// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v3alpha/lds.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V3Alpha {

  /// <summary>Holder for reflection information generated from envoy/api/v3alpha/lds.proto</summary>
  public static partial class LdsReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v3alpha/lds.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static LdsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChtlbnZveS9hcGkvdjNhbHBoYS9sZHMucHJvdG8SEWVudm95LmFwaS52M2Fs",
            "cGhhGiRlbnZveS9hcGkvdjNhbHBoYS9jb3JlL2FkZHJlc3MucHJvdG8aIWVu",
            "dm95L2FwaS92M2FscGhhL2NvcmUvYmFzZS5wcm90bxohZW52b3kvYXBpL3Yz",
            "YWxwaGEvZGlzY292ZXJ5LnByb3RvGillbnZveS9hcGkvdjNhbHBoYS9saXN0",
            "ZW5lci9saXN0ZW5lci5wcm90bxo0ZW52b3kvYXBpL3YzYWxwaGEvbGlzdGVu",
            "ZXIvdWRwX2xpc3RlbmVyX2NvbmZpZy5wcm90bxocZ29vZ2xlL2FwaS9hbm5v",
            "dGF0aW9ucy5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3Rv",
            "Gh5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8aF3ZhbGlkYXRlL3Zh",
            "bGlkYXRlLnByb3RvIt0ICghMaXN0ZW5lchIMCgRuYW1lGAEgASgJEjwKB2Fk",
            "ZHJlc3MYAiABKAsyHy5lbnZveS5hcGkudjNhbHBoYS5jb3JlLkFkZHJlc3NC",
            "CrrpwAMFigECEAESPgoNZmlsdGVyX2NoYWlucxgDIAMoCzInLmVudm95LmFw",
            "aS52M2FscGhhLmxpc3RlbmVyLkZpbHRlckNoYWluEjgKEHVzZV9vcmlnaW5h",
            "bF9kc3QYBCABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlQgIYARJH",
            "CiFwZXJfY29ubmVjdGlvbl9idWZmZXJfbGltaXRfYnl0ZXMYBSABKAsyHC5n",
            "b29nbGUucHJvdG9idWYuVUludDMyVmFsdWUSMgoIbWV0YWRhdGEYBiABKAsy",
            "IC5lbnZveS5hcGkudjNhbHBoYS5jb3JlLk1ldGFkYXRhEj8KDWRlcHJlY2F0",
            "ZWRfdjEYByABKAsyKC5lbnZveS5hcGkudjNhbHBoYS5MaXN0ZW5lci5EZXBy",
            "ZWNhdGVkVjESOQoKZHJhaW5fdHlwZRgIIAEoDjIlLmVudm95LmFwaS52M2Fs",
            "cGhhLkxpc3RlbmVyLkRyYWluVHlwZRJEChBsaXN0ZW5lcl9maWx0ZXJzGAkg",
            "AygLMiouZW52b3kuYXBpLnYzYWxwaGEubGlzdGVuZXIuTGlzdGVuZXJGaWx0",
            "ZXISOwoYbGlzdGVuZXJfZmlsdGVyc190aW1lb3V0GA8gASgLMhkuZ29vZ2xl",
            "LnByb3RvYnVmLkR1cmF0aW9uEiwKJGNvbnRpbnVlX29uX2xpc3RlbmVyX2Zp",
            "bHRlcnNfdGltZW91dBgRIAEoCBIvCgt0cmFuc3BhcmVudBgKIAEoCzIaLmdv",
            "b2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSLAoIZnJlZWJpbmQYCyABKAsyGi5n",
            "b29nbGUucHJvdG9idWYuQm9vbFZhbHVlEjwKDnNvY2tldF9vcHRpb25zGA0g",
            "AygLMiQuZW52b3kuYXBpLnYzYWxwaGEuY29yZS5Tb2NrZXRPcHRpb24SQAoa",
            "dGNwX2Zhc3Rfb3Blbl9xdWV1ZV9sZW5ndGgYDCABKAsyHC5nb29nbGUucHJv",
            "dG9idWYuVUludDMyVmFsdWUSQwoRdHJhZmZpY19kaXJlY3Rpb24YECABKA4y",
            "KC5lbnZveS5hcGkudjNhbHBoYS5jb3JlLlRyYWZmaWNEaXJlY3Rpb24SSgoT",
            "dWRwX2xpc3RlbmVyX2NvbmZpZxgSIAEoCzItLmVudm95LmFwaS52M2FscGhh",
            "Lmxpc3RlbmVyLlVkcExpc3RlbmVyQ29uZmlnGkAKDERlcHJlY2F0ZWRWMRIw",
            "CgxiaW5kX3RvX3BvcnQYASABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZh",
            "bHVlIikKCURyYWluVHlwZRILCgdERUZBVUxUEAASDwoLTU9ESUZZX09OTFkQ",
            "AUoECA4QDzLyAgoYTGlzdGVuZXJEaXNjb3ZlcnlTZXJ2aWNlEmsKDkRlbHRh",
            "TGlzdGVuZXJzEiguZW52b3kuYXBpLnYzYWxwaGEuRGVsdGFEaXNjb3ZlcnlS",
            "ZXF1ZXN0GikuZW52b3kuYXBpLnYzYWxwaGEuRGVsdGFEaXNjb3ZlcnlSZXNw",
            "b25zZSIAKAEwARJiCg9TdHJlYW1MaXN0ZW5lcnMSIy5lbnZveS5hcGkudjNh",
            "bHBoYS5EaXNjb3ZlcnlSZXF1ZXN0GiQuZW52b3kuYXBpLnYzYWxwaGEuRGlz",
            "Y292ZXJ5UmVzcG9uc2UiACgBMAEShAEKDkZldGNoTGlzdGVuZXJzEiMuZW52",
            "b3kuYXBpLnYzYWxwaGEuRGlzY292ZXJ5UmVxdWVzdBokLmVudm95LmFwaS52",
            "M2FscGhhLkRpc2NvdmVyeVJlc3BvbnNlIieC0+STAiEiHC92M2FscGhhL2Rp",
            "c2NvdmVyeTpsaXN0ZW5lcnM6ASpCMAofaW8uZW52b3lwcm94eS5lbnZveS5h",
            "cGkudjNhbHBoYUIITGRzUHJvdG9QAYgBAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V3Alpha.Core.AddressReflection.Descriptor, global::Envoy.Api.V3Alpha.Core.BaseReflection.Descriptor, global::Envoy.Api.V3Alpha.DiscoveryReflection.Descriptor, global::Envoy.Api.V3Alpha.ListenerNS.ListenerReflection.Descriptor, global::Envoy.Api.V3Alpha.ListenerNS.UdpListenerConfigReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V3Alpha.Listener), global::Envoy.Api.V3Alpha.Listener.Parser, new[]{ "Name", "Address", "FilterChains", "UseOriginalDst", "PerConnectionBufferLimitBytes", "Metadata", "DeprecatedV1", "DrainType", "ListenerFilters", "ListenerFiltersTimeout", "ContinueOnListenerFiltersTimeout", "Transparent", "Freebind", "SocketOptions", "TcpFastOpenQueueLength", "TrafficDirection", "UdpListenerConfig" }, null, new[]{ typeof(global::Envoy.Api.V3Alpha.Listener.Types.DrainType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V3Alpha.Listener.Types.DeprecatedV1), global::Envoy.Api.V3Alpha.Listener.Types.DeprecatedV1.Parser, new[]{ "BindToPort" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#comment:next free field: 19]
  /// </summary>
  public sealed partial class Listener : pb::IMessage<Listener> {
    private static readonly pb::MessageParser<Listener> _parser = new pb::MessageParser<Listener>(() => new Listener());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Listener> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V3Alpha.LdsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener(Listener other) : this() {
      name_ = other.name_;
      address_ = other.address_ != null ? other.address_.Clone() : null;
      filterChains_ = other.filterChains_.Clone();
      UseOriginalDst = other.UseOriginalDst;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      deprecatedV1_ = other.deprecatedV1_ != null ? other.deprecatedV1_.Clone() : null;
      drainType_ = other.drainType_;
      listenerFilters_ = other.listenerFilters_.Clone();
      listenerFiltersTimeout_ = other.listenerFiltersTimeout_ != null ? other.listenerFiltersTimeout_.Clone() : null;
      continueOnListenerFiltersTimeout_ = other.continueOnListenerFiltersTimeout_;
      Transparent = other.Transparent;
      Freebind = other.Freebind;
      socketOptions_ = other.socketOptions_.Clone();
      TcpFastOpenQueueLength = other.TcpFastOpenQueueLength;
      trafficDirection_ = other.trafficDirection_;
      udpListenerConfig_ = other.udpListenerConfig_ != null ? other.udpListenerConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener Clone() {
      return new Listener(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The unique name by which this listener is known. If no name is provided,
    /// Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
    /// updated or removed via :ref:`LDS &lt;config_listeners_lds>` a unique name must be provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private global::Envoy.Api.V3Alpha.Core.Address address_;
    /// <summary>
    /// The address that the listener should listen on. In general, the address must be unique, though
    /// that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
    /// Linux as the actual port will be allocated by the OS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.Address Address {
      get { return address_; }
      set {
        address_ = value;
      }
    }

    /// <summary>Field number for the "filter_chains" field.</summary>
    public const int FilterChainsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Api.V3Alpha.ListenerNS.FilterChain> _repeated_filterChains_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V3Alpha.ListenerNS.FilterChain.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V3Alpha.ListenerNS.FilterChain> filterChains_ = new pbc::RepeatedField<global::Envoy.Api.V3Alpha.ListenerNS.FilterChain>();
    /// <summary>
    /// A list of filter chains to consider for this listener. The
    /// :ref:`FilterChain &lt;envoy_api_msg_listener.FilterChain>` with the most specific
    /// :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>` criteria is used on a
    /// connection.
    ///
    /// Example using SNI for filter chain selection can be found in the
    /// :ref:`FAQ entry &lt;faq_how_to_setup_sni>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V3Alpha.ListenerNS.FilterChain> FilterChains {
      get { return filterChains_; }
    }

    /// <summary>Field number for the "use_original_dst" field.</summary>
    public const int UseOriginalDstFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_useOriginalDst_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? useOriginalDst_;
    /// <summary>
    /// If a connection is redirected using *iptables*, the port on which the proxy
    /// receives it might be different from the original destination address. When this flag is set to
    /// true, the listener hands off redirected connections to the listener associated with the
    /// original destination address. If there is no listener associated with the original destination
    /// address, the connection is handled by the listener that receives it. Defaults to false.
    ///
    /// .. attention::
    ///
    ///   This field is deprecated. Use :ref:`an original_dst &lt;config_listener_filters_original_dst>`
    ///   :ref:`listener filter &lt;envoy_api_field_Listener.listener_filters>` instead.
    ///
    ///   Note that hand off to another listener is *NOT* performed without this flag. Once
    ///   :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>` is implemented this flag
    ///   will be removed, as filter chain matching can be used to select a filter chain based on the
    ///   restored destination address.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? UseOriginalDst {
      get { return useOriginalDst_; }
      set {
        useOriginalDst_ = value;
      }
    }


    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the listener’s new connection read and write buffers.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }


    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 6;
    private global::Envoy.Api.V3Alpha.Core.Metadata metadata_;
    /// <summary>
    /// Listener metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "deprecated_v1" field.</summary>
    public const int DeprecatedV1FieldNumber = 7;
    private global::Envoy.Api.V3Alpha.Listener.Types.DeprecatedV1 deprecatedV1_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Listener.Types.DeprecatedV1 DeprecatedV1 {
      get { return deprecatedV1_; }
      set {
        deprecatedV1_ = value;
      }
    }

    /// <summary>Field number for the "drain_type" field.</summary>
    public const int DrainTypeFieldNumber = 8;
    private global::Envoy.Api.V3Alpha.Listener.Types.DrainType drainType_ = global::Envoy.Api.V3Alpha.Listener.Types.DrainType.Default;
    /// <summary>
    /// The type of draining to perform at a listener-wide level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Listener.Types.DrainType DrainType {
      get { return drainType_; }
      set {
        drainType_ = value;
      }
    }

    /// <summary>Field number for the "listener_filters" field.</summary>
    public const int ListenerFiltersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Api.V3Alpha.ListenerNS.ListenerFilter> _repeated_listenerFilters_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Api.V3Alpha.ListenerNS.ListenerFilter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V3Alpha.ListenerNS.ListenerFilter> listenerFilters_ = new pbc::RepeatedField<global::Envoy.Api.V3Alpha.ListenerNS.ListenerFilter>();
    /// <summary>
    /// Listener filters have the opportunity to manipulate and augment the connection metadata that
    /// is used in connection filter chain matching, for example. These filters are run before any in
    /// :ref:`filter_chains &lt;envoy_api_field_Listener.filter_chains>`. Order matters as the
    /// filters are processed sequentially right after a socket has been accepted by the listener, and
    /// before a connection is created.
    /// UDP Listener filters can be specified when the protocol in the listener socket address in
    /// :ref:`protocol &lt;envoy_api_field_core.SocketAddress.protocol>` is :ref:'UDP
    /// &lt;envoy_api_field_core.Protocol.UDP>`.
    /// UDP listeners currently support a single filter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V3Alpha.ListenerNS.ListenerFilter> ListenerFilters {
      get { return listenerFilters_; }
    }

    /// <summary>Field number for the "listener_filters_timeout" field.</summary>
    public const int ListenerFiltersTimeoutFieldNumber = 15;
    private global::Google.Protobuf.WellKnownTypes.Duration listenerFiltersTimeout_;
    /// <summary>
    /// The timeout to wait for all listener filters to complete operation. If the timeout is reached,
    /// the accepted socket is closed without a connection being created unless
    /// `continue_on_listener_filters_timeout` is set to true. Specify 0 to disable the
    /// timeout. If not specified, a default timeout of 15s is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration ListenerFiltersTimeout {
      get { return listenerFiltersTimeout_; }
      set {
        listenerFiltersTimeout_ = value;
      }
    }

    /// <summary>Field number for the "continue_on_listener_filters_timeout" field.</summary>
    public const int ContinueOnListenerFiltersTimeoutFieldNumber = 17;
    private bool continueOnListenerFiltersTimeout_;
    /// <summary>
    /// Whether a connection should be created when listener filters timeout. Default is false.
    ///
    /// .. attention::
    ///
    ///   Some listener filters, such as :ref:`Proxy Protocol filter
    ///   &lt;config_listener_filters_proxy_protocol>`, should not be used with this option. It will cause
    ///   unexpected behavior when a connection is created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ContinueOnListenerFiltersTimeout {
      get { return continueOnListenerFiltersTimeout_; }
      set {
        continueOnListenerFiltersTimeout_ = value;
      }
    }

    /// <summary>Field number for the "transparent" field.</summary>
    public const int TransparentFieldNumber = 10;
    private static readonly pb::FieldCodec<bool?> _single_transparent_codec = pb::FieldCodec.ForStructWrapper<bool>(82);
    private bool? transparent_;
    /// <summary>
    /// Whether the listener should be set as a transparent socket.
    /// When this flag is set to true, connections can be redirected to the listener using an
    /// *iptables* *TPROXY* target, in which case the original source and destination addresses and
    /// ports are preserved on accepted connections. This flag should be used in combination with
    /// :ref:`an original_dst &lt;config_listener_filters_original_dst>` :ref:`listener filter
    /// &lt;envoy_api_field_Listener.listener_filters>` to mark the connections' local addresses as
    /// "restored." This can be used to hand off each redirected connection to another listener
    /// associated with the connection's destination address. Direct connections to the socket without
    /// using *TPROXY* cannot be distinguished from connections redirected using *TPROXY* and are
    /// therefore treated as if they were redirected.
    /// When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
    /// Setting this flag requires Envoy to run with the *CAP_NET_ADMIN* capability.
    /// When this flag is not set (default), the socket is not modified, i.e. the transparent option
    /// is neither set nor reset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Transparent {
      get { return transparent_; }
      set {
        transparent_ = value;
      }
    }


    /// <summary>Field number for the "freebind" field.</summary>
    public const int FreebindFieldNumber = 11;
    private static readonly pb::FieldCodec<bool?> _single_freebind_codec = pb::FieldCodec.ForStructWrapper<bool>(90);
    private bool? freebind_;
    /// <summary>
    /// Whether the listener should set the *IP_FREEBIND* socket option. When this
    /// flag is set to true, listeners can be bound to an IP address that is not
    /// configured on the system running Envoy. When this flag is set to false, the
    /// option *IP_FREEBIND* is disabled on the socket. When this flag is not set
    /// (default), the socket is not modified, i.e. the option is neither enabled
    /// nor disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Freebind {
      get { return freebind_; }
      set {
        freebind_ = value;
      }
    }


    /// <summary>Field number for the "socket_options" field.</summary>
    public const int SocketOptionsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Api.V3Alpha.Core.SocketOption> _repeated_socketOptions_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Api.V3Alpha.Core.SocketOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V3Alpha.Core.SocketOption> socketOptions_ = new pbc::RepeatedField<global::Envoy.Api.V3Alpha.Core.SocketOption>();
    /// <summary>
    /// Additional socket options that may not be present in Envoy source code or
    /// precompiled binaries.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V3Alpha.Core.SocketOption> SocketOptions {
      get { return socketOptions_; }
    }

    /// <summary>Field number for the "tcp_fast_open_queue_length" field.</summary>
    public const int TcpFastOpenQueueLengthFieldNumber = 12;
    private static readonly pb::FieldCodec<uint?> _single_tcpFastOpenQueueLength_codec = pb::FieldCodec.ForStructWrapper<uint>(98);
    private uint? tcpFastOpenQueueLength_;
    /// <summary>
    /// Whether the listener should accept TCP Fast Open (TFO) connections.
    /// When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
    /// the socket, with a queue length of the specified size
    /// (see `details in RFC7413 &lt;https://tools.ietf.org/html/rfc7413#section-5.1>`_).
    /// When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
    /// When this flag is not set (default), the socket is not modified,
    /// i.e. the option is neither enabled nor disabled.
    ///
    /// On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
    /// TCP_FASTOPEN.
    /// See `ip-sysctl.txt &lt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>`_.
    ///
    /// On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
    /// To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? TcpFastOpenQueueLength {
      get { return tcpFastOpenQueueLength_; }
      set {
        tcpFastOpenQueueLength_ = value;
      }
    }


    /// <summary>Field number for the "traffic_direction" field.</summary>
    public const int TrafficDirectionFieldNumber = 16;
    private global::Envoy.Api.V3Alpha.Core.TrafficDirection trafficDirection_ = global::Envoy.Api.V3Alpha.Core.TrafficDirection.Unspecified;
    /// <summary>
    /// Specifies the intended direction of the traffic relative to the local Envoy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.TrafficDirection TrafficDirection {
      get { return trafficDirection_; }
      set {
        trafficDirection_ = value;
      }
    }

    /// <summary>Field number for the "udp_listener_config" field.</summary>
    public const int UdpListenerConfigFieldNumber = 18;
    private global::Envoy.Api.V3Alpha.ListenerNS.UdpListenerConfig udpListenerConfig_;
    /// <summary>
    /// If the protocol in the listener socket address in :ref:`protocol
    /// &lt;envoy_api_field_core.SocketAddress.protocol>` is :ref:'UDP
    /// &lt;envoy_api_field_core.Protocol.UDP>`, this field specifies the actual udp listener to create,
    /// i.e. :ref:`udp_listener_name
    /// &lt;envoy_api_field_listener.UdpListenerConfig.udp_listener_name>` = "raw_udp_listener" for
    /// creating a packet-oriented UDP listener. If not present, treat it as "raw_udp_listener".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.ListenerNS.UdpListenerConfig UdpListenerConfig {
      get { return udpListenerConfig_; }
      set {
        udpListenerConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Listener);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Listener other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Address, other.Address)) return false;
      if(!filterChains_.Equals(other.filterChains_)) return false;
      if (UseOriginalDst != other.UseOriginalDst) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
      if (DrainType != other.DrainType) return false;
      if(!listenerFilters_.Equals(other.listenerFilters_)) return false;
      if (!object.Equals(ListenerFiltersTimeout, other.ListenerFiltersTimeout)) return false;
      if (ContinueOnListenerFiltersTimeout != other.ContinueOnListenerFiltersTimeout) return false;
      if (Transparent != other.Transparent) return false;
      if (Freebind != other.Freebind) return false;
      if(!socketOptions_.Equals(other.socketOptions_)) return false;
      if (TcpFastOpenQueueLength != other.TcpFastOpenQueueLength) return false;
      if (TrafficDirection != other.TrafficDirection) return false;
      if (!object.Equals(UdpListenerConfig, other.UdpListenerConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (address_ != null) hash ^= Address.GetHashCode();
      hash ^= filterChains_.GetHashCode();
      if (useOriginalDst_ != null) hash ^= UseOriginalDst.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
      if (DrainType != global::Envoy.Api.V3Alpha.Listener.Types.DrainType.Default) hash ^= DrainType.GetHashCode();
      hash ^= listenerFilters_.GetHashCode();
      if (listenerFiltersTimeout_ != null) hash ^= ListenerFiltersTimeout.GetHashCode();
      if (ContinueOnListenerFiltersTimeout != false) hash ^= ContinueOnListenerFiltersTimeout.GetHashCode();
      if (transparent_ != null) hash ^= Transparent.GetHashCode();
      if (freebind_ != null) hash ^= Freebind.GetHashCode();
      hash ^= socketOptions_.GetHashCode();
      if (tcpFastOpenQueueLength_ != null) hash ^= TcpFastOpenQueueLength.GetHashCode();
      if (TrafficDirection != global::Envoy.Api.V3Alpha.Core.TrafficDirection.Unspecified) hash ^= TrafficDirection.GetHashCode();
      if (udpListenerConfig_ != null) hash ^= UdpListenerConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (address_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Address);
      }
      filterChains_.WriteTo(output, _repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        _single_useOriginalDst_codec.WriteTagAndValue(output, UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (deprecatedV1_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DeprecatedV1);
      }
      if (DrainType != global::Envoy.Api.V3Alpha.Listener.Types.DrainType.Default) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DrainType);
      }
      listenerFilters_.WriteTo(output, _repeated_listenerFilters_codec);
      if (transparent_ != null) {
        _single_transparent_codec.WriteTagAndValue(output, Transparent);
      }
      if (freebind_ != null) {
        _single_freebind_codec.WriteTagAndValue(output, Freebind);
      }
      if (tcpFastOpenQueueLength_ != null) {
        _single_tcpFastOpenQueueLength_codec.WriteTagAndValue(output, TcpFastOpenQueueLength);
      }
      socketOptions_.WriteTo(output, _repeated_socketOptions_codec);
      if (listenerFiltersTimeout_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(ListenerFiltersTimeout);
      }
      if (TrafficDirection != global::Envoy.Api.V3Alpha.Core.TrafficDirection.Unspecified) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) TrafficDirection);
      }
      if (ContinueOnListenerFiltersTimeout != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(ContinueOnListenerFiltersTimeout);
      }
      if (udpListenerConfig_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(UdpListenerConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (address_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Address);
      }
      size += filterChains_.CalculateSize(_repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        size += _single_useOriginalDst_codec.CalculateSizeWithTag(UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (deprecatedV1_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
      }
      if (DrainType != global::Envoy.Api.V3Alpha.Listener.Types.DrainType.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DrainType);
      }
      size += listenerFilters_.CalculateSize(_repeated_listenerFilters_codec);
      if (listenerFiltersTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ListenerFiltersTimeout);
      }
      if (ContinueOnListenerFiltersTimeout != false) {
        size += 2 + 1;
      }
      if (transparent_ != null) {
        size += _single_transparent_codec.CalculateSizeWithTag(Transparent);
      }
      if (freebind_ != null) {
        size += _single_freebind_codec.CalculateSizeWithTag(Freebind);
      }
      size += socketOptions_.CalculateSize(_repeated_socketOptions_codec);
      if (tcpFastOpenQueueLength_ != null) {
        size += _single_tcpFastOpenQueueLength_codec.CalculateSizeWithTag(TcpFastOpenQueueLength);
      }
      if (TrafficDirection != global::Envoy.Api.V3Alpha.Core.TrafficDirection.Unspecified) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) TrafficDirection);
      }
      if (udpListenerConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UdpListenerConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Listener other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.address_ != null) {
        if (address_ == null) {
          Address = new global::Envoy.Api.V3Alpha.Core.Address();
        }
        Address.MergeFrom(other.Address);
      }
      filterChains_.Add(other.filterChains_);
      if (other.useOriginalDst_ != null) {
        if (useOriginalDst_ == null || other.UseOriginalDst != false) {
          UseOriginalDst = other.UseOriginalDst;
        }
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Envoy.Api.V3Alpha.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.deprecatedV1_ != null) {
        if (deprecatedV1_ == null) {
          DeprecatedV1 = new global::Envoy.Api.V3Alpha.Listener.Types.DeprecatedV1();
        }
        DeprecatedV1.MergeFrom(other.DeprecatedV1);
      }
      if (other.DrainType != global::Envoy.Api.V3Alpha.Listener.Types.DrainType.Default) {
        DrainType = other.DrainType;
      }
      listenerFilters_.Add(other.listenerFilters_);
      if (other.listenerFiltersTimeout_ != null) {
        if (listenerFiltersTimeout_ == null) {
          ListenerFiltersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ListenerFiltersTimeout.MergeFrom(other.ListenerFiltersTimeout);
      }
      if (other.ContinueOnListenerFiltersTimeout != false) {
        ContinueOnListenerFiltersTimeout = other.ContinueOnListenerFiltersTimeout;
      }
      if (other.transparent_ != null) {
        if (transparent_ == null || other.Transparent != false) {
          Transparent = other.Transparent;
        }
      }
      if (other.freebind_ != null) {
        if (freebind_ == null || other.Freebind != false) {
          Freebind = other.Freebind;
        }
      }
      socketOptions_.Add(other.socketOptions_);
      if (other.tcpFastOpenQueueLength_ != null) {
        if (tcpFastOpenQueueLength_ == null || other.TcpFastOpenQueueLength != 0) {
          TcpFastOpenQueueLength = other.TcpFastOpenQueueLength;
        }
      }
      if (other.TrafficDirection != global::Envoy.Api.V3Alpha.Core.TrafficDirection.Unspecified) {
        TrafficDirection = other.TrafficDirection;
      }
      if (other.udpListenerConfig_ != null) {
        if (udpListenerConfig_ == null) {
          UdpListenerConfig = new global::Envoy.Api.V3Alpha.ListenerNS.UdpListenerConfig();
        }
        UdpListenerConfig.MergeFrom(other.UdpListenerConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (address_ == null) {
              Address = new global::Envoy.Api.V3Alpha.Core.Address();
            }
            input.ReadMessage(Address);
            break;
          }
          case 26: {
            filterChains_.AddEntriesFrom(input, _repeated_filterChains_codec);
            break;
          }
          case 34: {
            bool? value = _single_useOriginalDst_codec.Read(input);
            if (useOriginalDst_ == null || value != false) {
              UseOriginalDst = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Api.V3Alpha.Core.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 58: {
            if (deprecatedV1_ == null) {
              DeprecatedV1 = new global::Envoy.Api.V3Alpha.Listener.Types.DeprecatedV1();
            }
            input.ReadMessage(DeprecatedV1);
            break;
          }
          case 64: {
            DrainType = (global::Envoy.Api.V3Alpha.Listener.Types.DrainType) input.ReadEnum();
            break;
          }
          case 74: {
            listenerFilters_.AddEntriesFrom(input, _repeated_listenerFilters_codec);
            break;
          }
          case 82: {
            bool? value = _single_transparent_codec.Read(input);
            if (transparent_ == null || value != false) {
              Transparent = value;
            }
            break;
          }
          case 90: {
            bool? value = _single_freebind_codec.Read(input);
            if (freebind_ == null || value != false) {
              Freebind = value;
            }
            break;
          }
          case 98: {
            uint? value = _single_tcpFastOpenQueueLength_codec.Read(input);
            if (tcpFastOpenQueueLength_ == null || value != 0) {
              TcpFastOpenQueueLength = value;
            }
            break;
          }
          case 106: {
            socketOptions_.AddEntriesFrom(input, _repeated_socketOptions_codec);
            break;
          }
          case 122: {
            if (listenerFiltersTimeout_ == null) {
              ListenerFiltersTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ListenerFiltersTimeout);
            break;
          }
          case 128: {
            TrafficDirection = (global::Envoy.Api.V3Alpha.Core.TrafficDirection) input.ReadEnum();
            break;
          }
          case 136: {
            ContinueOnListenerFiltersTimeout = input.ReadBool();
            break;
          }
          case 146: {
            if (udpListenerConfig_ == null) {
              UdpListenerConfig = new global::Envoy.Api.V3Alpha.ListenerNS.UdpListenerConfig();
            }
            input.ReadMessage(UdpListenerConfig);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Listener message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum DrainType {
        /// <summary>
        /// Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
        /// filter), listener removal/modification, and hot restart.
        /// </summary>
        [pbr::OriginalName("DEFAULT")] Default = 0,
        /// <summary>
        /// Drain in response to listener removal/modification and hot restart. This setting does not
        /// include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
        /// and egress listeners.
        /// </summary>
        [pbr::OriginalName("MODIFY_ONLY")] ModifyOnly = 1,
      }

      /// <summary>
      /// [#not-implemented-hide:]
      /// </summary>
      public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1> {
        private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V3Alpha.Listener.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1(DeprecatedV1 other) : this() {
          BindToPort = other.BindToPort;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1 Clone() {
          return new DeprecatedV1(this);
        }

        /// <summary>Field number for the "bind_to_port" field.</summary>
        public const int BindToPortFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_bindToPort_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? bindToPort_;
        /// <summary>
        /// Whether the listener should bind to the port. A listener that doesn't
        /// bind can only receive connections redirected from other listeners that
        /// set use_original_dst parameter to true. Default is true.
        ///
        /// [V2-API-DIFF] This is deprecated in v2, all Listeners will bind to their
        /// port. An additional filter chain must be created for every original
        /// destination port this listener may redirect to in v2, with the original
        /// port specified in the FilterChainMatch destination_port field.
        ///
        /// [#comment:TODO(PiotrSikora): Remove this once verified that we no longer need it.]
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? BindToPort {
          get { return bindToPort_; }
          set {
            bindToPort_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DeprecatedV1);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeprecatedV1 other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (BindToPort != other.BindToPort) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (bindToPort_ != null) hash ^= BindToPort.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (bindToPort_ != null) {
            _single_bindToPort_codec.WriteTagAndValue(output, BindToPort);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (bindToPort_ != null) {
            size += _single_bindToPort_codec.CalculateSizeWithTag(BindToPort);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeprecatedV1 other) {
          if (other == null) {
            return;
          }
          if (other.bindToPort_ != null) {
            if (bindToPort_ == null || other.BindToPort != false) {
              BindToPort = other.BindToPort;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                bool? value = _single_bindToPort_codec.Read(input);
                if (bindToPort_ == null || value != false) {
                  BindToPort = value;
                }
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
