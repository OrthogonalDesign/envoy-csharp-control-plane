// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/cds.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2 {

  /// <summary>Holder for reflection information generated from envoy/api/v2/cds.proto</summary>
  public static partial class CdsReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/cds.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CdsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZlbnZveS9hcGkvdjIvY2RzLnByb3RvEgxlbnZveS5hcGkudjIaH2Vudm95",
            "L2FwaS92Mi9jb3JlL2FkZHJlc3MucHJvdG8aHGVudm95L2FwaS92Mi9hdXRo",
            "L2NlcnQucHJvdG8aHGVudm95L2FwaS92Mi9jb3JlL2Jhc2UucHJvdG8aJWVu",
            "dm95L2FwaS92Mi9jb3JlL2NvbmZpZ19zb3VyY2UucHJvdG8aHGVudm95L2Fw",
            "aS92Mi9kaXNjb3ZlcnkucHJvdG8aJGVudm95L2FwaS92Mi9jb3JlL2hlYWx0",
            "aF9jaGVjay5wcm90bxogZW52b3kvYXBpL3YyL2NvcmUvcHJvdG9jb2wucHJv",
            "dG8aKmVudm95L2FwaS92Mi9jbHVzdGVyL2NpcmN1aXRfYnJlYWtlci5wcm90",
            "bxohZW52b3kvYXBpL3YyL2NsdXN0ZXIvZmlsdGVyLnByb3RvGixlbnZveS9h",
            "cGkvdjIvY2x1c3Rlci9vdXRsaWVyX2RldGVjdGlvbi5wcm90bxoWZW52b3kv",
            "YXBpL3YyL2Vkcy5wcm90bxoYZW52b3kvdHlwZS9wZXJjZW50LnByb3RvGhxn",
            "b29nbGUvYXBpL2Fubm90YXRpb25zLnByb3RvGhlnb29nbGUvcHJvdG9idWYv",
            "YW55LnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8aHGdv",
            "b2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93",
            "cmFwcGVycy5wcm90bxoXdmFsaWRhdGUvdmFsaWRhdGUucHJvdG8ipScKB0Ns",
            "dXN0ZXISFwoEbmFtZRgBIAEoCUIJuunAAwRyAiABEhUKDWFsdF9zdGF0X25h",
            "bWUYHCABKAkSPwoEdHlwZRgCIAEoDjIjLmVudm95LmFwaS52Mi5DbHVzdGVy",
            "LkRpc2NvdmVyeVR5cGVCCrrpwAMFggECEAFIABI/CgxjbHVzdGVyX3R5cGUY",
            "JiABKAsyJy5lbnZveS5hcGkudjIuQ2x1c3Rlci5DdXN0b21DbHVzdGVyVHlw",
            "ZUgAEkIKEmVkc19jbHVzdGVyX2NvbmZpZxgDIAEoCzImLmVudm95LmFwaS52",
            "Mi5DbHVzdGVyLkVkc0NsdXN0ZXJDb25maWcSPgoPY29ubmVjdF90aW1lb3V0",
            "GAQgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgq66cADBaoBAioA",
            "EkcKIXBlcl9jb25uZWN0aW9uX2J1ZmZlcl9saW1pdF9ieXRlcxgFIAEoCzIc",
            "Lmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZRI9CglsYl9wb2xpY3kYBiAB",
            "KA4yHi5lbnZveS5hcGkudjIuQ2x1c3Rlci5MYlBvbGljeUIKuunAAwWCAQIQ",
            "ARIpCgVob3N0cxgHIAMoCzIaLmVudm95LmFwaS52Mi5jb3JlLkFkZHJlc3MS",
            "PAoPbG9hZF9hc3NpZ25tZW50GCEgASgLMiMuZW52b3kuYXBpLnYyLkNsdXN0",
            "ZXJMb2FkQXNzaWdubWVudBI1Cg1oZWFsdGhfY2hlY2tzGAggAygLMh4uZW52",
            "b3kuYXBpLnYyLmNvcmUuSGVhbHRoQ2hlY2sSQQobbWF4X3JlcXVlc3RzX3Bl",
            "cl9jb25uZWN0aW9uGAkgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZh",
            "bHVlEj8KEGNpcmN1aXRfYnJlYWtlcnMYCiABKAsyJS5lbnZveS5hcGkudjIu",
            "Y2x1c3Rlci5DaXJjdWl0QnJlYWtlcnMSOgoLdGxzX2NvbnRleHQYCyABKAsy",
            "JS5lbnZveS5hcGkudjIuYXV0aC5VcHN0cmVhbVRsc0NvbnRleHQSTAocY29t",
            "bW9uX2h0dHBfcHJvdG9jb2xfb3B0aW9ucxgdIAEoCzImLmVudm95LmFwaS52",
            "Mi5jb3JlLkh0dHBQcm90b2NvbE9wdGlvbnMSRgoVaHR0cF9wcm90b2NvbF9v",
            "cHRpb25zGA0gASgLMicuZW52b3kuYXBpLnYyLmNvcmUuSHR0cDFQcm90b2Nv",
            "bE9wdGlvbnMSRwoWaHR0cDJfcHJvdG9jb2xfb3B0aW9ucxgOIAEoCzInLmVu",
            "dm95LmFwaS52Mi5jb3JlLkh0dHAyUHJvdG9jb2xPcHRpb25zElcKGmV4dGVu",
            "c2lvbl9wcm90b2NvbF9vcHRpb25zGCMgAygLMjMuZW52b3kuYXBpLnYyLkNs",
            "dXN0ZXIuRXh0ZW5zaW9uUHJvdG9jb2xPcHRpb25zRW50cnkSYgogdHlwZWRf",
            "ZXh0ZW5zaW9uX3Byb3RvY29sX29wdGlvbnMYJCADKAsyOC5lbnZveS5hcGku",
            "djIuQ2x1c3Rlci5UeXBlZEV4dGVuc2lvblByb3RvY29sT3B0aW9uc0VudHJ5",
            "Ej8KEGRuc19yZWZyZXNoX3JhdGUYECABKAsyGS5nb29nbGUucHJvdG9idWYu",
            "RHVyYXRpb25CCrrpwAMFqgECKgASFwoPcmVzcGVjdF9kbnNfdHRsGCcgASgI",
            "EkwKEWRuc19sb29rdXBfZmFtaWx5GBEgASgOMiUuZW52b3kuYXBpLnYyLkNs",
            "dXN0ZXIuRG5zTG9va3VwRmFtaWx5Qgq66cADBYIBAhABEjEKDWRuc19yZXNv",
            "bHZlcnMYEiADKAsyGi5lbnZveS5hcGkudjIuY29yZS5BZGRyZXNzEkEKEW91",
            "dGxpZXJfZGV0ZWN0aW9uGBMgASgLMiYuZW52b3kuYXBpLnYyLmNsdXN0ZXIu",
            "T3V0bGllckRldGVjdGlvbhI/ChBjbGVhbnVwX2ludGVydmFsGBQgASgLMhku",
            "Z29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQgq66cADBaoBAioAEjsKFHVwc3Ry",
            "ZWFtX2JpbmRfY29uZmlnGBUgASgLMh0uZW52b3kuYXBpLnYyLmNvcmUuQmlu",
            "ZENvbmZpZxI+ChBsYl9zdWJzZXRfY29uZmlnGBYgASgLMiQuZW52b3kuYXBp",
            "LnYyLkNsdXN0ZXIuTGJTdWJzZXRDb25maWcSRQoTcmluZ19oYXNoX2xiX2Nv",
            "bmZpZxgXIAEoCzImLmVudm95LmFwaS52Mi5DbHVzdGVyLlJpbmdIYXNoTGJD",
            "b25maWdIARJLChZvcmlnaW5hbF9kc3RfbGJfY29uZmlnGCIgASgLMikuZW52",
            "b3kuYXBpLnYyLkNsdXN0ZXIuT3JpZ2luYWxEc3RMYkNvbmZpZ0gBEk0KF2xl",
            "YXN0X3JlcXVlc3RfbGJfY29uZmlnGCUgASgLMiouZW52b3kuYXBpLnYyLkNs",
            "dXN0ZXIuTGVhc3RSZXF1ZXN0TGJDb25maWdIARI+ChBjb21tb25fbGJfY29u",
            "ZmlnGBsgASgLMiQuZW52b3kuYXBpLnYyLkNsdXN0ZXIuQ29tbW9uTGJDb25m",
            "aWcSPAoQdHJhbnNwb3J0X3NvY2tldBgYIAEoCzIiLmVudm95LmFwaS52Mi5j",
            "b3JlLlRyYW5zcG9ydFNvY2tldBItCghtZXRhZGF0YRgZIAEoCzIbLmVudm95",
            "LmFwaS52Mi5jb3JlLk1ldGFkYXRhEkoKEnByb3RvY29sX3NlbGVjdGlvbhga",
            "IAEoDjIuLmVudm95LmFwaS52Mi5DbHVzdGVyLkNsdXN0ZXJQcm90b2NvbFNl",
            "bGVjdGlvbhJMCht1cHN0cmVhbV9jb25uZWN0aW9uX29wdGlvbnMYHiABKAsy",
            "Jy5lbnZveS5hcGkudjIuVXBzdHJlYW1Db25uZWN0aW9uT3B0aW9ucxIwCihj",
            "bG9zZV9jb25uZWN0aW9uc19vbl9ob3N0X2hlYWx0aF9mYWlsdXJlGB8gASgI",
            "EikKIWRyYWluX2Nvbm5lY3Rpb25zX29uX2hvc3RfcmVtb3ZhbBggIAEoCBIt",
            "CgdmaWx0ZXJzGCggAygLMhwuZW52b3kuYXBpLnYyLmNsdXN0ZXIuRmlsdGVy",
            "EkAKFWxvYWRfYmFsYW5jaW5nX3BvbGljeRgpIAEoCzIhLmVudm95LmFwaS52",
            "Mi5Mb2FkQmFsYW5jaW5nUG9saWN5GlgKEUN1c3RvbUNsdXN0ZXJUeXBlEhcK",
            "BG5hbWUYASABKAlCCbrpwAMEcgIgARIqCgx0eXBlZF9jb25maWcYAiABKAsy",
            "FC5nb29nbGUucHJvdG9idWYuQW55Gl0KEEVkc0NsdXN0ZXJDb25maWcSMwoK",
            "ZWRzX2NvbmZpZxgBIAEoCzIfLmVudm95LmFwaS52Mi5jb3JlLkNvbmZpZ1Nv",
            "dXJjZRIUCgxzZXJ2aWNlX25hbWUYAiABKAkaWAodRXh0ZW5zaW9uUHJvdG9j",
            "b2xPcHRpb25zRW50cnkSCwoDa2V5GAEgASgJEiYKBXZhbHVlGAIgASgLMhcu",
            "Z29vZ2xlLnByb3RvYnVmLlN0cnVjdDoCOAEaWgoiVHlwZWRFeHRlbnNpb25Q",
            "cm90b2NvbE9wdGlvbnNFbnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUYAiAB",
            "KAsyFC5nb29nbGUucHJvdG9idWYuQW55OgI4ARq4BQoOTGJTdWJzZXRDb25m",
            "aWcSYAoPZmFsbGJhY2tfcG9saWN5GAEgASgOMjsuZW52b3kuYXBpLnYyLkNs",
            "dXN0ZXIuTGJTdWJzZXRDb25maWcuTGJTdWJzZXRGYWxsYmFja1BvbGljeUIK",
            "uunAAwWCAQIQARIvCg5kZWZhdWx0X3N1YnNldBgCIAEoCzIXLmdvb2dsZS5w",
            "cm90b2J1Zi5TdHJ1Y3QSTwoQc3Vic2V0X3NlbGVjdG9ycxgDIAMoCzI1LmVu",
            "dm95LmFwaS52Mi5DbHVzdGVyLkxiU3Vic2V0Q29uZmlnLkxiU3Vic2V0U2Vs",
            "ZWN0b3ISHQoVbG9jYWxpdHlfd2VpZ2h0X2F3YXJlGAQgASgIEh0KFXNjYWxl",
            "X2xvY2FsaXR5X3dlaWdodBgFIAEoCBIWCg5wYW5pY19tb2RlX2FueRgGIAEo",
            "CBITCgtsaXN0X2FzX2FueRgHIAEoCBqFAgoQTGJTdWJzZXRTZWxlY3RvchIM",
            "CgRrZXlzGAEgAygJEnkKD2ZhbGxiYWNrX3BvbGljeRgCIAEoDjJULmVudm95",
            "LmFwaS52Mi5DbHVzdGVyLkxiU3Vic2V0Q29uZmlnLkxiU3Vic2V0U2VsZWN0",
            "b3IuTGJTdWJzZXRTZWxlY3RvckZhbGxiYWNrUG9saWN5Qgq66cADBYIBAhAB",
            "ImgKHkxiU3Vic2V0U2VsZWN0b3JGYWxsYmFja1BvbGljeRIPCgtOT1RfREVG",
            "SU5FRBAAEg8KC05PX0ZBTExCQUNLEAESEAoMQU5ZX0VORFBPSU5UEAISEgoO",
            "REVGQVVMVF9TVUJTRVQQAyJPChZMYlN1YnNldEZhbGxiYWNrUG9saWN5Eg8K",
            "C05PX0ZBTExCQUNLEAASEAoMQU5ZX0VORFBPSU5UEAESEgoOREVGQVVMVF9T",
            "VUJTRVQQAhpVChRMZWFzdFJlcXVlc3RMYkNvbmZpZxI9CgxjaG9pY2VfY291",
            "bnQYASABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCCbrpwAME",
            "KgIoAhquAgoQUmluZ0hhc2hMYkNvbmZpZxJFChFtaW5pbXVtX3Jpbmdfc2l6",
            "ZRgBIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZUIMuunAAwcy",
            "BRiAgIAEElYKDWhhc2hfZnVuY3Rpb24YAyABKA4yMy5lbnZveS5hcGkudjIu",
            "Q2x1c3Rlci5SaW5nSGFzaExiQ29uZmlnLkhhc2hGdW5jdGlvbkIKuunAAwWC",
            "AQIQARJFChFtYXhpbXVtX3Jpbmdfc2l6ZRgEIAEoCzIcLmdvb2dsZS5wcm90",
            "b2J1Zi5VSW50NjRWYWx1ZUIMuunAAwcyBRiAgIAEIi4KDEhhc2hGdW5jdGlv",
            "bhILCgdYWF9IQVNIEAASEQoNTVVSTVVSX0hBU0hfMhABSgQIAhADGi4KE09y",
            "aWdpbmFsRHN0TGJDb25maWcSFwoPdXNlX2h0dHBfaGVhZGVyGAEgASgIGucE",
            "Cg5Db21tb25MYkNvbmZpZxI0ChdoZWFsdGh5X3BhbmljX3RocmVzaG9sZBgB",
            "IAEoCzITLmVudm95LnR5cGUuUGVyY2VudBJWChR6b25lX2F3YXJlX2xiX2Nv",
            "bmZpZxgCIAEoCzI2LmVudm95LmFwaS52Mi5DbHVzdGVyLkNvbW1vbkxiQ29u",
            "ZmlnLlpvbmVBd2FyZUxiQ29uZmlnSAASZAobbG9jYWxpdHlfd2VpZ2h0ZWRf",
            "bGJfY29uZmlnGAMgASgLMj0uZW52b3kuYXBpLnYyLkNsdXN0ZXIuQ29tbW9u",
            "TGJDb25maWcuTG9jYWxpdHlXZWlnaHRlZExiQ29uZmlnSAASNgoTdXBkYXRl",
            "X21lcmdlX3dpbmRvdxgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlv",
            "bhInCh9pZ25vcmVfbmV3X2hvc3RzX3VudGlsX2ZpcnN0X2hjGAUgASgIEiwK",
            "JGNsb3NlX2Nvbm5lY3Rpb25zX29uX2hvc3Rfc2V0X2NoYW5nZRgGIAEoCBqY",
            "AQoRWm9uZUF3YXJlTGJDb25maWcSLAoPcm91dGluZ19lbmFibGVkGAEgASgL",
            "MhMuZW52b3kudHlwZS5QZXJjZW50EjYKEG1pbl9jbHVzdGVyX3NpemUYAiAB",
            "KAsyHC5nb29nbGUucHJvdG9idWYuVUludDY0VmFsdWUSHQoVZmFpbF90cmFm",
            "ZmljX29uX3BhbmljGAMgASgIGhoKGExvY2FsaXR5V2VpZ2h0ZWRMYkNvbmZp",
            "Z0IbChlsb2NhbGl0eV9jb25maWdfc3BlY2lmaWVyIlcKDURpc2NvdmVyeVR5",
            "cGUSCgoGU1RBVElDEAASDgoKU1RSSUNUX0ROUxABEg8KC0xPR0lDQUxfRE5T",
            "EAISBwoDRURTEAMSEAoMT1JJR0lOQUxfRFNUEAQipgEKCExiUG9saWN5Eg8K",
            "C1JPVU5EX1JPQklOEAASEQoNTEVBU1RfUkVRVUVTVBABEg0KCVJJTkdfSEFT",
            "SBACEgoKBlJBTkRPTRADEhcKD09SSUdJTkFMX0RTVF9MQhAEGgIIARIKCgZN",
            "QUdMRVYQBRIUChBDTFVTVEVSX1BST1ZJREVEEAYSIAocTE9BRF9CQUxBTkNJ",
            "TkdfUE9MSUNZX0NPTkZJRxAHIjUKD0Ruc0xvb2t1cEZhbWlseRIICgRBVVRP",
            "EAASCwoHVjRfT05MWRABEgsKB1Y2X09OTFkQAiJUChhDbHVzdGVyUHJvdG9j",
            "b2xTZWxlY3Rpb24SGwoXVVNFX0NPTkZJR1VSRURfUFJPVE9DT0wQABIbChdV",
            "U0VfRE9XTlNUUkVBTV9QUk9UT0NPTBABQhgKFmNsdXN0ZXJfZGlzY292ZXJ5",
            "X3R5cGVCCwoJbGJfY29uZmlnSgQIDBANSgQIDxAQIr4BChNMb2FkQmFsYW5j",
            "aW5nUG9saWN5EjoKCHBvbGljaWVzGAEgAygLMiguZW52b3kuYXBpLnYyLkxv",
            "YWRCYWxhbmNpbmdQb2xpY3kuUG9saWN5GmsKBlBvbGljeRIMCgRuYW1lGAEg",
            "ASgJEicKBmNvbmZpZxgCIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QS",
            "KgoMdHlwZWRfY29uZmlnGAMgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueSJI",
            "ChJVcHN0cmVhbUJpbmRDb25maWcSMgoOc291cmNlX2FkZHJlc3MYASABKAsy",
            "Gi5lbnZveS5hcGkudjIuY29yZS5BZGRyZXNzIlMKGVVwc3RyZWFtQ29ubmVj",
            "dGlvbk9wdGlvbnMSNgoNdGNwX2tlZXBhbGl2ZRgBIAEoCzIfLmVudm95LmFw",
            "aS52Mi5jb3JlLlRjcEtlZXBhbGl2ZTLJAgoXQ2x1c3RlckRpc2NvdmVyeVNl",
            "cnZpY2USVwoOU3RyZWFtQ2x1c3RlcnMSHi5lbnZveS5hcGkudjIuRGlzY292",
            "ZXJ5UmVxdWVzdBofLmVudm95LmFwaS52Mi5EaXNjb3ZlcnlSZXNwb25zZSIA",
            "KAEwARJgCg1EZWx0YUNsdXN0ZXJzEiMuZW52b3kuYXBpLnYyLkRlbHRhRGlz",
            "Y292ZXJ5UmVxdWVzdBokLmVudm95LmFwaS52Mi5EZWx0YURpc2NvdmVyeVJl",
            "c3BvbnNlIgAoATABEnMKDUZldGNoQ2x1c3RlcnMSHi5lbnZveS5hcGkudjIu",
            "RGlzY292ZXJ5UmVxdWVzdBofLmVudm95LmFwaS52Mi5EaXNjb3ZlcnlSZXNw",
            "b25zZSIhgtPkkwIbIhYvdjIvZGlzY292ZXJ5OmNsdXN0ZXJzOgEqQisKGmlv",
            "LmVudm95cHJveHkuZW52b3kuYXBpLnYyQghDZHNQcm90b1ABiAEBYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Auth.CertReflection.Descriptor, global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor, global::Envoy.Api.V2.DiscoveryReflection.Descriptor, global::Envoy.Api.V2.Core.HealthCheckReflection.Descriptor, global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor, global::Envoy.Api.V2.ClusterNS.CircuitBreakerReflection.Descriptor, global::Envoy.Api.V2.ClusterNS.FilterReflection.Descriptor, global::Envoy.Api.V2.ClusterNS.OutlierDetectionReflection.Descriptor, global::Envoy.Api.V2.EdsReflection.Descriptor, global::Envoy.Type.PercentReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster), global::Envoy.Api.V2.Cluster.Parser, new[]{ "Name", "AltStatName", "Type", "ClusterType", "EdsClusterConfig", "ConnectTimeout", "PerConnectionBufferLimitBytes", "LbPolicy", "Hosts", "LoadAssignment", "HealthChecks", "MaxRequestsPerConnection", "CircuitBreakers", "TlsContext", "CommonHttpProtocolOptions", "HttpProtocolOptions", "Http2ProtocolOptions", "ExtensionProtocolOptions", "TypedExtensionProtocolOptions", "DnsRefreshRate", "RespectDnsTtl", "DnsLookupFamily", "DnsResolvers", "OutlierDetection", "CleanupInterval", "UpstreamBindConfig", "LbSubsetConfig", "RingHashLbConfig", "OriginalDstLbConfig", "LeastRequestLbConfig", "CommonLbConfig", "TransportSocket", "Metadata", "ProtocolSelection", "UpstreamConnectionOptions", "CloseConnectionsOnHostHealthFailure", "DrainConnectionsOnHostRemoval", "Filters", "LoadBalancingPolicy" }, new[]{ "ClusterDiscoveryType", "LbConfig" }, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.DiscoveryType), typeof(global::Envoy.Api.V2.Cluster.Types.LbPolicy), typeof(global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily), typeof(global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CustomClusterType), global::Envoy.Api.V2.Cluster.Types.CustomClusterType.Parser, new[]{ "Name", "TypedConfig" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig), global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig.Parser, new[]{ "EdsConfig", "ServiceName" }, null, null, null, null),
            null, null, new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig), global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Parser, new[]{ "FallbackPolicy", "DefaultSubset", "SubsetSelectors", "LocalityWeightAware", "ScaleLocalityWeight", "PanicModeAny", "ListAsAny" }, null, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector), global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser, new[]{ "Keys", "FallbackPolicy" }, null, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig), global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig.Parser, new[]{ "ChoiceCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig), global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Parser, new[]{ "MinimumRingSize", "HashFunction", "MaximumRingSize" }, null, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig), global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig.Parser, new[]{ "UseHttpHeader" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Parser, new[]{ "HealthyPanicThreshold", "ZoneAwareLbConfig", "LocalityWeightedLbConfig", "UpdateMergeWindow", "IgnoreNewHostsUntilFirstHc", "CloseConnectionsOnHostSetChange" }, new[]{ "LocalityConfigSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig.Parser, new[]{ "RoutingEnabled", "MinClusterSize", "FailTrafficOnPanic" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig.Parser, null, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.LoadBalancingPolicy), global::Envoy.Api.V2.LoadBalancingPolicy.Parser, new[]{ "Policies" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy), global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy.Parser, new[]{ "Name", "Config", "TypedConfig" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.UpstreamBindConfig), global::Envoy.Api.V2.UpstreamBindConfig.Parser, new[]{ "SourceAddress" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.UpstreamConnectionOptions), global::Envoy.Api.V2.UpstreamConnectionOptions.Parser, new[]{ "TcpKeepalive" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for a single upstream cluster.
  /// [#comment:next free field: 42]
  /// </summary>
  public sealed partial class Cluster : pb::IMessage<Cluster> {
    private static readonly pb::MessageParser<Cluster> _parser = new pb::MessageParser<Cluster>(() => new Cluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Cluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster(Cluster other) : this() {
      name_ = other.name_;
      altStatName_ = other.altStatName_;
      edsClusterConfig_ = other.edsClusterConfig_ != null ? other.edsClusterConfig_.Clone() : null;
      connectTimeout_ = other.connectTimeout_ != null ? other.connectTimeout_.Clone() : null;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      lbPolicy_ = other.lbPolicy_;
      hosts_ = other.hosts_.Clone();
      loadAssignment_ = other.loadAssignment_ != null ? other.loadAssignment_.Clone() : null;
      healthChecks_ = other.healthChecks_.Clone();
      MaxRequestsPerConnection = other.MaxRequestsPerConnection;
      circuitBreakers_ = other.circuitBreakers_ != null ? other.circuitBreakers_.Clone() : null;
      tlsContext_ = other.tlsContext_ != null ? other.tlsContext_.Clone() : null;
      commonHttpProtocolOptions_ = other.commonHttpProtocolOptions_ != null ? other.commonHttpProtocolOptions_.Clone() : null;
      httpProtocolOptions_ = other.httpProtocolOptions_ != null ? other.httpProtocolOptions_.Clone() : null;
      http2ProtocolOptions_ = other.http2ProtocolOptions_ != null ? other.http2ProtocolOptions_.Clone() : null;
      extensionProtocolOptions_ = other.extensionProtocolOptions_.Clone();
      typedExtensionProtocolOptions_ = other.typedExtensionProtocolOptions_.Clone();
      dnsRefreshRate_ = other.dnsRefreshRate_ != null ? other.dnsRefreshRate_.Clone() : null;
      respectDnsTtl_ = other.respectDnsTtl_;
      dnsLookupFamily_ = other.dnsLookupFamily_;
      dnsResolvers_ = other.dnsResolvers_.Clone();
      outlierDetection_ = other.outlierDetection_ != null ? other.outlierDetection_.Clone() : null;
      cleanupInterval_ = other.cleanupInterval_ != null ? other.cleanupInterval_.Clone() : null;
      upstreamBindConfig_ = other.upstreamBindConfig_ != null ? other.upstreamBindConfig_.Clone() : null;
      lbSubsetConfig_ = other.lbSubsetConfig_ != null ? other.lbSubsetConfig_.Clone() : null;
      commonLbConfig_ = other.commonLbConfig_ != null ? other.commonLbConfig_.Clone() : null;
      transportSocket_ = other.transportSocket_ != null ? other.transportSocket_.Clone() : null;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      protocolSelection_ = other.protocolSelection_;
      upstreamConnectionOptions_ = other.upstreamConnectionOptions_ != null ? other.upstreamConnectionOptions_.Clone() : null;
      closeConnectionsOnHostHealthFailure_ = other.closeConnectionsOnHostHealthFailure_;
      drainConnectionsOnHostRemoval_ = other.drainConnectionsOnHostRemoval_;
      filters_ = other.filters_.Clone();
      loadBalancingPolicy_ = other.loadBalancingPolicy_ != null ? other.loadBalancingPolicy_.Clone() : null;
      switch (other.ClusterDiscoveryTypeCase) {
        case ClusterDiscoveryTypeOneofCase.Type:
          Type = other.Type;
          break;
        case ClusterDiscoveryTypeOneofCase.ClusterType:
          ClusterType = other.ClusterType.Clone();
          break;
      }

      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          RingHashLbConfig = other.RingHashLbConfig.Clone();
          break;
        case LbConfigOneofCase.OriginalDstLbConfig:
          OriginalDstLbConfig = other.OriginalDstLbConfig.Clone();
          break;
        case LbConfigOneofCase.LeastRequestLbConfig:
          LeastRequestLbConfig = other.LeastRequestLbConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster Clone() {
      return new Cluster(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Supplies the name of the cluster which must be unique across all clusters.
    /// The cluster name is used when emitting
    /// :ref:`statistics &lt;config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
    /// &lt;envoy_api_field_Cluster.alt_stat_name>` is not provided.
    /// Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alt_stat_name" field.</summary>
    public const int AltStatNameFieldNumber = 28;
    private string altStatName_ = "";
    /// <summary>
    /// An optional alternative to the cluster name to be used while emitting stats.
    /// Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
    /// confused with :ref:`Router Filter Header
    /// &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AltStatName {
      get { return altStatName_; }
      set {
        altStatName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    /// <summary>
    /// The :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
    /// to use for resolving the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.DiscoveryType Type {
      get { return clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type ? (global::Envoy.Api.V2.Cluster.Types.DiscoveryType) clusterDiscoveryType_ : global::Envoy.Api.V2.Cluster.Types.DiscoveryType.Static; }
      set {
        clusterDiscoveryType_ = value;
        clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.Type;
      }
    }

    /// <summary>Field number for the "cluster_type" field.</summary>
    public const int ClusterTypeFieldNumber = 38;
    /// <summary>
    /// The custom cluster type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.CustomClusterType ClusterType {
      get { return clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType ? (global::Envoy.Api.V2.Cluster.Types.CustomClusterType) clusterDiscoveryType_ : null; }
      set {
        clusterDiscoveryType_ = value;
        clusterDiscoveryTypeCase_ = value == null ? ClusterDiscoveryTypeOneofCase.None : ClusterDiscoveryTypeOneofCase.ClusterType;
      }
    }

    /// <summary>Field number for the "eds_cluster_config" field.</summary>
    public const int EdsClusterConfigFieldNumber = 3;
    private global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig edsClusterConfig_;
    /// <summary>
    /// Configuration to use for EDS updates for the Cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig EdsClusterConfig {
      get { return edsClusterConfig_; }
      set {
        edsClusterConfig_ = value;
      }
    }

    /// <summary>Field number for the "connect_timeout" field.</summary>
    public const int ConnectTimeoutFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration connectTimeout_;
    /// <summary>
    /// The timeout for new network connections to hosts in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration ConnectTimeout {
      get { return connectTimeout_; }
      set {
        connectTimeout_ = value;
      }
    }

    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the cluster’s connections read and write buffers. If
    /// unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }


    /// <summary>Field number for the "lb_policy" field.</summary>
    public const int LbPolicyFieldNumber = 6;
    private global::Envoy.Api.V2.Cluster.Types.LbPolicy lbPolicy_ = global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin;
    /// <summary>
    /// The :ref:`load balancer type &lt;arch_overview_load_balancing_types>` to use
    /// when picking a host in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.LbPolicy LbPolicy {
      get { return lbPolicy_; }
      set {
        lbPolicy_ = value;
      }
    }

    /// <summary>Field number for the "hosts" field.</summary>
    public const int HostsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Address> _repeated_hosts_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Api.V2.Core.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> hosts_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Address>();
    /// <summary>
    /// If the service discovery type is
    /// :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// then hosts is required.
    ///
    /// .. attention::
    ///
    ///   **This field is deprecated**. Set the
    ///   :ref:`load_assignment&lt;envoy_api_field_Cluster.load_assignment>` field instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> Hosts {
      get { return hosts_; }
    }

    /// <summary>Field number for the "load_assignment" field.</summary>
    public const int LoadAssignmentFieldNumber = 33;
    private global::Envoy.Api.V2.ClusterLoadAssignment loadAssignment_;
    /// <summary>
    /// Setting this is required for specifying members of
    /// :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
    /// This field supersedes :ref:`hosts&lt;envoy_api_field_Cluster.hosts>` field.
    /// [#comment:TODO(dio): Deprecate the hosts field and add it to :ref:`deprecated log&lt;deprecated>`
    /// once load_assignment is implemented.]
    ///
    /// .. attention::
    ///
    ///   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
    ///   :ref:`endpoint assignments&lt;envoy_api_msg_ClusterLoadAssignment>`.
    ///   Setting this overrides :ref:`hosts&lt;envoy_api_field_Cluster.hosts>` values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.ClusterLoadAssignment LoadAssignment {
      get { return loadAssignment_; }
      set {
        loadAssignment_ = value;
      }
    }

    /// <summary>Field number for the "health_checks" field.</summary>
    public const int HealthChecksFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HealthCheck> _repeated_healthChecks_codec
        = pb::FieldCodec.ForMessage(66, global::Envoy.Api.V2.Core.HealthCheck.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck> healthChecks_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck>();
    /// <summary>
    /// Optional :ref:`active health checking &lt;arch_overview_health_checking>`
    /// configuration for the cluster. If no
    /// configuration is specified no health checking will be done and all cluster
    /// members will be considered healthy at all times.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck> HealthChecks {
      get { return healthChecks_; }
    }

    /// <summary>Field number for the "max_requests_per_connection" field.</summary>
    public const int MaxRequestsPerConnectionFieldNumber = 9;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestsPerConnection_codec = pb::FieldCodec.ForStructWrapper<uint>(74);
    private uint? maxRequestsPerConnection_;
    /// <summary>
    /// Optional maximum requests for a single upstream connection. This parameter
    /// is respected by both the HTTP/1.1 and HTTP/2 connection pool
    /// implementations. If not specified, there is no limit. Setting this
    /// parameter to 1 will effectively disable keep alive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxRequestsPerConnection {
      get { return maxRequestsPerConnection_; }
      set {
        maxRequestsPerConnection_ = value;
      }
    }


    /// <summary>Field number for the "circuit_breakers" field.</summary>
    public const int CircuitBreakersFieldNumber = 10;
    private global::Envoy.Api.V2.ClusterNS.CircuitBreakers circuitBreakers_;
    /// <summary>
    /// Optional :ref:`circuit breaking &lt;arch_overview_circuit_break>` for the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.ClusterNS.CircuitBreakers CircuitBreakers {
      get { return circuitBreakers_; }
      set {
        circuitBreakers_ = value;
      }
    }

    /// <summary>Field number for the "tls_context" field.</summary>
    public const int TlsContextFieldNumber = 11;
    private global::Envoy.Api.V2.Auth.UpstreamTlsContext tlsContext_;
    /// <summary>
    /// The TLS configuration for connections to the upstream cluster. If no TLS
    /// configuration is specified, TLS will not be used for new connections.
    ///
    /// .. attention::
    ///
    ///   Server certificate verification is not enabled by default. Configure
    ///   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca>` to enable
    ///   verification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.UpstreamTlsContext TlsContext {
      get { return tlsContext_; }
      set {
        tlsContext_ = value;
      }
    }

    /// <summary>Field number for the "common_http_protocol_options" field.</summary>
    public const int CommonHttpProtocolOptionsFieldNumber = 29;
    private global::Envoy.Api.V2.Core.HttpProtocolOptions commonHttpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP requests. These options will be applicable to both
    /// HTTP1 and HTTP2 requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.HttpProtocolOptions CommonHttpProtocolOptions {
      get { return commonHttpProtocolOptions_; }
      set {
        commonHttpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http_protocol_options" field.</summary>
    public const int HttpProtocolOptionsFieldNumber = 13;
    private global::Envoy.Api.V2.Core.Http1ProtocolOptions httpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP1 requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http1ProtocolOptions HttpProtocolOptions {
      get { return httpProtocolOptions_; }
      set {
        httpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 14;
    private global::Envoy.Api.V2.Core.Http2ProtocolOptions http2ProtocolOptions_;
    /// <summary>
    /// Even if default HTTP2 protocol options are desired, this field must be
    /// set so that Envoy will assume that the upstream supports HTTP/2 when
    /// making new HTTP connection pool connections. Currently, Envoy only
    /// supports prior knowledge for upstream connections. Even if TLS is used
    /// with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
    /// connections to happen over plain text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "extension_protocol_options" field.</summary>
    public const int ExtensionProtocolOptionsFieldNumber = 35;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec _map_extensionProtocolOptions_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Struct.Parser), 282);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> extensionProtocolOptions_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>();
    /// <summary>
    /// The extension_protocol_options field is used to provide extension-specific protocol options
    /// for upstream connections. The key should match the extension filter name, such as
    /// "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
    /// specific options.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> ExtensionProtocolOptions {
      get { return extensionProtocolOptions_; }
    }

    /// <summary>Field number for the "typed_extension_protocol_options" field.</summary>
    public const int TypedExtensionProtocolOptionsFieldNumber = 36;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedExtensionProtocolOptions_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 290);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedExtensionProtocolOptions_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// The extension_protocol_options field is used to provide extension-specific protocol options
    /// for upstream connections. The key should match the extension filter name, such as
    /// "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
    /// specific options.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedExtensionProtocolOptions {
      get { return typedExtensionProtocolOptions_; }
    }

    /// <summary>Field number for the "dns_refresh_rate" field.</summary>
    public const int DnsRefreshRateFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsRefreshRate_;
    /// <summary>
    /// If the DNS refresh rate is specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used as the cluster’s DNS refresh
    /// rate. If this setting is not specified, the value defaults to 5000ms. For
    /// cluster types other than
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsRefreshRate {
      get { return dnsRefreshRate_; }
      set {
        dnsRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "respect_dns_ttl" field.</summary>
    public const int RespectDnsTtlFieldNumber = 39;
    private bool respectDnsTtl_;
    /// <summary>
    /// Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
    /// cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
    /// resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RespectDnsTtl {
      get { return respectDnsTtl_; }
      set {
        respectDnsTtl_ = value;
      }
    }

    /// <summary>Field number for the "dns_lookup_family" field.</summary>
    public const int DnsLookupFamilyFieldNumber = 17;
    private global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily dnsLookupFamily_ = global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto;
    /// <summary>
    /// The DNS IP address resolution policy. If this setting is not specified, the
    /// value defaults to
    /// :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily DnsLookupFamily {
      get { return dnsLookupFamily_; }
      set {
        dnsLookupFamily_ = value;
      }
    }

    /// <summary>Field number for the "dns_resolvers" field.</summary>
    public const int DnsResolversFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Address> _repeated_dnsResolvers_codec
        = pb::FieldCodec.ForMessage(146, global::Envoy.Api.V2.Core.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> dnsResolvers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Address>();
    /// <summary>
    /// If DNS resolvers are specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used to specify the cluster’s dns resolvers.
    /// If this setting is not specified, the value defaults to the default
    /// resolver, which uses /etc/resolv.conf for configuration. For cluster types
    /// other than
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> DnsResolvers {
      get { return dnsResolvers_; }
    }

    /// <summary>Field number for the "outlier_detection" field.</summary>
    public const int OutlierDetectionFieldNumber = 19;
    private global::Envoy.Api.V2.ClusterNS.OutlierDetection outlierDetection_;
    /// <summary>
    /// If specified, outlier detection will be enabled for this upstream cluster.
    /// Each of the configuration values can be overridden via
    /// :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.ClusterNS.OutlierDetection OutlierDetection {
      get { return outlierDetection_; }
      set {
        outlierDetection_ = value;
      }
    }

    /// <summary>Field number for the "cleanup_interval" field.</summary>
    public const int CleanupIntervalFieldNumber = 20;
    private global::Google.Protobuf.WellKnownTypes.Duration cleanupInterval_;
    /// <summary>
    /// The interval for removing stale hosts from a cluster type
    /// :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`.
    /// Hosts are considered stale if they have not been used
    /// as upstream destinations during this interval. New hosts are added
    /// to original destination clusters on demand as new connections are
    /// redirected to Envoy, causing the number of hosts in the cluster to
    /// grow over time. Hosts that are not stale (they are actively used as
    /// destinations) are kept in the cluster, which allows connections to
    /// them remain open, saving the latency that would otherwise be spent
    /// on opening new connections. If this setting is not specified, the
    /// value defaults to 5000ms. For cluster types other than
    /// :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration CleanupInterval {
      get { return cleanupInterval_; }
      set {
        cleanupInterval_ = value;
      }
    }

    /// <summary>Field number for the "upstream_bind_config" field.</summary>
    public const int UpstreamBindConfigFieldNumber = 21;
    private global::Envoy.Api.V2.Core.BindConfig upstreamBindConfig_;
    /// <summary>
    /// Optional configuration used to bind newly established upstream connections.
    /// This overrides any bind_config specified in the bootstrap proto.
    /// If the address and port are empty, no bind will be performed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.BindConfig UpstreamBindConfig {
      get { return upstreamBindConfig_; }
      set {
        upstreamBindConfig_ = value;
      }
    }

    /// <summary>Field number for the "lb_subset_config" field.</summary>
    public const int LbSubsetConfigFieldNumber = 22;
    private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig lbSubsetConfig_;
    /// <summary>
    /// Configuration for load balancing subsetting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig LbSubsetConfig {
      get { return lbSubsetConfig_; }
      set {
        lbSubsetConfig_ = value;
      }
    }

    /// <summary>Field number for the "ring_hash_lb_config" field.</summary>
    public const int RingHashLbConfigFieldNumber = 23;
    /// <summary>
    /// Optional configuration for the Ring Hash load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig RingHashLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig ? (global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.RingHashLbConfig;
      }
    }

    /// <summary>Field number for the "original_dst_lb_config" field.</summary>
    public const int OriginalDstLbConfigFieldNumber = 34;
    /// <summary>
    /// Optional configuration for the Original Destination load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig OriginalDstLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig ? (global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.OriginalDstLbConfig;
      }
    }

    /// <summary>Field number for the "least_request_lb_config" field.</summary>
    public const int LeastRequestLbConfigFieldNumber = 37;
    /// <summary>
    /// Optional configuration for the LeastRequest load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig LeastRequestLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig ? (global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.LeastRequestLbConfig;
      }
    }

    /// <summary>Field number for the "common_lb_config" field.</summary>
    public const int CommonLbConfigFieldNumber = 27;
    private global::Envoy.Api.V2.Cluster.Types.CommonLbConfig commonLbConfig_;
    /// <summary>
    /// Common configuration for all load balancer implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig CommonLbConfig {
      get { return commonLbConfig_; }
      set {
        commonLbConfig_ = value;
      }
    }

    /// <summary>Field number for the "transport_socket" field.</summary>
    public const int TransportSocketFieldNumber = 24;
    private global::Envoy.Api.V2.Core.TransportSocket transportSocket_;
    /// <summary>
    /// Optional custom transport socket implementation to use for upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.TransportSocket TransportSocket {
      get { return transportSocket_; }
      set {
        transportSocket_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 25;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// The Metadata field can be used to provide additional information about the
    /// cluster. It can be used for stats, logging, and varying filter behavior.
    /// Fields should use reverse DNS notation to denote which entity within Envoy
    /// will need the information. For instance, if the metadata is intended for
    /// the Router filter, the filter name should be specified as *envoy.router*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "protocol_selection" field.</summary>
    public const int ProtocolSelectionFieldNumber = 26;
    private global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection protocolSelection_ = global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol;
    /// <summary>
    /// Determines how Envoy selects the protocol used to speak to upstream hosts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection ProtocolSelection {
      get { return protocolSelection_; }
      set {
        protocolSelection_ = value;
      }
    }

    /// <summary>Field number for the "upstream_connection_options" field.</summary>
    public const int UpstreamConnectionOptionsFieldNumber = 30;
    private global::Envoy.Api.V2.UpstreamConnectionOptions upstreamConnectionOptions_;
    /// <summary>
    /// Optional options for upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.UpstreamConnectionOptions UpstreamConnectionOptions {
      get { return upstreamConnectionOptions_; }
      set {
        upstreamConnectionOptions_ = value;
      }
    }

    /// <summary>Field number for the "close_connections_on_host_health_failure" field.</summary>
    public const int CloseConnectionsOnHostHealthFailureFieldNumber = 31;
    private bool closeConnectionsOnHostHealthFailure_;
    /// <summary>
    /// If an upstream host becomes unhealthy (as determined by the configured health checks
    /// or outlier detection), immediately close all connections to the failed host.
    ///
    /// .. note::
    ///
    ///   This is currently only supported for connections created by tcp_proxy.
    ///
    /// .. note::
    ///
    ///   The current implementation of this feature closes all connections immediately when
    ///   the unhealthy status is detected. If there are a large number of connections open
    ///   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
    ///   time exclusively closing these connections, and not processing any other traffic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool CloseConnectionsOnHostHealthFailure {
      get { return closeConnectionsOnHostHealthFailure_; }
      set {
        closeConnectionsOnHostHealthFailure_ = value;
      }
    }

    /// <summary>Field number for the "drain_connections_on_host_removal" field.</summary>
    public const int DrainConnectionsOnHostRemovalFieldNumber = 32;
    private bool drainConnectionsOnHostRemoval_;
    /// <summary>
    /// If this cluster uses EDS or STRICT_DNS to configure its hosts, immediately drain
    /// connections from any hosts that are removed from service discovery.
    ///
    /// This only affects behavior for hosts that are being actively health checked.
    /// If this flag is not set to true, Envoy will wait until the hosts fail active health
    /// checking before removing it from the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DrainConnectionsOnHostRemoval {
      get { return drainConnectionsOnHostRemoval_; }
      set {
        drainConnectionsOnHostRemoval_ = value;
      }
    }

    /// <summary>Field number for the "filters" field.</summary>
    public const int FiltersFieldNumber = 40;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.ClusterNS.Filter> _repeated_filters_codec
        = pb::FieldCodec.ForMessage(322, global::Envoy.Api.V2.ClusterNS.Filter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.ClusterNS.Filter> filters_ = new pbc::RepeatedField<global::Envoy.Api.V2.ClusterNS.Filter>();
    /// <summary>
    /// An (optional) network filter chain, listed in the order the filters should be applied.
    /// The chain will be applied to all outgoing connections that Envoy makes to the upstream
    /// servers of this cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.ClusterNS.Filter> Filters {
      get { return filters_; }
    }

    /// <summary>Field number for the "load_balancing_policy" field.</summary>
    public const int LoadBalancingPolicyFieldNumber = 41;
    private global::Envoy.Api.V2.LoadBalancingPolicy loadBalancingPolicy_;
    /// <summary>
    /// [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
    /// :ref:`lb_policy&lt;envoy_api_field_Cluster.lb_policy>` field has the value
    /// :ref:`LOAD_BALANCING_POLICY_CONFIG&lt;envoy_api_enum_value_Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.LoadBalancingPolicy LoadBalancingPolicy {
      get { return loadBalancingPolicy_; }
      set {
        loadBalancingPolicy_ = value;
      }
    }

    private object clusterDiscoveryType_;
    /// <summary>Enum of possible cases for the "cluster_discovery_type" oneof.</summary>
    public enum ClusterDiscoveryTypeOneofCase {
      None = 0,
      Type = 2,
      ClusterType = 38,
    }
    private ClusterDiscoveryTypeOneofCase clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterDiscoveryTypeOneofCase ClusterDiscoveryTypeCase {
      get { return clusterDiscoveryTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClusterDiscoveryType() {
      clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.None;
      clusterDiscoveryType_ = null;
    }

    private object lbConfig_;
    /// <summary>Enum of possible cases for the "lb_config" oneof.</summary>
    public enum LbConfigOneofCase {
      None = 0,
      RingHashLbConfig = 23,
      OriginalDstLbConfig = 34,
      LeastRequestLbConfig = 37,
    }
    private LbConfigOneofCase lbConfigCase_ = LbConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LbConfigOneofCase LbConfigCase {
      get { return lbConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLbConfig() {
      lbConfigCase_ = LbConfigOneofCase.None;
      lbConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Cluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Cluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (AltStatName != other.AltStatName) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(ClusterType, other.ClusterType)) return false;
      if (!object.Equals(EdsClusterConfig, other.EdsClusterConfig)) return false;
      if (!object.Equals(ConnectTimeout, other.ConnectTimeout)) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (LbPolicy != other.LbPolicy) return false;
      if(!hosts_.Equals(other.hosts_)) return false;
      if (!object.Equals(LoadAssignment, other.LoadAssignment)) return false;
      if(!healthChecks_.Equals(other.healthChecks_)) return false;
      if (MaxRequestsPerConnection != other.MaxRequestsPerConnection) return false;
      if (!object.Equals(CircuitBreakers, other.CircuitBreakers)) return false;
      if (!object.Equals(TlsContext, other.TlsContext)) return false;
      if (!object.Equals(CommonHttpProtocolOptions, other.CommonHttpProtocolOptions)) return false;
      if (!object.Equals(HttpProtocolOptions, other.HttpProtocolOptions)) return false;
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      if (!ExtensionProtocolOptions.Equals(other.ExtensionProtocolOptions)) return false;
      if (!TypedExtensionProtocolOptions.Equals(other.TypedExtensionProtocolOptions)) return false;
      if (!object.Equals(DnsRefreshRate, other.DnsRefreshRate)) return false;
      if (RespectDnsTtl != other.RespectDnsTtl) return false;
      if (DnsLookupFamily != other.DnsLookupFamily) return false;
      if(!dnsResolvers_.Equals(other.dnsResolvers_)) return false;
      if (!object.Equals(OutlierDetection, other.OutlierDetection)) return false;
      if (!object.Equals(CleanupInterval, other.CleanupInterval)) return false;
      if (!object.Equals(UpstreamBindConfig, other.UpstreamBindConfig)) return false;
      if (!object.Equals(LbSubsetConfig, other.LbSubsetConfig)) return false;
      if (!object.Equals(RingHashLbConfig, other.RingHashLbConfig)) return false;
      if (!object.Equals(OriginalDstLbConfig, other.OriginalDstLbConfig)) return false;
      if (!object.Equals(LeastRequestLbConfig, other.LeastRequestLbConfig)) return false;
      if (!object.Equals(CommonLbConfig, other.CommonLbConfig)) return false;
      if (!object.Equals(TransportSocket, other.TransportSocket)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (ProtocolSelection != other.ProtocolSelection) return false;
      if (!object.Equals(UpstreamConnectionOptions, other.UpstreamConnectionOptions)) return false;
      if (CloseConnectionsOnHostHealthFailure != other.CloseConnectionsOnHostHealthFailure) return false;
      if (DrainConnectionsOnHostRemoval != other.DrainConnectionsOnHostRemoval) return false;
      if(!filters_.Equals(other.filters_)) return false;
      if (!object.Equals(LoadBalancingPolicy, other.LoadBalancingPolicy)) return false;
      if (ClusterDiscoveryTypeCase != other.ClusterDiscoveryTypeCase) return false;
      if (LbConfigCase != other.LbConfigCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (AltStatName.Length != 0) hash ^= AltStatName.GetHashCode();
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) hash ^= Type.GetHashCode();
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) hash ^= ClusterType.GetHashCode();
      if (edsClusterConfig_ != null) hash ^= EdsClusterConfig.GetHashCode();
      if (connectTimeout_ != null) hash ^= ConnectTimeout.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) hash ^= LbPolicy.GetHashCode();
      hash ^= hosts_.GetHashCode();
      if (loadAssignment_ != null) hash ^= LoadAssignment.GetHashCode();
      hash ^= healthChecks_.GetHashCode();
      if (maxRequestsPerConnection_ != null) hash ^= MaxRequestsPerConnection.GetHashCode();
      if (circuitBreakers_ != null) hash ^= CircuitBreakers.GetHashCode();
      if (tlsContext_ != null) hash ^= TlsContext.GetHashCode();
      if (commonHttpProtocolOptions_ != null) hash ^= CommonHttpProtocolOptions.GetHashCode();
      if (httpProtocolOptions_ != null) hash ^= HttpProtocolOptions.GetHashCode();
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      hash ^= ExtensionProtocolOptions.GetHashCode();
      hash ^= TypedExtensionProtocolOptions.GetHashCode();
      if (dnsRefreshRate_ != null) hash ^= DnsRefreshRate.GetHashCode();
      if (RespectDnsTtl != false) hash ^= RespectDnsTtl.GetHashCode();
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) hash ^= DnsLookupFamily.GetHashCode();
      hash ^= dnsResolvers_.GetHashCode();
      if (outlierDetection_ != null) hash ^= OutlierDetection.GetHashCode();
      if (cleanupInterval_ != null) hash ^= CleanupInterval.GetHashCode();
      if (upstreamBindConfig_ != null) hash ^= UpstreamBindConfig.GetHashCode();
      if (lbSubsetConfig_ != null) hash ^= LbSubsetConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) hash ^= RingHashLbConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) hash ^= OriginalDstLbConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) hash ^= LeastRequestLbConfig.GetHashCode();
      if (commonLbConfig_ != null) hash ^= CommonLbConfig.GetHashCode();
      if (transportSocket_ != null) hash ^= TransportSocket.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) hash ^= ProtocolSelection.GetHashCode();
      if (upstreamConnectionOptions_ != null) hash ^= UpstreamConnectionOptions.GetHashCode();
      if (CloseConnectionsOnHostHealthFailure != false) hash ^= CloseConnectionsOnHostHealthFailure.GetHashCode();
      if (DrainConnectionsOnHostRemoval != false) hash ^= DrainConnectionsOnHostRemoval.GetHashCode();
      hash ^= filters_.GetHashCode();
      if (loadBalancingPolicy_ != null) hash ^= LoadBalancingPolicy.GetHashCode();
      hash ^= (int) clusterDiscoveryTypeCase_;
      hash ^= (int) lbConfigCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (edsClusterConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) {
        output.WriteRawTag(48);
        output.WriteEnum((int) LbPolicy);
      }
      hosts_.WriteTo(output, _repeated_hosts_codec);
      healthChecks_.WriteTo(output, _repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(output, MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsContext);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DnsRefreshRate);
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) DnsLookupFamily);
      }
      dnsResolvers_.WriteTo(output, _repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RingHashLbConfig);
      }
      if (transportSocket_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(TransportSocket);
      }
      if (metadata_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(Metadata);
      }
      if (ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) ProtocolSelection);
      }
      if (commonLbConfig_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(CommonLbConfig);
      }
      if (AltStatName.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(AltStatName);
      }
      if (commonHttpProtocolOptions_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(CommonHttpProtocolOptions);
      }
      if (upstreamConnectionOptions_ != null) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        output.WriteRawTag(248, 1);
        output.WriteBool(CloseConnectionsOnHostHealthFailure);
      }
      if (DrainConnectionsOnHostRemoval != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(DrainConnectionsOnHostRemoval);
      }
      if (loadAssignment_ != null) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(LoadAssignment);
      }
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
        output.WriteRawTag(146, 2);
        output.WriteMessage(OriginalDstLbConfig);
      }
      extensionProtocolOptions_.WriteTo(output, _map_extensionProtocolOptions_codec);
      typedExtensionProtocolOptions_.WriteTo(output, _map_typedExtensionProtocolOptions_codec);
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
        output.WriteRawTag(170, 2);
        output.WriteMessage(LeastRequestLbConfig);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
        output.WriteRawTag(178, 2);
        output.WriteMessage(ClusterType);
      }
      if (RespectDnsTtl != false) {
        output.WriteRawTag(184, 2);
        output.WriteBool(RespectDnsTtl);
      }
      filters_.WriteTo(output, _repeated_filters_codec);
      if (loadBalancingPolicy_ != null) {
        output.WriteRawTag(202, 2);
        output.WriteMessage(LoadBalancingPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (AltStatName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(AltStatName);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.Type) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ClusterType);
      }
      if (edsClusterConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LbPolicy);
      }
      size += hosts_.CalculateSize(_repeated_hosts_codec);
      if (loadAssignment_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LoadAssignment);
      }
      size += healthChecks_.CalculateSize(_repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        size += _single_maxRequestsPerConnection_codec.CalculateSizeWithTag(MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsContext);
      }
      if (commonHttpProtocolOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonHttpProtocolOptions);
      }
      if (httpProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      size += extensionProtocolOptions_.CalculateSize(_map_extensionProtocolOptions_codec);
      size += typedExtensionProtocolOptions_.CalculateSize(_map_typedExtensionProtocolOptions_codec);
      if (dnsRefreshRate_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsRefreshRate);
      }
      if (RespectDnsTtl != false) {
        size += 2 + 1;
      }
      if (DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) DnsLookupFamily);
      }
      size += dnsResolvers_.CalculateSize(_repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RingHashLbConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OriginalDstLbConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LeastRequestLbConfig);
      }
      if (commonLbConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonLbConfig);
      }
      if (transportSocket_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TransportSocket);
      }
      if (metadata_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ProtocolSelection);
      }
      if (upstreamConnectionOptions_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamConnectionOptions);
      }
      if (CloseConnectionsOnHostHealthFailure != false) {
        size += 2 + 1;
      }
      if (DrainConnectionsOnHostRemoval != false) {
        size += 2 + 1;
      }
      size += filters_.CalculateSize(_repeated_filters_codec);
      if (loadBalancingPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LoadBalancingPolicy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Cluster other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.AltStatName.Length != 0) {
        AltStatName = other.AltStatName;
      }
      if (other.edsClusterConfig_ != null) {
        if (edsClusterConfig_ == null) {
          EdsClusterConfig = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
        }
        EdsClusterConfig.MergeFrom(other.EdsClusterConfig);
      }
      if (other.connectTimeout_ != null) {
        if (connectTimeout_ == null) {
          ConnectTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ConnectTimeout.MergeFrom(other.ConnectTimeout);
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.LbPolicy != global::Envoy.Api.V2.Cluster.Types.LbPolicy.RoundRobin) {
        LbPolicy = other.LbPolicy;
      }
      hosts_.Add(other.hosts_);
      if (other.loadAssignment_ != null) {
        if (loadAssignment_ == null) {
          LoadAssignment = new global::Envoy.Api.V2.ClusterLoadAssignment();
        }
        LoadAssignment.MergeFrom(other.LoadAssignment);
      }
      healthChecks_.Add(other.healthChecks_);
      if (other.maxRequestsPerConnection_ != null) {
        if (maxRequestsPerConnection_ == null || other.MaxRequestsPerConnection != 0) {
          MaxRequestsPerConnection = other.MaxRequestsPerConnection;
        }
      }
      if (other.circuitBreakers_ != null) {
        if (circuitBreakers_ == null) {
          CircuitBreakers = new global::Envoy.Api.V2.ClusterNS.CircuitBreakers();
        }
        CircuitBreakers.MergeFrom(other.CircuitBreakers);
      }
      if (other.tlsContext_ != null) {
        if (tlsContext_ == null) {
          TlsContext = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
        }
        TlsContext.MergeFrom(other.TlsContext);
      }
      if (other.commonHttpProtocolOptions_ != null) {
        if (commonHttpProtocolOptions_ == null) {
          CommonHttpProtocolOptions = new global::Envoy.Api.V2.Core.HttpProtocolOptions();
        }
        CommonHttpProtocolOptions.MergeFrom(other.CommonHttpProtocolOptions);
      }
      if (other.httpProtocolOptions_ != null) {
        if (httpProtocolOptions_ == null) {
          HttpProtocolOptions = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
        }
        HttpProtocolOptions.MergeFrom(other.HttpProtocolOptions);
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      extensionProtocolOptions_.Add(other.extensionProtocolOptions_);
      typedExtensionProtocolOptions_.Add(other.typedExtensionProtocolOptions_);
      if (other.dnsRefreshRate_ != null) {
        if (dnsRefreshRate_ == null) {
          DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsRefreshRate.MergeFrom(other.DnsRefreshRate);
      }
      if (other.RespectDnsTtl != false) {
        RespectDnsTtl = other.RespectDnsTtl;
      }
      if (other.DnsLookupFamily != global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily.Auto) {
        DnsLookupFamily = other.DnsLookupFamily;
      }
      dnsResolvers_.Add(other.dnsResolvers_);
      if (other.outlierDetection_ != null) {
        if (outlierDetection_ == null) {
          OutlierDetection = new global::Envoy.Api.V2.ClusterNS.OutlierDetection();
        }
        OutlierDetection.MergeFrom(other.OutlierDetection);
      }
      if (other.cleanupInterval_ != null) {
        if (cleanupInterval_ == null) {
          CleanupInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        CleanupInterval.MergeFrom(other.CleanupInterval);
      }
      if (other.upstreamBindConfig_ != null) {
        if (upstreamBindConfig_ == null) {
          UpstreamBindConfig = new global::Envoy.Api.V2.Core.BindConfig();
        }
        UpstreamBindConfig.MergeFrom(other.UpstreamBindConfig);
      }
      if (other.lbSubsetConfig_ != null) {
        if (lbSubsetConfig_ == null) {
          LbSubsetConfig = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
        }
        LbSubsetConfig.MergeFrom(other.LbSubsetConfig);
      }
      if (other.commonLbConfig_ != null) {
        if (commonLbConfig_ == null) {
          CommonLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
        }
        CommonLbConfig.MergeFrom(other.CommonLbConfig);
      }
      if (other.transportSocket_ != null) {
        if (transportSocket_ == null) {
          TransportSocket = new global::Envoy.Api.V2.Core.TransportSocket();
        }
        TransportSocket.MergeFrom(other.TransportSocket);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.ProtocolSelection != global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection.UseConfiguredProtocol) {
        ProtocolSelection = other.ProtocolSelection;
      }
      if (other.upstreamConnectionOptions_ != null) {
        if (upstreamConnectionOptions_ == null) {
          UpstreamConnectionOptions = new global::Envoy.Api.V2.UpstreamConnectionOptions();
        }
        UpstreamConnectionOptions.MergeFrom(other.UpstreamConnectionOptions);
      }
      if (other.CloseConnectionsOnHostHealthFailure != false) {
        CloseConnectionsOnHostHealthFailure = other.CloseConnectionsOnHostHealthFailure;
      }
      if (other.DrainConnectionsOnHostRemoval != false) {
        DrainConnectionsOnHostRemoval = other.DrainConnectionsOnHostRemoval;
      }
      filters_.Add(other.filters_);
      if (other.loadBalancingPolicy_ != null) {
        if (loadBalancingPolicy_ == null) {
          LoadBalancingPolicy = new global::Envoy.Api.V2.LoadBalancingPolicy();
        }
        LoadBalancingPolicy.MergeFrom(other.LoadBalancingPolicy);
      }
      switch (other.ClusterDiscoveryTypeCase) {
        case ClusterDiscoveryTypeOneofCase.Type:
          Type = other.Type;
          break;
        case ClusterDiscoveryTypeOneofCase.ClusterType:
          if (ClusterType == null) {
            ClusterType = new global::Envoy.Api.V2.Cluster.Types.CustomClusterType();
          }
          ClusterType.MergeFrom(other.ClusterType);
          break;
      }

      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          if (RingHashLbConfig == null) {
            RingHashLbConfig = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
          }
          RingHashLbConfig.MergeFrom(other.RingHashLbConfig);
          break;
        case LbConfigOneofCase.OriginalDstLbConfig:
          if (OriginalDstLbConfig == null) {
            OriginalDstLbConfig = new global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig();
          }
          OriginalDstLbConfig.MergeFrom(other.OriginalDstLbConfig);
          break;
        case LbConfigOneofCase.LeastRequestLbConfig:
          if (LeastRequestLbConfig == null) {
            LeastRequestLbConfig = new global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig();
          }
          LeastRequestLbConfig.MergeFrom(other.LeastRequestLbConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            clusterDiscoveryType_ = input.ReadEnum();
            clusterDiscoveryTypeCase_ = ClusterDiscoveryTypeOneofCase.Type;
            break;
          }
          case 26: {
            if (edsClusterConfig_ == null) {
              EdsClusterConfig = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
            }
            input.ReadMessage(EdsClusterConfig);
            break;
          }
          case 34: {
            if (connectTimeout_ == null) {
              ConnectTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(ConnectTimeout);
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 48: {
            LbPolicy = (global::Envoy.Api.V2.Cluster.Types.LbPolicy) input.ReadEnum();
            break;
          }
          case 58: {
            hosts_.AddEntriesFrom(input, _repeated_hosts_codec);
            break;
          }
          case 66: {
            healthChecks_.AddEntriesFrom(input, _repeated_healthChecks_codec);
            break;
          }
          case 74: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
          case 82: {
            if (circuitBreakers_ == null) {
              CircuitBreakers = new global::Envoy.Api.V2.ClusterNS.CircuitBreakers();
            }
            input.ReadMessage(CircuitBreakers);
            break;
          }
          case 90: {
            if (tlsContext_ == null) {
              TlsContext = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
            }
            input.ReadMessage(TlsContext);
            break;
          }
          case 106: {
            if (httpProtocolOptions_ == null) {
              HttpProtocolOptions = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
            }
            input.ReadMessage(HttpProtocolOptions);
            break;
          }
          case 114: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
          case 130: {
            if (dnsRefreshRate_ == null) {
              DnsRefreshRate = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DnsRefreshRate);
            break;
          }
          case 136: {
            DnsLookupFamily = (global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 146: {
            dnsResolvers_.AddEntriesFrom(input, _repeated_dnsResolvers_codec);
            break;
          }
          case 154: {
            if (outlierDetection_ == null) {
              OutlierDetection = new global::Envoy.Api.V2.ClusterNS.OutlierDetection();
            }
            input.ReadMessage(OutlierDetection);
            break;
          }
          case 162: {
            if (cleanupInterval_ == null) {
              CleanupInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(CleanupInterval);
            break;
          }
          case 170: {
            if (upstreamBindConfig_ == null) {
              UpstreamBindConfig = new global::Envoy.Api.V2.Core.BindConfig();
            }
            input.ReadMessage(UpstreamBindConfig);
            break;
          }
          case 178: {
            if (lbSubsetConfig_ == null) {
              LbSubsetConfig = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
            }
            input.ReadMessage(LbSubsetConfig);
            break;
          }
          case 186: {
            global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
              subBuilder.MergeFrom(RingHashLbConfig);
            }
            input.ReadMessage(subBuilder);
            RingHashLbConfig = subBuilder;
            break;
          }
          case 194: {
            if (transportSocket_ == null) {
              TransportSocket = new global::Envoy.Api.V2.Core.TransportSocket();
            }
            input.ReadMessage(TransportSocket);
            break;
          }
          case 202: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 208: {
            ProtocolSelection = (global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) input.ReadEnum();
            break;
          }
          case 218: {
            if (commonLbConfig_ == null) {
              CommonLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
            }
            input.ReadMessage(CommonLbConfig);
            break;
          }
          case 226: {
            AltStatName = input.ReadString();
            break;
          }
          case 234: {
            if (commonHttpProtocolOptions_ == null) {
              CommonHttpProtocolOptions = new global::Envoy.Api.V2.Core.HttpProtocolOptions();
            }
            input.ReadMessage(CommonHttpProtocolOptions);
            break;
          }
          case 242: {
            if (upstreamConnectionOptions_ == null) {
              UpstreamConnectionOptions = new global::Envoy.Api.V2.UpstreamConnectionOptions();
            }
            input.ReadMessage(UpstreamConnectionOptions);
            break;
          }
          case 248: {
            CloseConnectionsOnHostHealthFailure = input.ReadBool();
            break;
          }
          case 256: {
            DrainConnectionsOnHostRemoval = input.ReadBool();
            break;
          }
          case 266: {
            if (loadAssignment_ == null) {
              LoadAssignment = new global::Envoy.Api.V2.ClusterLoadAssignment();
            }
            input.ReadMessage(LoadAssignment);
            break;
          }
          case 274: {
            global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.OriginalDstLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.OriginalDstLbConfig) {
              subBuilder.MergeFrom(OriginalDstLbConfig);
            }
            input.ReadMessage(subBuilder);
            OriginalDstLbConfig = subBuilder;
            break;
          }
          case 282: {
            extensionProtocolOptions_.AddEntriesFrom(input, _map_extensionProtocolOptions_codec);
            break;
          }
          case 290: {
            typedExtensionProtocolOptions_.AddEntriesFrom(input, _map_typedExtensionProtocolOptions_codec);
            break;
          }
          case 298: {
            global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.LeastRequestLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.LeastRequestLbConfig) {
              subBuilder.MergeFrom(LeastRequestLbConfig);
            }
            input.ReadMessage(subBuilder);
            LeastRequestLbConfig = subBuilder;
            break;
          }
          case 306: {
            global::Envoy.Api.V2.Cluster.Types.CustomClusterType subBuilder = new global::Envoy.Api.V2.Cluster.Types.CustomClusterType();
            if (clusterDiscoveryTypeCase_ == ClusterDiscoveryTypeOneofCase.ClusterType) {
              subBuilder.MergeFrom(ClusterType);
            }
            input.ReadMessage(subBuilder);
            ClusterType = subBuilder;
            break;
          }
          case 312: {
            RespectDnsTtl = input.ReadBool();
            break;
          }
          case 322: {
            filters_.AddEntriesFrom(input, _repeated_filters_codec);
            break;
          }
          case 330: {
            if (loadBalancingPolicy_ == null) {
              LoadBalancingPolicy = new global::Envoy.Api.V2.LoadBalancingPolicy();
            }
            input.ReadMessage(LoadBalancingPolicy);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Cluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Refer to :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
      /// for an explanation on each type.
      /// </summary>
      public enum DiscoveryType {
        /// <summary>
        /// Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STATIC")] Static = 0,
        /// <summary>
        /// Refer to the :ref:`strict DNS discovery
        /// type&lt;arch_overview_service_discovery_types_strict_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STRICT_DNS")] StrictDns = 1,
        /// <summary>
        /// Refer to the :ref:`logical DNS discovery
        /// type&lt;arch_overview_service_discovery_types_logical_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LOGICAL_DNS")] LogicalDns = 2,
        /// <summary>
        /// Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_eds>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("EDS")] Eds = 3,
        /// <summary>
        /// Refer to the :ref:`original destination discovery
        /// type&lt;arch_overview_service_discovery_types_original_destination>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST")] OriginalDst = 4,
      }

      /// <summary>
      /// Refer to :ref:`load balancer type &lt;arch_overview_load_balancing_types>` architecture
      /// overview section for information on each type.
      /// </summary>
      public enum LbPolicy {
        /// <summary>
        /// Refer to the :ref:`round robin load balancing
        /// policy&lt;arch_overview_load_balancing_types_round_robin>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ROUND_ROBIN")] RoundRobin = 0,
        /// <summary>
        /// Refer to the :ref:`least request load balancing
        /// policy&lt;arch_overview_load_balancing_types_least_request>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LEAST_REQUEST")] LeastRequest = 1,
        /// <summary>
        /// Refer to the :ref:`ring hash load balancing
        /// policy&lt;arch_overview_load_balancing_types_ring_hash>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RING_HASH")] RingHash = 2,
        /// <summary>
        /// Refer to the :ref:`random load balancing
        /// policy&lt;arch_overview_load_balancing_types_random>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RANDOM")] Random = 3,
        /// <summary>
        /// Refer to the :ref:`original destination load balancing
        /// policy&lt;arch_overview_load_balancing_types_original_destination>`
        /// for an explanation.
        ///
        /// .. attention::
        ///
        ///   **This load balancing policy is deprecated**. Use CLUSTER_PROVIDED instead.
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST_LB")] OriginalDstLb = 4,
        /// <summary>
        /// Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("MAGLEV")] Maglev = 5,
        /// <summary>
        /// This load balancer type must be specified if the configured cluster provides a cluster
        /// specific load balancer. Consult the configured cluster's documentation for whether to set
        /// this option or not.
        /// </summary>
        [pbr::OriginalName("CLUSTER_PROVIDED")] ClusterProvided = 6,
        /// <summary>
        /// [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
        /// &lt;envoy_api_field_Cluster.load_balancing_policy>` field to determine the LB policy.
        /// [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
        /// and instead using the new load_balancing_policy field as the one and only mechanism for
        /// configuring this.]
        /// </summary>
        [pbr::OriginalName("LOAD_BALANCING_POLICY_CONFIG")] LoadBalancingPolicyConfig = 7,
      }

      /// <summary>
      /// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
      /// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
      /// only perform a lookup for addresses in the IPv6 family. If AUTO is
      /// specified, the DNS resolver will first perform a lookup for addresses in
      /// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
      /// For cluster types other than
      /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
      /// :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
      /// this setting is
      /// ignored.
      /// </summary>
      public enum DnsLookupFamily {
        [pbr::OriginalName("AUTO")] Auto = 0,
        [pbr::OriginalName("V4_ONLY")] V4Only = 1,
        [pbr::OriginalName("V6_ONLY")] V6Only = 2,
      }

      public enum ClusterProtocolSelection {
        /// <summary>
        /// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
        /// If :ref:`http2_protocol_options &lt;envoy_api_field_Cluster.http2_protocol_options>` are
        /// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
        /// </summary>
        [pbr::OriginalName("USE_CONFIGURED_PROTOCOL")] UseConfiguredProtocol = 0,
        /// <summary>
        /// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
        /// </summary>
        [pbr::OriginalName("USE_DOWNSTREAM_PROTOCOL")] UseDownstreamProtocol = 1,
      }

      /// <summary>
      /// Extended cluster type.
      /// </summary>
      public sealed partial class CustomClusterType : pb::IMessage<CustomClusterType> {
        private static readonly pb::MessageParser<CustomClusterType> _parser = new pb::MessageParser<CustomClusterType>(() => new CustomClusterType());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CustomClusterType> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomClusterType() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomClusterType(CustomClusterType other) : this() {
          name_ = other.name_;
          typedConfig_ = other.typedConfig_ != null ? other.typedConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomClusterType Clone() {
          return new CustomClusterType(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The type of the cluster to instantiate. The name must match a supported cluster type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Any typedConfig_;
        /// <summary>
        /// Cluster specific configuration which depends on the cluster being instantiated.
        /// See the supported cluster for further documentation.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return typedConfig_; }
          set {
            typedConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CustomClusterType);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CustomClusterType other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (typedConfig_ != null) hash ^= TypedConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (typedConfig_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (typedConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CustomClusterType other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.typedConfig_ != null) {
            if (typedConfig_ == null) {
              TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            TypedConfig.MergeFrom(other.TypedConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (typedConfig_ == null) {
                  TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(TypedConfig);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Only valid when discovery type is EDS.
      /// </summary>
      public sealed partial class EdsClusterConfig : pb::IMessage<EdsClusterConfig> {
        private static readonly pb::MessageParser<EdsClusterConfig> _parser = new pb::MessageParser<EdsClusterConfig>(() => new EdsClusterConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<EdsClusterConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig(EdsClusterConfig other) : this() {
          edsConfig_ = other.edsConfig_ != null ? other.edsConfig_.Clone() : null;
          serviceName_ = other.serviceName_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig Clone() {
          return new EdsClusterConfig(this);
        }

        /// <summary>Field number for the "eds_config" field.</summary>
        public const int EdsConfigFieldNumber = 1;
        private global::Envoy.Api.V2.Core.ConfigSource edsConfig_;
        /// <summary>
        /// Configuration for the source of EDS updates for this Cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.ConfigSource EdsConfig {
          get { return edsConfig_; }
          set {
            edsConfig_ = value;
          }
        }

        /// <summary>Field number for the "service_name" field.</summary>
        public const int ServiceNameFieldNumber = 2;
        private string serviceName_ = "";
        /// <summary>
        /// Optional alternative to cluster name to present to EDS. This does not
        /// have the same restrictions as cluster name, i.e. it may be arbitrary
        /// length.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ServiceName {
          get { return serviceName_; }
          set {
            serviceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as EdsClusterConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(EdsClusterConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EdsConfig, other.EdsConfig)) return false;
          if (ServiceName != other.ServiceName) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (edsConfig_ != null) hash ^= EdsConfig.GetHashCode();
          if (ServiceName.Length != 0) hash ^= ServiceName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (edsConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(ServiceName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (edsConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(EdsClusterConfig other) {
          if (other == null) {
            return;
          }
          if (other.edsConfig_ != null) {
            if (edsConfig_ == null) {
              EdsConfig = new global::Envoy.Api.V2.Core.ConfigSource();
            }
            EdsConfig.MergeFrom(other.EdsConfig);
          }
          if (other.ServiceName.Length != 0) {
            ServiceName = other.ServiceName;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (edsConfig_ == null) {
                  EdsConfig = new global::Envoy.Api.V2.Core.ConfigSource();
                }
                input.ReadMessage(EdsConfig);
                break;
              }
              case 18: {
                ServiceName = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Optionally divide the endpoints in this cluster into subsets defined by
      /// endpoint metadata and selected by route and weighted cluster metadata.
      /// </summary>
      public sealed partial class LbSubsetConfig : pb::IMessage<LbSubsetConfig> {
        private static readonly pb::MessageParser<LbSubsetConfig> _parser = new pb::MessageParser<LbSubsetConfig>(() => new LbSubsetConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LbSubsetConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig(LbSubsetConfig other) : this() {
          fallbackPolicy_ = other.fallbackPolicy_;
          defaultSubset_ = other.defaultSubset_ != null ? other.defaultSubset_.Clone() : null;
          subsetSelectors_ = other.subsetSelectors_.Clone();
          localityWeightAware_ = other.localityWeightAware_;
          scaleLocalityWeight_ = other.scaleLocalityWeight_;
          panicModeAny_ = other.panicModeAny_;
          listAsAny_ = other.listAsAny_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig Clone() {
          return new LbSubsetConfig(this);
        }

        /// <summary>Field number for the "fallback_policy" field.</summary>
        public const int FallbackPolicyFieldNumber = 1;
        private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy fallbackPolicy_ = global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback;
        /// <summary>
        /// The behavior used when no endpoint subset matches the selected route's
        /// metadata. The value defaults to
        /// :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy FallbackPolicy {
          get { return fallbackPolicy_; }
          set {
            fallbackPolicy_ = value;
          }
        }

        /// <summary>Field number for the "default_subset" field.</summary>
        public const int DefaultSubsetFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct defaultSubset_;
        /// <summary>
        /// Specifies the default subset of endpoints used during fallback if
        /// fallback_policy is
        /// :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
        /// Each field in default_subset is
        /// compared to the matching LbEndpoint.Metadata under the *envoy.lb*
        /// namespace. It is valid for no hosts to match, in which case the behavior
        /// is the same as a fallback_policy of
        /// :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Struct DefaultSubset {
          get { return defaultSubset_; }
          set {
            defaultSubset_ = value;
          }
        }

        /// <summary>Field number for the "subset_selectors" field.</summary>
        public const int SubsetSelectorsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> _repeated_subsetSelectors_codec
            = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> subsetSelectors_ = new pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector>();
        /// <summary>
        /// For each entry, LbEndpoint.Metadata's
        /// *envoy.lb* namespace is traversed and a subset is created for each unique
        /// combination of key and value. For example:
        ///
        /// .. code-block:: json
        ///
        ///   { "subset_selectors": [
        ///       { "keys": [ "version" ] },
        ///       { "keys": [ "stage", "hardware_type" ] }
        ///   ]}
        ///
        /// A subset is matched when the metadata from the selected route and
        /// weighted cluster contains the same keys and values as the subset's
        /// metadata. The same host may appear in multiple subsets.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> SubsetSelectors {
          get { return subsetSelectors_; }
        }

        /// <summary>Field number for the "locality_weight_aware" field.</summary>
        public const int LocalityWeightAwareFieldNumber = 4;
        private bool localityWeightAware_;
        /// <summary>
        /// If true, routing to subsets will take into account the localities and locality weights of the
        /// endpoints when making the routing decision.
        ///
        /// There are some potential pitfalls associated with enabling this feature, as the resulting
        /// traffic split after applying both a subset match and locality weights might be undesirable.
        ///
        /// Consider for example a situation in which you have 50/50 split across two localities X/Y
        /// which have 100 hosts each without subsetting. If the subset LB results in X having only 1
        /// host selected but Y having 100, then a lot more load is being dumped on the single host in X
        /// than originally anticipated in the load balancing assignment delivered via EDS.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool LocalityWeightAware {
          get { return localityWeightAware_; }
          set {
            localityWeightAware_ = value;
          }
        }

        /// <summary>Field number for the "scale_locality_weight" field.</summary>
        public const int ScaleLocalityWeightFieldNumber = 5;
        private bool scaleLocalityWeight_;
        /// <summary>
        /// When used with locality_weight_aware, scales the weight of each locality by the ratio
        /// of hosts in the subset vs hosts in the original subset. This aims to even out the load
        /// going to an individual locality if said locality is disproportionally affected by the
        /// subset predicate.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ScaleLocalityWeight {
          get { return scaleLocalityWeight_; }
          set {
            scaleLocalityWeight_ = value;
          }
        }

        /// <summary>Field number for the "panic_mode_any" field.</summary>
        public const int PanicModeAnyFieldNumber = 6;
        private bool panicModeAny_;
        /// <summary>
        /// If true, when a fallback policy is configured and its corresponding subset fails to find
        /// a host this will cause any host to be selected instead.
        ///
        /// This is useful when using the default subset as the fallback policy, given the default
        /// subset might become empty. With this option enabled, if that happens the LB will attempt
        /// to select a host from the entire cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool PanicModeAny {
          get { return panicModeAny_; }
          set {
            panicModeAny_ = value;
          }
        }

        /// <summary>Field number for the "list_as_any" field.</summary>
        public const int ListAsAnyFieldNumber = 7;
        private bool listAsAny_;
        /// <summary>
        /// If true, metadata specified for a metadata key will be matched against the corresponding
        /// endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
        /// and any of the elements in the list matches the criteria.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ListAsAny {
          get { return listAsAny_; }
          set {
            listAsAny_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as LbSubsetConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LbSubsetConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FallbackPolicy != other.FallbackPolicy) return false;
          if (!object.Equals(DefaultSubset, other.DefaultSubset)) return false;
          if(!subsetSelectors_.Equals(other.subsetSelectors_)) return false;
          if (LocalityWeightAware != other.LocalityWeightAware) return false;
          if (ScaleLocalityWeight != other.ScaleLocalityWeight) return false;
          if (PanicModeAny != other.PanicModeAny) return false;
          if (ListAsAny != other.ListAsAny) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) hash ^= FallbackPolicy.GetHashCode();
          if (defaultSubset_ != null) hash ^= DefaultSubset.GetHashCode();
          hash ^= subsetSelectors_.GetHashCode();
          if (LocalityWeightAware != false) hash ^= LocalityWeightAware.GetHashCode();
          if (ScaleLocalityWeight != false) hash ^= ScaleLocalityWeight.GetHashCode();
          if (PanicModeAny != false) hash ^= PanicModeAny.GetHashCode();
          if (ListAsAny != false) hash ^= ListAsAny.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DefaultSubset);
          }
          subsetSelectors_.WriteTo(output, _repeated_subsetSelectors_codec);
          if (LocalityWeightAware != false) {
            output.WriteRawTag(32);
            output.WriteBool(LocalityWeightAware);
          }
          if (ScaleLocalityWeight != false) {
            output.WriteRawTag(40);
            output.WriteBool(ScaleLocalityWeight);
          }
          if (PanicModeAny != false) {
            output.WriteRawTag(48);
            output.WriteBool(PanicModeAny);
          }
          if (ListAsAny != false) {
            output.WriteRawTag(56);
            output.WriteBool(ListAsAny);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultSubset);
          }
          size += subsetSelectors_.CalculateSize(_repeated_subsetSelectors_codec);
          if (LocalityWeightAware != false) {
            size += 1 + 1;
          }
          if (ScaleLocalityWeight != false) {
            size += 1 + 1;
          }
          if (PanicModeAny != false) {
            size += 1 + 1;
          }
          if (ListAsAny != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LbSubsetConfig other) {
          if (other == null) {
            return;
          }
          if (other.FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy.NoFallback) {
            FallbackPolicy = other.FallbackPolicy;
          }
          if (other.defaultSubset_ != null) {
            if (defaultSubset_ == null) {
              DefaultSubset = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            DefaultSubset.MergeFrom(other.DefaultSubset);
          }
          subsetSelectors_.Add(other.subsetSelectors_);
          if (other.LocalityWeightAware != false) {
            LocalityWeightAware = other.LocalityWeightAware;
          }
          if (other.ScaleLocalityWeight != false) {
            ScaleLocalityWeight = other.ScaleLocalityWeight;
          }
          if (other.PanicModeAny != false) {
            PanicModeAny = other.PanicModeAny;
          }
          if (other.ListAsAny != false) {
            ListAsAny = other.ListAsAny;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                FallbackPolicy = (global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) input.ReadEnum();
                break;
              }
              case 18: {
                if (defaultSubset_ == null) {
                  DefaultSubset = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(DefaultSubset);
                break;
              }
              case 26: {
                subsetSelectors_.AddEntriesFrom(input, _repeated_subsetSelectors_codec);
                break;
              }
              case 32: {
                LocalityWeightAware = input.ReadBool();
                break;
              }
              case 40: {
                ScaleLocalityWeight = input.ReadBool();
                break;
              }
              case 48: {
                PanicModeAny = input.ReadBool();
                break;
              }
              case 56: {
                ListAsAny = input.ReadBool();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the LbSubsetConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// If NO_FALLBACK is selected, a result
          /// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
          /// any cluster endpoint may be returned (subject to policy, health checks,
          /// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
          /// endpoints matching the values from the default_subset field.
          /// </summary>
          public enum LbSubsetFallbackPolicy {
            [pbr::OriginalName("NO_FALLBACK")] NoFallback = 0,
            [pbr::OriginalName("ANY_ENDPOINT")] AnyEndpoint = 1,
            [pbr::OriginalName("DEFAULT_SUBSET")] DefaultSubset = 2,
          }

          /// <summary>
          /// Specifications for subsets.
          /// </summary>
          public sealed partial class LbSubsetSelector : pb::IMessage<LbSubsetSelector> {
            private static readonly pb::MessageParser<LbSubsetSelector> _parser = new pb::MessageParser<LbSubsetSelector>(() => new LbSubsetSelector());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<LbSubsetSelector> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector(LbSubsetSelector other) : this() {
              keys_ = other.keys_.Clone();
              fallbackPolicy_ = other.fallbackPolicy_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector Clone() {
              return new LbSubsetSelector(this);
            }

            /// <summary>Field number for the "keys" field.</summary>
            public const int KeysFieldNumber = 1;
            private static readonly pb::FieldCodec<string> _repeated_keys_codec
                = pb::FieldCodec.ForString(10);
            private readonly pbc::RepeatedField<string> keys_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// List of keys to match with the weighted cluster metadata.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<string> Keys {
              get { return keys_; }
            }

            /// <summary>Field number for the "fallback_policy" field.</summary>
            public const int FallbackPolicyFieldNumber = 2;
            private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy fallbackPolicy_ = global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined;
            /// <summary>
            /// The behavior used when no endpoint subset matches the selected route's
            /// metadata.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy FallbackPolicy {
              get { return fallbackPolicy_; }
              set {
                fallbackPolicy_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as LbSubsetSelector);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(LbSubsetSelector other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!keys_.Equals(other.keys_)) return false;
              if (FallbackPolicy != other.FallbackPolicy) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= keys_.GetHashCode();
              if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) hash ^= FallbackPolicy.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              keys_.WriteTo(output, _repeated_keys_codec);
              if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                output.WriteRawTag(16);
                output.WriteEnum((int) FallbackPolicy);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += keys_.CalculateSize(_repeated_keys_codec);
              if (FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackPolicy);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(LbSubsetSelector other) {
              if (other == null) {
                return;
              }
              keys_.Add(other.keys_);
              if (other.FallbackPolicy != global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy.NotDefined) {
                FallbackPolicy = other.FallbackPolicy;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    keys_.AddEntriesFrom(input, _repeated_keys_codec);
                    break;
                  }
                  case 16: {
                    FallbackPolicy = (global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Types.LbSubsetSelectorFallbackPolicy) input.ReadEnum();
                    break;
                  }
                }
              }
            }

            #region Nested types
            /// <summary>Container for nested types declared in the LbSubsetSelector message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static partial class Types {
              /// <summary>
              /// Allows to override top level fallback policy per selector.
              /// </summary>
              public enum LbSubsetSelectorFallbackPolicy {
                /// <summary>
                /// If NOT_DEFINED top level config fallback policy is used instead.
                /// </summary>
                [pbr::OriginalName("NOT_DEFINED")] NotDefined = 0,
                /// <summary>
                /// If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
                /// </summary>
                [pbr::OriginalName("NO_FALLBACK")] NoFallback = 1,
                /// <summary>
                /// If ANY_ENDPOINT is selected, any cluster endpoint may be returned
                /// (subject to policy, health checks, etc).
                /// </summary>
                [pbr::OriginalName("ANY_ENDPOINT")] AnyEndpoint = 2,
                /// <summary>
                /// If DEFAULT_SUBSET is selected, load balancing is performed over the
                /// endpoints matching the values from the default_subset field.
                /// </summary>
                [pbr::OriginalName("DEFAULT_SUBSET")] DefaultSubset = 3,
              }

            }
            #endregion

          }

        }
        #endregion

      }

      /// <summary>
      /// Specific configuration for the LeastRequest load balancing policy.
      /// </summary>
      public sealed partial class LeastRequestLbConfig : pb::IMessage<LeastRequestLbConfig> {
        private static readonly pb::MessageParser<LeastRequestLbConfig> _parser = new pb::MessageParser<LeastRequestLbConfig>(() => new LeastRequestLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LeastRequestLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LeastRequestLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LeastRequestLbConfig(LeastRequestLbConfig other) : this() {
          ChoiceCount = other.ChoiceCount;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LeastRequestLbConfig Clone() {
          return new LeastRequestLbConfig(this);
        }

        /// <summary>Field number for the "choice_count" field.</summary>
        public const int ChoiceCountFieldNumber = 1;
        private static readonly pb::FieldCodec<uint?> _single_choiceCount_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
        private uint? choiceCount_;
        /// <summary>
        /// The number of random healthy hosts from which the host with the fewest active requests will
        /// be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint? ChoiceCount {
          get { return choiceCount_; }
          set {
            choiceCount_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as LeastRequestLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LeastRequestLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ChoiceCount != other.ChoiceCount) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (choiceCount_ != null) hash ^= ChoiceCount.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (choiceCount_ != null) {
            _single_choiceCount_codec.WriteTagAndValue(output, ChoiceCount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (choiceCount_ != null) {
            size += _single_choiceCount_codec.CalculateSizeWithTag(ChoiceCount);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LeastRequestLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.choiceCount_ != null) {
            if (choiceCount_ == null || other.ChoiceCount != 0) {
              ChoiceCount = other.ChoiceCount;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                uint? value = _single_choiceCount_codec.Read(input);
                if (choiceCount_ == null || value != 0) {
                  ChoiceCount = value;
                }
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class RingHashLbConfig : pb::IMessage<RingHashLbConfig> {
        private static readonly pb::MessageParser<RingHashLbConfig> _parser = new pb::MessageParser<RingHashLbConfig>(() => new RingHashLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RingHashLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig(RingHashLbConfig other) : this() {
          MinimumRingSize = other.MinimumRingSize;
          hashFunction_ = other.hashFunction_;
          MaximumRingSize = other.MaximumRingSize;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig Clone() {
          return new RingHashLbConfig(this);
        }

        /// <summary>Field number for the "minimum_ring_size" field.</summary>
        public const int MinimumRingSizeFieldNumber = 1;
        private static readonly pb::FieldCodec<ulong?> _single_minimumRingSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(10);
        private ulong? minimumRingSize_;
        /// <summary>
        /// Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
        /// provided host) the better the request distribution will reflect the desired weights. Defaults
        /// to 1024 entries, and limited to 8M entries. See also
        /// :ref:`maximum_ring_size&lt;envoy_api_field_Cluster.RingHashLbConfig.maximum_ring_size>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong? MinimumRingSize {
          get { return minimumRingSize_; }
          set {
            minimumRingSize_ = value;
          }
        }


        /// <summary>Field number for the "hash_function" field.</summary>
        public const int HashFunctionFieldNumber = 3;
        private global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction hashFunction_ = global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash;
        /// <summary>
        /// The hash function used to hash hosts onto the ketama ring. The value defaults to
        /// :ref:`XX_HASH&lt;envoy_api_enum_value_Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction HashFunction {
          get { return hashFunction_; }
          set {
            hashFunction_ = value;
          }
        }

        /// <summary>Field number for the "maximum_ring_size" field.</summary>
        public const int MaximumRingSizeFieldNumber = 4;
        private static readonly pb::FieldCodec<ulong?> _single_maximumRingSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(34);
        private ulong? maximumRingSize_;
        /// <summary>
        /// Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
        /// to further constrain resource use. See also
        /// :ref:`minimum_ring_size&lt;envoy_api_field_Cluster.RingHashLbConfig.minimum_ring_size>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong? MaximumRingSize {
          get { return maximumRingSize_; }
          set {
            maximumRingSize_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RingHashLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RingHashLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MinimumRingSize != other.MinimumRingSize) return false;
          if (HashFunction != other.HashFunction) return false;
          if (MaximumRingSize != other.MaximumRingSize) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (minimumRingSize_ != null) hash ^= MinimumRingSize.GetHashCode();
          if (HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) hash ^= HashFunction.GetHashCode();
          if (maximumRingSize_ != null) hash ^= MaximumRingSize.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (minimumRingSize_ != null) {
            _single_minimumRingSize_codec.WriteTagAndValue(output, MinimumRingSize);
          }
          if (HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            output.WriteRawTag(24);
            output.WriteEnum((int) HashFunction);
          }
          if (maximumRingSize_ != null) {
            _single_maximumRingSize_codec.WriteTagAndValue(output, MaximumRingSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (minimumRingSize_ != null) {
            size += _single_minimumRingSize_codec.CalculateSizeWithTag(MinimumRingSize);
          }
          if (HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) HashFunction);
          }
          if (maximumRingSize_ != null) {
            size += _single_maximumRingSize_codec.CalculateSizeWithTag(MaximumRingSize);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RingHashLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.minimumRingSize_ != null) {
            if (minimumRingSize_ == null || other.MinimumRingSize != 0UL) {
              MinimumRingSize = other.MinimumRingSize;
            }
          }
          if (other.HashFunction != global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction.XxHash) {
            HashFunction = other.HashFunction;
          }
          if (other.maximumRingSize_ != null) {
            if (maximumRingSize_ == null || other.MaximumRingSize != 0UL) {
              MaximumRingSize = other.MaximumRingSize;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ulong? value = _single_minimumRingSize_codec.Read(input);
                if (minimumRingSize_ == null || value != 0UL) {
                  MinimumRingSize = value;
                }
                break;
              }
              case 24: {
                HashFunction = (global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.HashFunction) input.ReadEnum();
                break;
              }
              case 34: {
                ulong? value = _single_maximumRingSize_codec.Read(input);
                if (maximumRingSize_ == null || value != 0UL) {
                  MaximumRingSize = value;
                }
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the RingHashLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// The hash function used to hash hosts onto the ketama ring.
          /// </summary>
          public enum HashFunction {
            /// <summary>
            /// Use `xxHash &lt;https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
            /// </summary>
            [pbr::OriginalName("XX_HASH")] XxHash = 0,
            /// <summary>
            /// Use `MurmurHash2 &lt;https://sites.google.com/site/murmurhash/>`_, this is compatible with
            /// std:hash&lt;string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
            /// on Linux and not macOS.
            /// </summary>
            [pbr::OriginalName("MURMUR_HASH_2")] MurmurHash2 = 1,
          }

        }
        #endregion

      }

      /// <summary>
      /// Specific configuration for the
      /// :ref:`Original Destination &lt;arch_overview_load_balancing_types_original_destination>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class OriginalDstLbConfig : pb::IMessage<OriginalDstLbConfig> {
        private static readonly pb::MessageParser<OriginalDstLbConfig> _parser = new pb::MessageParser<OriginalDstLbConfig>(() => new OriginalDstLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<OriginalDstLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[7]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public OriginalDstLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public OriginalDstLbConfig(OriginalDstLbConfig other) : this() {
          useHttpHeader_ = other.useHttpHeader_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public OriginalDstLbConfig Clone() {
          return new OriginalDstLbConfig(this);
        }

        /// <summary>Field number for the "use_http_header" field.</summary>
        public const int UseHttpHeaderFieldNumber = 1;
        private bool useHttpHeader_;
        /// <summary>
        /// When true, :ref:`x-envoy-original-dst-host
        /// &lt;config_http_conn_man_headers_x-envoy-original-dst-host>` can be used to override destination
        /// address.
        ///
        /// .. attention::
        ///
        ///   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
        ///   route traffic to arbitrary hosts and/or ports, which may have serious security
        ///   consequences.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool UseHttpHeader {
          get { return useHttpHeader_; }
          set {
            useHttpHeader_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as OriginalDstLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(OriginalDstLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UseHttpHeader != other.UseHttpHeader) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (UseHttpHeader != false) hash ^= UseHttpHeader.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (UseHttpHeader != false) {
            output.WriteRawTag(8);
            output.WriteBool(UseHttpHeader);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (UseHttpHeader != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(OriginalDstLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.UseHttpHeader != false) {
            UseHttpHeader = other.UseHttpHeader;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                UseHttpHeader = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Common configuration for all load balancer implementations.
      /// </summary>
      public sealed partial class CommonLbConfig : pb::IMessage<CommonLbConfig> {
        private static readonly pb::MessageParser<CommonLbConfig> _parser = new pb::MessageParser<CommonLbConfig>(() => new CommonLbConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CommonLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[8]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig(CommonLbConfig other) : this() {
          healthyPanicThreshold_ = other.healthyPanicThreshold_ != null ? other.healthyPanicThreshold_.Clone() : null;
          updateMergeWindow_ = other.updateMergeWindow_ != null ? other.updateMergeWindow_.Clone() : null;
          ignoreNewHostsUntilFirstHc_ = other.ignoreNewHostsUntilFirstHc_;
          closeConnectionsOnHostSetChange_ = other.closeConnectionsOnHostSetChange_;
          switch (other.LocalityConfigSpecifierCase) {
            case LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig:
              ZoneAwareLbConfig = other.ZoneAwareLbConfig.Clone();
              break;
            case LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig:
              LocalityWeightedLbConfig = other.LocalityWeightedLbConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig Clone() {
          return new CommonLbConfig(this);
        }

        /// <summary>Field number for the "healthy_panic_threshold" field.</summary>
        public const int HealthyPanicThresholdFieldNumber = 1;
        private global::Envoy.Type.Percent healthyPanicThreshold_;
        /// <summary>
        /// Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold>`.
        /// If not specified, the default is 50%.
        /// To disable panic mode, set to 0%.
        ///
        /// .. note::
        ///   The specified percent will be truncated to the nearest 1%.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Type.Percent HealthyPanicThreshold {
          get { return healthyPanicThreshold_; }
          set {
            healthyPanicThreshold_ = value;
          }
        }

        /// <summary>Field number for the "zone_aware_lb_config" field.</summary>
        public const int ZoneAwareLbConfigFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig ZoneAwareLbConfig {
          get { return localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig ? (global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig) localityConfigSpecifier_ : null; }
          set {
            localityConfigSpecifier_ = value;
            localityConfigSpecifierCase_ = value == null ? LocalityConfigSpecifierOneofCase.None : LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig;
          }
        }

        /// <summary>Field number for the "locality_weighted_lb_config" field.</summary>
        public const int LocalityWeightedLbConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig LocalityWeightedLbConfig {
          get { return localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig ? (global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig) localityConfigSpecifier_ : null; }
          set {
            localityConfigSpecifier_ = value;
            localityConfigSpecifierCase_ = value == null ? LocalityConfigSpecifierOneofCase.None : LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig;
          }
        }

        /// <summary>Field number for the "update_merge_window" field.</summary>
        public const int UpdateMergeWindowFieldNumber = 4;
        private global::Google.Protobuf.WellKnownTypes.Duration updateMergeWindow_;
        /// <summary>
        /// If set, all health check/weight/metadata updates that happen within this duration will be
        /// merged and delivered in one shot when the duration expires. The start of the duration is when
        /// the first update happens. This is useful for big clusters, with potentially noisy deploys
        /// that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
        /// or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
        /// cluster). Please always keep in mind that the use of sandbox technologies may change this
        /// behavior.
        ///
        /// If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
        /// window to 0.
        ///
        /// Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
        /// because merging those updates isn't currently safe. See
        /// https://github.com/envoyproxy/envoy/pull/3941.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration UpdateMergeWindow {
          get { return updateMergeWindow_; }
          set {
            updateMergeWindow_ = value;
          }
        }

        /// <summary>Field number for the "ignore_new_hosts_until_first_hc" field.</summary>
        public const int IgnoreNewHostsUntilFirstHcFieldNumber = 5;
        private bool ignoreNewHostsUntilFirstHc_;
        /// <summary>
        /// If set to true, Envoy will not consider new hosts when computing load balancing weights until
        /// they have been health checked for the first time. This will have no effect unless
        /// active health checking is also configured.
        ///
        /// Ignoring a host means that for any load balancing calculations that adjust weights based
        /// on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
        /// panic mode) Envoy will exclude these hosts in the denominator.
        ///
        /// For example, with hosts in two priorities P0 and P1, where P0 looks like
        /// {healthy, unhealthy (new), unhealthy (new)}
        /// and where P1 looks like
        /// {healthy, healthy}
        /// all traffic will still hit P0, as 1 / (3 - 2) = 1.
        ///
        /// Enabling this will allow scaling up the number of hosts for a given cluster without entering
        /// panic mode or triggering priority spillover, assuming the hosts pass the first health check.
        ///
        /// If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
        /// contribute to the calculation when deciding whether panic mode is enabled or not.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IgnoreNewHostsUntilFirstHc {
          get { return ignoreNewHostsUntilFirstHc_; }
          set {
            ignoreNewHostsUntilFirstHc_ = value;
          }
        }

        /// <summary>Field number for the "close_connections_on_host_set_change" field.</summary>
        public const int CloseConnectionsOnHostSetChangeFieldNumber = 6;
        private bool closeConnectionsOnHostSetChange_;
        /// <summary>
        /// If set to `true`, the cluster manager will drain all existing
        /// connections to upstream hosts whenever hosts are added or removed from the cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CloseConnectionsOnHostSetChange {
          get { return closeConnectionsOnHostSetChange_; }
          set {
            closeConnectionsOnHostSetChange_ = value;
          }
        }

        private object localityConfigSpecifier_;
        /// <summary>Enum of possible cases for the "locality_config_specifier" oneof.</summary>
        public enum LocalityConfigSpecifierOneofCase {
          None = 0,
          ZoneAwareLbConfig = 2,
          LocalityWeightedLbConfig = 3,
        }
        private LocalityConfigSpecifierOneofCase localityConfigSpecifierCase_ = LocalityConfigSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LocalityConfigSpecifierOneofCase LocalityConfigSpecifierCase {
          get { return localityConfigSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearLocalityConfigSpecifier() {
          localityConfigSpecifierCase_ = LocalityConfigSpecifierOneofCase.None;
          localityConfigSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CommonLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CommonLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(HealthyPanicThreshold, other.HealthyPanicThreshold)) return false;
          if (!object.Equals(ZoneAwareLbConfig, other.ZoneAwareLbConfig)) return false;
          if (!object.Equals(LocalityWeightedLbConfig, other.LocalityWeightedLbConfig)) return false;
          if (!object.Equals(UpdateMergeWindow, other.UpdateMergeWindow)) return false;
          if (IgnoreNewHostsUntilFirstHc != other.IgnoreNewHostsUntilFirstHc) return false;
          if (CloseConnectionsOnHostSetChange != other.CloseConnectionsOnHostSetChange) return false;
          if (LocalityConfigSpecifierCase != other.LocalityConfigSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (healthyPanicThreshold_ != null) hash ^= HealthyPanicThreshold.GetHashCode();
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) hash ^= ZoneAwareLbConfig.GetHashCode();
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) hash ^= LocalityWeightedLbConfig.GetHashCode();
          if (updateMergeWindow_ != null) hash ^= UpdateMergeWindow.GetHashCode();
          if (IgnoreNewHostsUntilFirstHc != false) hash ^= IgnoreNewHostsUntilFirstHc.GetHashCode();
          if (CloseConnectionsOnHostSetChange != false) hash ^= CloseConnectionsOnHostSetChange.GetHashCode();
          hash ^= (int) localityConfigSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (healthyPanicThreshold_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            output.WriteRawTag(18);
            output.WriteMessage(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(LocalityWeightedLbConfig);
          }
          if (updateMergeWindow_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(UpdateMergeWindow);
          }
          if (IgnoreNewHostsUntilFirstHc != false) {
            output.WriteRawTag(40);
            output.WriteBool(IgnoreNewHostsUntilFirstHc);
          }
          if (CloseConnectionsOnHostSetChange != false) {
            output.WriteRawTag(48);
            output.WriteBool(CloseConnectionsOnHostSetChange);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (healthyPanicThreshold_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HealthyPanicThreshold);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ZoneAwareLbConfig);
          }
          if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalityWeightedLbConfig);
          }
          if (updateMergeWindow_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(UpdateMergeWindow);
          }
          if (IgnoreNewHostsUntilFirstHc != false) {
            size += 1 + 1;
          }
          if (CloseConnectionsOnHostSetChange != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CommonLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.healthyPanicThreshold_ != null) {
            if (healthyPanicThreshold_ == null) {
              HealthyPanicThreshold = new global::Envoy.Type.Percent();
            }
            HealthyPanicThreshold.MergeFrom(other.HealthyPanicThreshold);
          }
          if (other.updateMergeWindow_ != null) {
            if (updateMergeWindow_ == null) {
              UpdateMergeWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            UpdateMergeWindow.MergeFrom(other.UpdateMergeWindow);
          }
          if (other.IgnoreNewHostsUntilFirstHc != false) {
            IgnoreNewHostsUntilFirstHc = other.IgnoreNewHostsUntilFirstHc;
          }
          if (other.CloseConnectionsOnHostSetChange != false) {
            CloseConnectionsOnHostSetChange = other.CloseConnectionsOnHostSetChange;
          }
          switch (other.LocalityConfigSpecifierCase) {
            case LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig:
              if (ZoneAwareLbConfig == null) {
                ZoneAwareLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
              }
              ZoneAwareLbConfig.MergeFrom(other.ZoneAwareLbConfig);
              break;
            case LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig:
              if (LocalityWeightedLbConfig == null) {
                LocalityWeightedLbConfig = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
              }
              LocalityWeightedLbConfig.MergeFrom(other.LocalityWeightedLbConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (healthyPanicThreshold_ == null) {
                  HealthyPanicThreshold = new global::Envoy.Type.Percent();
                }
                input.ReadMessage(HealthyPanicThreshold);
                break;
              }
              case 18: {
                global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.ZoneAwareLbConfig) {
                  subBuilder.MergeFrom(ZoneAwareLbConfig);
                }
                input.ReadMessage(subBuilder);
                ZoneAwareLbConfig = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.LocalityWeightedLbConfig();
                if (localityConfigSpecifierCase_ == LocalityConfigSpecifierOneofCase.LocalityWeightedLbConfig) {
                  subBuilder.MergeFrom(LocalityWeightedLbConfig);
                }
                input.ReadMessage(subBuilder);
                LocalityWeightedLbConfig = subBuilder;
                break;
              }
              case 34: {
                if (updateMergeWindow_ == null) {
                  UpdateMergeWindow = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(UpdateMergeWindow);
                break;
              }
              case 40: {
                IgnoreNewHostsUntilFirstHc = input.ReadBool();
                break;
              }
              case 48: {
                CloseConnectionsOnHostSetChange = input.ReadBool();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the CommonLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Configuration for :ref:`zone aware routing
          /// &lt;arch_overview_load_balancing_zone_aware_routing>`.
          /// </summary>
          public sealed partial class ZoneAwareLbConfig : pb::IMessage<ZoneAwareLbConfig> {
            private static readonly pb::MessageParser<ZoneAwareLbConfig> _parser = new pb::MessageParser<ZoneAwareLbConfig>(() => new ZoneAwareLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<ZoneAwareLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig(ZoneAwareLbConfig other) : this() {
              routingEnabled_ = other.routingEnabled_ != null ? other.routingEnabled_.Clone() : null;
              MinClusterSize = other.MinClusterSize;
              failTrafficOnPanic_ = other.failTrafficOnPanic_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig Clone() {
              return new ZoneAwareLbConfig(this);
            }

            /// <summary>Field number for the "routing_enabled" field.</summary>
            public const int RoutingEnabledFieldNumber = 1;
            private global::Envoy.Type.Percent routingEnabled_;
            /// <summary>
            /// Configures percentage of requests that will be considered for zone aware routing
            /// if zone aware routing is configured. If not specified, the default is 100%.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Envoy.Type.Percent RoutingEnabled {
              get { return routingEnabled_; }
              set {
                routingEnabled_ = value;
              }
            }

            /// <summary>Field number for the "min_cluster_size" field.</summary>
            public const int MinClusterSizeFieldNumber = 2;
            private static readonly pb::FieldCodec<ulong?> _single_minClusterSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(18);
            private ulong? minClusterSize_;
            /// <summary>
            /// Configures minimum upstream cluster size required for zone aware routing
            /// If upstream cluster size is less than specified, zone aware routing is not performed
            /// even if zone aware routing is configured. If not specified, the default is 6.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ulong? MinClusterSize {
              get { return minClusterSize_; }
              set {
                minClusterSize_ = value;
              }
            }


            /// <summary>Field number for the "fail_traffic_on_panic" field.</summary>
            public const int FailTrafficOnPanicFieldNumber = 3;
            private bool failTrafficOnPanic_;
            /// <summary>
            /// If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
            /// mode&lt;arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
            /// requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
            /// failing service.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool FailTrafficOnPanic {
              get { return failTrafficOnPanic_; }
              set {
                failTrafficOnPanic_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as ZoneAwareLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(ZoneAwareLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(RoutingEnabled, other.RoutingEnabled)) return false;
              if (MinClusterSize != other.MinClusterSize) return false;
              if (FailTrafficOnPanic != other.FailTrafficOnPanic) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (routingEnabled_ != null) hash ^= RoutingEnabled.GetHashCode();
              if (minClusterSize_ != null) hash ^= MinClusterSize.GetHashCode();
              if (FailTrafficOnPanic != false) hash ^= FailTrafficOnPanic.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (routingEnabled_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                _single_minClusterSize_codec.WriteTagAndValue(output, MinClusterSize);
              }
              if (FailTrafficOnPanic != false) {
                output.WriteRawTag(24);
                output.WriteBool(FailTrafficOnPanic);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (routingEnabled_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                size += _single_minClusterSize_codec.CalculateSizeWithTag(MinClusterSize);
              }
              if (FailTrafficOnPanic != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(ZoneAwareLbConfig other) {
              if (other == null) {
                return;
              }
              if (other.routingEnabled_ != null) {
                if (routingEnabled_ == null) {
                  RoutingEnabled = new global::Envoy.Type.Percent();
                }
                RoutingEnabled.MergeFrom(other.RoutingEnabled);
              }
              if (other.minClusterSize_ != null) {
                if (minClusterSize_ == null || other.MinClusterSize != 0UL) {
                  MinClusterSize = other.MinClusterSize;
                }
              }
              if (other.FailTrafficOnPanic != false) {
                FailTrafficOnPanic = other.FailTrafficOnPanic;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    if (routingEnabled_ == null) {
                      RoutingEnabled = new global::Envoy.Type.Percent();
                    }
                    input.ReadMessage(RoutingEnabled);
                    break;
                  }
                  case 18: {
                    ulong? value = _single_minClusterSize_codec.Read(input);
                    if (minClusterSize_ == null || value != 0UL) {
                      MinClusterSize = value;
                    }
                    break;
                  }
                  case 24: {
                    FailTrafficOnPanic = input.ReadBool();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// Configuration for :ref:`locality weighted load balancing
          /// &lt;arch_overview_load_balancing_locality_weighted_lb>`
          /// </summary>
          public sealed partial class LocalityWeightedLbConfig : pb::IMessage<LocalityWeightedLbConfig> {
            private static readonly pb::MessageParser<LocalityWeightedLbConfig> _parser = new pb::MessageParser<LocalityWeightedLbConfig>(() => new LocalityWeightedLbConfig());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<LocalityWeightedLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LocalityWeightedLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LocalityWeightedLbConfig(LocalityWeightedLbConfig other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LocalityWeightedLbConfig Clone() {
              return new LocalityWeightedLbConfig(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as LocalityWeightedLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(LocalityWeightedLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(LocalityWeightedLbConfig other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// [#not-implemented-hide:] Extensible load balancing policy configuration.
  ///
  /// Every LB policy defined via this mechanism will be identified via a unique name using reverse
  /// DNS notation. If the policy needs configuration parameters, it must define a message for its
  /// own configuration, which will be stored in the config field. The name of the policy will tell
  /// clients which type of message they should expect to see in the config field.
  ///
  /// Note that there are cases where it is useful to be able to independently select LB policies
  /// for choosing a locality and for choosing an endpoint within that locality. For example, a
  /// given deployment may always use the same policy to choose the locality, but for choosing the
  /// endpoint within the locality, some clusters may use weighted-round-robin, while others may
  /// use some sort of session-based balancing.
  ///
  /// This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
  /// child LB policy for each locality. For each request, the parent chooses the locality and then
  /// delegates to the child policy for that locality to choose the endpoint within the locality.
  ///
  /// To facilitate this, the config message for the top-level LB policy may include a field of
  /// type LoadBalancingPolicy that specifies the child policy.
  ///
  /// [#proto-status: experimental]
  /// </summary>
  public sealed partial class LoadBalancingPolicy : pb::IMessage<LoadBalancingPolicy> {
    private static readonly pb::MessageParser<LoadBalancingPolicy> _parser = new pb::MessageParser<LoadBalancingPolicy>(() => new LoadBalancingPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LoadBalancingPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoadBalancingPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoadBalancingPolicy(LoadBalancingPolicy other) : this() {
      policies_ = other.policies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LoadBalancingPolicy Clone() {
      return new LoadBalancingPolicy(this);
    }

    /// <summary>Field number for the "policies" field.</summary>
    public const int PoliciesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy> _repeated_policies_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy> policies_ = new pbc::RepeatedField<global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy>();
    /// <summary>
    /// Each client will iterate over the list in order and stop at the first policy that it
    /// supports. This provides a mechanism for starting to use new LB policies that are not yet
    /// supported by all clients.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.LoadBalancingPolicy.Types.Policy> Policies {
      get { return policies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LoadBalancingPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LoadBalancingPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!policies_.Equals(other.policies_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= policies_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      policies_.WriteTo(output, _repeated_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += policies_.CalculateSize(_repeated_policies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LoadBalancingPolicy other) {
      if (other == null) {
        return;
      }
      policies_.Add(other.policies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            policies_.AddEntriesFrom(input, _repeated_policies_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the LoadBalancingPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Policy : pb::IMessage<Policy> {
        private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Policy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.LoadBalancingPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Policy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Policy(Policy other) : this() {
          name_ = other.name_;
          config_ = other.config_ != null ? other.config_.Clone() : null;
          typedConfig_ = other.typedConfig_ != null ? other.typedConfig_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Policy Clone() {
          return new Policy(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Required. The name of the LB policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "config" field.</summary>
        public const int ConfigFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct config_;
        /// <summary>
        /// Optional config for the LB policy.
        /// No more than one of these two fields may be populated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Struct Config {
          get { return config_; }
          set {
            config_ = value;
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 3;
        private global::Google.Protobuf.WellKnownTypes.Any typedConfig_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return typedConfig_; }
          set {
            typedConfig_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Policy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Policy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Config, other.Config)) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (config_ != null) hash ^= Config.GetHashCode();
          if (typedConfig_ != null) hash ^= TypedConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (config_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Config);
          }
          if (typedConfig_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (config_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
          }
          if (typedConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Policy other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.config_ != null) {
            if (config_ == null) {
              Config = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            Config.MergeFrom(other.Config);
          }
          if (other.typedConfig_ != null) {
            if (typedConfig_ == null) {
              TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
            }
            TypedConfig.MergeFrom(other.TypedConfig);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (config_ == null) {
                  Config = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(Config);
                break;
              }
              case 26: {
                if (typedConfig_ == null) {
                  TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
                }
                input.ReadMessage(TypedConfig);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// An extensible structure containing the address Envoy should bind to when
  /// establishing upstream connections.
  /// </summary>
  public sealed partial class UpstreamBindConfig : pb::IMessage<UpstreamBindConfig> {
    private static readonly pb::MessageParser<UpstreamBindConfig> _parser = new pb::MessageParser<UpstreamBindConfig>(() => new UpstreamBindConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpstreamBindConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig(UpstreamBindConfig other) : this() {
      sourceAddress_ = other.sourceAddress_ != null ? other.sourceAddress_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig Clone() {
      return new UpstreamBindConfig(this);
    }

    /// <summary>Field number for the "source_address" field.</summary>
    public const int SourceAddressFieldNumber = 1;
    private global::Envoy.Api.V2.Core.Address sourceAddress_;
    /// <summary>
    /// The address Envoy should bind to when establishing upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Address SourceAddress {
      get { return sourceAddress_; }
      set {
        sourceAddress_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpstreamBindConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpstreamBindConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SourceAddress, other.SourceAddress)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceAddress_ != null) hash ^= SourceAddress.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (sourceAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceAddress);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpstreamBindConfig other) {
      if (other == null) {
        return;
      }
      if (other.sourceAddress_ != null) {
        if (sourceAddress_ == null) {
          SourceAddress = new global::Envoy.Api.V2.Core.Address();
        }
        SourceAddress.MergeFrom(other.SourceAddress);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (sourceAddress_ == null) {
              SourceAddress = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(SourceAddress);
            break;
          }
        }
      }
    }

  }

  public sealed partial class UpstreamConnectionOptions : pb::IMessage<UpstreamConnectionOptions> {
    private static readonly pb::MessageParser<UpstreamConnectionOptions> _parser = new pb::MessageParser<UpstreamConnectionOptions>(() => new UpstreamConnectionOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpstreamConnectionOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamConnectionOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamConnectionOptions(UpstreamConnectionOptions other) : this() {
      tcpKeepalive_ = other.tcpKeepalive_ != null ? other.tcpKeepalive_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamConnectionOptions Clone() {
      return new UpstreamConnectionOptions(this);
    }

    /// <summary>Field number for the "tcp_keepalive" field.</summary>
    public const int TcpKeepaliveFieldNumber = 1;
    private global::Envoy.Api.V2.Core.TcpKeepalive tcpKeepalive_;
    /// <summary>
    /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.TcpKeepalive TcpKeepalive {
      get { return tcpKeepalive_; }
      set {
        tcpKeepalive_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpstreamConnectionOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpstreamConnectionOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TcpKeepalive, other.TcpKeepalive)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (tcpKeepalive_ != null) hash ^= TcpKeepalive.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (tcpKeepalive_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TcpKeepalive);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (tcpKeepalive_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TcpKeepalive);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpstreamConnectionOptions other) {
      if (other == null) {
        return;
      }
      if (other.tcpKeepalive_ != null) {
        if (tcpKeepalive_ == null) {
          TcpKeepalive = new global::Envoy.Api.V2.Core.TcpKeepalive();
        }
        TcpKeepalive.MergeFrom(other.TcpKeepalive);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tcpKeepalive_ == null) {
              TcpKeepalive = new global::Envoy.Api.V2.Core.TcpKeepalive();
            }
            input.ReadMessage(TcpKeepalive);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
