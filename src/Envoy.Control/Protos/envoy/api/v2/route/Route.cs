// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/route/route.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2.Route {

  /// <summary>Holder for reflection information generated from envoy/api/v2/route/route.proto</summary>
  public static partial class RouteReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/route/route.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RouteReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch5lbnZveS9hcGkvdjIvcm91dGUvcm91dGUucHJvdG8SEmVudm95LmFwaS52",
            "Mi5yb3V0ZRocZW52b3kvYXBpL3YyL2NvcmUvYmFzZS5wcm90bxoeZW52b3kv",
            "dHlwZS9tYXRjaGVyL3JlZ2V4LnByb3RvGh9lbnZveS90eXBlL21hdGNoZXIv",
            "c3RyaW5nLnByb3RvGhhlbnZveS90eXBlL3BlcmNlbnQucHJvdG8aFmVudm95",
            "L3R5cGUvcmFuZ2UucHJvdG8aGWdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG8a",
            "Hmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90bxocZ29vZ2xlL3Byb3Rv",
            "YnVmL3N0cnVjdC5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnBy",
            "b3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90byLtCAoLVmlydHVhbEhvc3QS",
            "FwoEbmFtZRgBIAEoCUIJuunAAwRyAiABEhsKB2RvbWFpbnMYAiADKAlCCrrp",
            "wAMFkgECCAESKQoGcm91dGVzGAMgAygLMhkuZW52b3kuYXBpLnYyLnJvdXRl",
            "LlJvdXRlEkcKC3JlcXVpcmVfdGxzGAQgASgOMjIuZW52b3kuYXBpLnYyLnJv",
            "dXRlLlZpcnR1YWxIb3N0LlRsc1JlcXVpcmVtZW50VHlwZRI8ChB2aXJ0dWFs",
            "X2NsdXN0ZXJzGAUgAygLMiIuZW52b3kuYXBpLnYyLnJvdXRlLlZpcnR1YWxD",
            "bHVzdGVyEjIKC3JhdGVfbGltaXRzGAYgAygLMh0uZW52b3kuYXBpLnYyLnJv",
            "dXRlLlJhdGVMaW1pdBJRChZyZXF1ZXN0X2hlYWRlcnNfdG9fYWRkGAcgAygL",
            "MiQuZW52b3kuYXBpLnYyLmNvcmUuSGVhZGVyVmFsdWVPcHRpb25CC7rpwAMG",
            "kgEDEOgHEiEKGXJlcXVlc3RfaGVhZGVyc190b19yZW1vdmUYDSADKAkSUgoX",
            "cmVzcG9uc2VfaGVhZGVyc190b19hZGQYCiADKAsyJC5lbnZveS5hcGkudjIu",
            "Y29yZS5IZWFkZXJWYWx1ZU9wdGlvbkILuunAAwaSAQMQ6AcSIgoacmVzcG9u",
            "c2VfaGVhZGVyc190b19yZW1vdmUYCyADKAkSLAoEY29ycxgIIAEoCzIeLmVu",
            "dm95LmFwaS52Mi5yb3V0ZS5Db3JzUG9saWN5Ek8KEXBlcl9maWx0ZXJfY29u",
            "ZmlnGAwgAygLMjQuZW52b3kuYXBpLnYyLnJvdXRlLlZpcnR1YWxIb3N0LlBl",
            "ckZpbHRlckNvbmZpZ0VudHJ5EloKF3R5cGVkX3Blcl9maWx0ZXJfY29uZmln",
            "GA8gAygLMjkuZW52b3kuYXBpLnYyLnJvdXRlLlZpcnR1YWxIb3N0LlR5cGVk",
            "UGVyRmlsdGVyQ29uZmlnRW50cnkSJQodaW5jbHVkZV9yZXF1ZXN0X2F0dGVt",
            "cHRfY291bnQYDiABKAgSNQoMcmV0cnlfcG9saWN5GBAgASgLMh8uZW52b3ku",
            "YXBpLnYyLnJvdXRlLlJldHJ5UG9saWN5EjUKDGhlZGdlX3BvbGljeRgRIAEo",
            "CzIfLmVudm95LmFwaS52Mi5yb3V0ZS5IZWRnZVBvbGljeRpPChRQZXJGaWx0",
            "ZXJDb25maWdFbnRyeRILCgNrZXkYASABKAkSJgoFdmFsdWUYAiABKAsyFy5n",
            "b29nbGUucHJvdG9idWYuU3RydWN0OgI4ARpRChlUeXBlZFBlckZpbHRlckNv",
            "bmZpZ0VudHJ5EgsKA2tleRgBIAEoCRIjCgV2YWx1ZRgCIAEoCzIULmdvb2ds",
            "ZS5wcm90b2J1Zi5Bbnk6AjgBIjoKElRsc1JlcXVpcmVtZW50VHlwZRIICgRO",
            "T05FEAASEQoNRVhURVJOQUxfT05MWRABEgcKA0FMTBACSgQICRAKItgHCgVS",
            "b3V0ZRIMCgRuYW1lGA4gASgJEjkKBW1hdGNoGAEgASgLMh4uZW52b3kuYXBp",
            "LnYyLnJvdXRlLlJvdXRlTWF0Y2hCCrrpwAMFigECEAESMAoFcm91dGUYAiAB",
            "KAsyHy5lbnZveS5hcGkudjIucm91dGUuUm91dGVBY3Rpb25IABI2CghyZWRp",
            "cmVjdBgDIAEoCzIiLmVudm95LmFwaS52Mi5yb3V0ZS5SZWRpcmVjdEFjdGlv",
            "bkgAEkMKD2RpcmVjdF9yZXNwb25zZRgHIAEoCzIoLmVudm95LmFwaS52Mi5y",
            "b3V0ZS5EaXJlY3RSZXNwb25zZUFjdGlvbkgAEi0KCG1ldGFkYXRhGAQgASgL",
            "MhsuZW52b3kuYXBpLnYyLmNvcmUuTWV0YWRhdGESMAoJZGVjb3JhdG9yGAUg",
            "ASgLMh0uZW52b3kuYXBpLnYyLnJvdXRlLkRlY29yYXRvchJJChFwZXJfZmls",
            "dGVyX2NvbmZpZxgIIAMoCzIuLmVudm95LmFwaS52Mi5yb3V0ZS5Sb3V0ZS5Q",
            "ZXJGaWx0ZXJDb25maWdFbnRyeRJUChd0eXBlZF9wZXJfZmlsdGVyX2NvbmZp",
            "ZxgNIAMoCzIzLmVudm95LmFwaS52Mi5yb3V0ZS5Sb3V0ZS5UeXBlZFBlckZp",
            "bHRlckNvbmZpZ0VudHJ5ElEKFnJlcXVlc3RfaGVhZGVyc190b19hZGQYCSAD",
            "KAsyJC5lbnZveS5hcGkudjIuY29yZS5IZWFkZXJWYWx1ZU9wdGlvbkILuunA",
            "AwaSAQMQ6AcSIQoZcmVxdWVzdF9oZWFkZXJzX3RvX3JlbW92ZRgMIAMoCRJS",
            "ChdyZXNwb25zZV9oZWFkZXJzX3RvX2FkZBgKIAMoCzIkLmVudm95LmFwaS52",
            "Mi5jb3JlLkhlYWRlclZhbHVlT3B0aW9uQgu66cADBpIBAxDoBxIiChpyZXNw",
            "b25zZV9oZWFkZXJzX3RvX3JlbW92ZRgLIAMoCRIsCgd0cmFjaW5nGA8gASgL",
            "MhsuZW52b3kuYXBpLnYyLnJvdXRlLlRyYWNpbmcaTwoUUGVyRmlsdGVyQ29u",
            "ZmlnRW50cnkSCwoDa2V5GAEgASgJEiYKBXZhbHVlGAIgASgLMhcuZ29vZ2xl",
            "LnByb3RvYnVmLlN0cnVjdDoCOAEaUQoZVHlwZWRQZXJGaWx0ZXJDb25maWdF",
            "bnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUYAiABKAsyFC5nb29nbGUucHJv",
            "dG9idWYuQW55OgI4AUIPCgZhY3Rpb24SBbjpwAMBSgQIBhAHIrQHCg9XZWln",
            "aHRlZENsdXN0ZXISTwoIY2x1c3RlcnMYASADKAsyMS5lbnZveS5hcGkudjIu",
            "cm91dGUuV2VpZ2h0ZWRDbHVzdGVyLkNsdXN0ZXJXZWlnaHRCCrrpwAMFkgEC",
            "CAESPQoMdG90YWxfd2VpZ2h0GAMgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJ",
            "bnQzMlZhbHVlQgm66cADBCoCKAESGgoScnVudGltZV9rZXlfcHJlZml4GAIg",
            "ASgJGvQFCg1DbHVzdGVyV2VpZ2h0EhcKBG5hbWUYASABKAlCCbrpwAMEcgIg",
            "ARIsCgZ3ZWlnaHQYAiABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFs",
            "dWUSMwoObWV0YWRhdGFfbWF0Y2gYAyABKAsyGy5lbnZveS5hcGkudjIuY29y",
            "ZS5NZXRhZGF0YRJRChZyZXF1ZXN0X2hlYWRlcnNfdG9fYWRkGAQgAygLMiQu",
            "ZW52b3kuYXBpLnYyLmNvcmUuSGVhZGVyVmFsdWVPcHRpb25CC7rpwAMGkgED",
            "EOgHEiEKGXJlcXVlc3RfaGVhZGVyc190b19yZW1vdmUYCSADKAkSUgoXcmVz",
            "cG9uc2VfaGVhZGVyc190b19hZGQYBSADKAsyJC5lbnZveS5hcGkudjIuY29y",
            "ZS5IZWFkZXJWYWx1ZU9wdGlvbkILuunAAwaSAQMQ6AcSIgoacmVzcG9uc2Vf",
            "aGVhZGVyc190b19yZW1vdmUYBiADKAkSYQoRcGVyX2ZpbHRlcl9jb25maWcY",
            "CCADKAsyRi5lbnZveS5hcGkudjIucm91dGUuV2VpZ2h0ZWRDbHVzdGVyLkNs",
            "dXN0ZXJXZWlnaHQuUGVyRmlsdGVyQ29uZmlnRW50cnkSbAoXdHlwZWRfcGVy",
            "X2ZpbHRlcl9jb25maWcYCiADKAsySy5lbnZveS5hcGkudjIucm91dGUuV2Vp",
            "Z2h0ZWRDbHVzdGVyLkNsdXN0ZXJXZWlnaHQuVHlwZWRQZXJGaWx0ZXJDb25m",
            "aWdFbnRyeRpPChRQZXJGaWx0ZXJDb25maWdFbnRyeRILCgNrZXkYASABKAkS",
            "JgoFdmFsdWUYAiABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0OgI4ARpR",
            "ChlUeXBlZFBlckZpbHRlckNvbmZpZ0VudHJ5EgsKA2tleRgBIAEoCRIjCgV2",
            "YWx1ZRgCIAEoCzIULmdvb2dsZS5wcm90b2J1Zi5Bbnk6AjgBSgQIBxAIIoEE",
            "CgpSb3V0ZU1hdGNoEhAKBnByZWZpeBgBIAEoCUgAEg4KBHBhdGgYAiABKAlI",
            "ABIdCgVyZWdleBgDIAEoCUIMGAG66cADBXIDKIAISAASQgoKc2FmZV9yZWdl",
            "eBgKIAEoCzIgLmVudm95LnR5cGUubWF0Y2hlci5SZWdleE1hdGNoZXJCCrrp",
            "wAMFigECEAFIABIyCg5jYXNlX3NlbnNpdGl2ZRgEIAEoCzIaLmdvb2dsZS5w",
            "cm90b2J1Zi5Cb29sVmFsdWUSRQoQcnVudGltZV9mcmFjdGlvbhgJIAEoCzIr",
            "LmVudm95LmFwaS52Mi5jb3JlLlJ1bnRpbWVGcmFjdGlvbmFsUGVyY2VudBIy",
            "CgdoZWFkZXJzGAYgAygLMiEuZW52b3kuYXBpLnYyLnJvdXRlLkhlYWRlck1h",
            "dGNoZXISQwoQcXVlcnlfcGFyYW1ldGVycxgHIAMoCzIpLmVudm95LmFwaS52",
            "Mi5yb3V0ZS5RdWVyeVBhcmFtZXRlck1hdGNoZXISQgoEZ3JwYxgIIAEoCzI0",
            "LmVudm95LmFwaS52Mi5yb3V0ZS5Sb3V0ZU1hdGNoLkdycGNSb3V0ZU1hdGNo",
            "T3B0aW9ucxoXChVHcnBjUm91dGVNYXRjaE9wdGlvbnNCFwoOcGF0aF9zcGVj",
            "aWZpZXISBbjpwAMBSgQIBRAGIv0DCgpDb3JzUG9saWN5EhgKDGFsbG93X29y",
            "aWdpbhgBIAMoCUICGAESLQoSYWxsb3dfb3JpZ2luX3JlZ2V4GAggAygJQhEY",
            "AbrpwAMKkgEHIgVyAyiACBJEChlhbGxvd19vcmlnaW5fc3RyaW5nX21hdGNo",
            "GAsgAygLMiEuZW52b3kudHlwZS5tYXRjaGVyLlN0cmluZ01hdGNoZXISFQoN",
            "YWxsb3dfbWV0aG9kcxgCIAEoCRIVCg1hbGxvd19oZWFkZXJzGAMgASgJEhYK",
            "DmV4cG9zZV9oZWFkZXJzGAQgASgJEg8KB21heF9hZ2UYBSABKAkSNQoRYWxs",
            "b3dfY3JlZGVudGlhbHMYBiABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZh",
            "bHVlEjEKB2VuYWJsZWQYByABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZh",
            "bHVlQgIYAUgAEkUKDmZpbHRlcl9lbmFibGVkGAkgASgLMisuZW52b3kuYXBp",
            "LnYyLmNvcmUuUnVudGltZUZyYWN0aW9uYWxQZXJjZW50SAASQwoOc2hhZG93",
            "X2VuYWJsZWQYCiABKAsyKy5lbnZveS5hcGkudjIuY29yZS5SdW50aW1lRnJh",
            "Y3Rpb25hbFBlcmNlbnRCEwoRZW5hYmxlZF9zcGVjaWZpZXIixBEKC1JvdXRl",
            "QWN0aW9uEhwKB2NsdXN0ZXIYASABKAlCCbrpwAMEcgIgAUgAEiMKDmNsdXN0",
            "ZXJfaGVhZGVyGAIgASgJQgm66cADBHICIAFIABJAChF3ZWlnaHRlZF9jbHVz",
            "dGVycxgDIAEoCzIjLmVudm95LmFwaS52Mi5yb3V0ZS5XZWlnaHRlZENsdXN0",
            "ZXJIABJwCh9jbHVzdGVyX25vdF9mb3VuZF9yZXNwb25zZV9jb2RlGBQgASgO",
            "MjsuZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0aW9uLkNsdXN0ZXJOb3RG",
            "b3VuZFJlc3BvbnNlQ29kZUIKuunAAwWCAQIQARIzCg5tZXRhZGF0YV9tYXRj",
            "aBgEIAEoCzIbLmVudm95LmFwaS52Mi5jb3JlLk1ldGFkYXRhEhYKDnByZWZp",
            "eF9yZXdyaXRlGAUgASgJEhYKDGhvc3RfcmV3cml0ZRgGIAEoCUgBEjcKEWF1",
            "dG9faG9zdF9yZXdyaXRlGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xW",
            "YWx1ZUgBEiIKGGF1dG9faG9zdF9yZXdyaXRlX2hlYWRlchgdIAEoCUgBEioK",
            "B3RpbWVvdXQYCCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SLwoM",
            "aWRsZV90aW1lb3V0GBggASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9u",
            "EjUKDHJldHJ5X3BvbGljeRgJIAEoCzIfLmVudm95LmFwaS52Mi5yb3V0ZS5S",
            "ZXRyeVBvbGljeRJSChVyZXF1ZXN0X21pcnJvcl9wb2xpY3kYCiABKAsyMy5l",
            "bnZveS5hcGkudjIucm91dGUuUm91dGVBY3Rpb24uUmVxdWVzdE1pcnJvclBv",
            "bGljeRI0Cghwcmlvcml0eRgLIAEoDjIiLmVudm95LmFwaS52Mi5jb3JlLlJv",
            "dXRpbmdQcmlvcml0eRIyCgtyYXRlX2xpbWl0cxgNIAMoCzIdLmVudm95LmFw",
            "aS52Mi5yb3V0ZS5SYXRlTGltaXQSOgoWaW5jbHVkZV92aF9yYXRlX2xpbWl0",
            "cxgOIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSPwoLaGFzaF9w",
            "b2xpY3kYDyADKAsyKi5lbnZveS5hcGkudjIucm91dGUuUm91dGVBY3Rpb24u",
            "SGFzaFBvbGljeRIsCgRjb3JzGBEgASgLMh4uZW52b3kuYXBpLnYyLnJvdXRl",
            "LkNvcnNQb2xpY3kSMwoQbWF4X2dycGNfdGltZW91dBgXIAEoCzIZLmdvb2ds",
            "ZS5wcm90b2J1Zi5EdXJhdGlvbhI2ChNncnBjX3RpbWVvdXRfb2Zmc2V0GBwg",
            "ASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEkYKD3VwZ3JhZGVfY29u",
            "ZmlncxgZIAMoCzItLmVudm95LmFwaS52Mi5yb3V0ZS5Sb3V0ZUFjdGlvbi5V",
            "cGdyYWRlQ29uZmlnElgKGGludGVybmFsX3JlZGlyZWN0X2FjdGlvbhgaIAEo",
            "DjI2LmVudm95LmFwaS52Mi5yb3V0ZS5Sb3V0ZUFjdGlvbi5JbnRlcm5hbFJl",
            "ZGlyZWN0QWN0aW9uEjUKDGhlZGdlX3BvbGljeRgbIAEoCzIfLmVudm95LmFw",
            "aS52Mi5yb3V0ZS5IZWRnZVBvbGljeRqRAQoTUmVxdWVzdE1pcnJvclBvbGlj",
            "eRIaCgdjbHVzdGVyGAEgASgJQgm66cADBHICIAESFwoLcnVudGltZV9rZXkY",
            "AiABKAlCAhgBEkUKEHJ1bnRpbWVfZnJhY3Rpb24YAyABKAsyKy5lbnZveS5h",
            "cGkudjIuY29yZS5SdW50aW1lRnJhY3Rpb25hbFBlcmNlbnQa0wMKCkhhc2hQ",
            "b2xpY3kSQwoGaGVhZGVyGAEgASgLMjEuZW52b3kuYXBpLnYyLnJvdXRlLlJv",
            "dXRlQWN0aW9uLkhhc2hQb2xpY3kuSGVhZGVySAASQwoGY29va2llGAIgASgL",
            "MjEuZW52b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0aW9uLkhhc2hQb2xpY3ku",
            "Q29va2llSAASYAoVY29ubmVjdGlvbl9wcm9wZXJ0aWVzGAMgASgLMj8uZW52",
            "b3kuYXBpLnYyLnJvdXRlLlJvdXRlQWN0aW9uLkhhc2hQb2xpY3kuQ29ubmVj",
            "dGlvblByb3BlcnRpZXNIABIQCgh0ZXJtaW5hbBgEIAEoCBooCgZIZWFkZXIS",
            "HgoLaGVhZGVyX25hbWUYASABKAlCCbrpwAMEcgIgARpXCgZDb29raWUSFwoE",
            "bmFtZRgBIAEoCUIJuunAAwRyAiABEiYKA3R0bBgCIAEoCzIZLmdvb2dsZS5w",
            "cm90b2J1Zi5EdXJhdGlvbhIMCgRwYXRoGAMgASgJGikKFENvbm5lY3Rpb25Q",
            "cm9wZXJ0aWVzEhEKCXNvdXJjZV9pcBgBIAEoCEIZChBwb2xpY3lfc3BlY2lm",
            "aWVyEgW46cADARpSCg1VcGdyYWRlQ29uZmlnEhQKDHVwZ3JhZGVfdHlwZRgB",
            "IAEoCRIrCgdlbmFibGVkGAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xW",
            "YWx1ZSJFChtDbHVzdGVyTm90Rm91bmRSZXNwb25zZUNvZGUSFwoTU0VSVklD",
            "RV9VTkFWQUlMQUJMRRAAEg0KCU5PVF9GT1VORBABIloKFkludGVybmFsUmVk",
            "aXJlY3RBY3Rpb24SIgoeUEFTU19USFJPVUdIX0lOVEVSTkFMX1JFRElSRUNU",
            "EAASHAoYSEFORExFX0lOVEVSTkFMX1JFRElSRUNUEAFCGgoRY2x1c3Rlcl9z",
            "cGVjaWZpZXISBbjpwAMBQhgKFmhvc3RfcmV3cml0ZV9zcGVjaWZpZXJKBAgM",
            "EA1KBAgSEBNKBAgTEBRKBAgQEBFKBAgWEBdKBAgVEBYi6QYKC1JldHJ5UG9s",
            "aWN5EhAKCHJldHJ5X29uGAEgASgJEjEKC251bV9yZXRyaWVzGAIgASgLMhwu",
            "Z29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlEjIKD3Blcl90cnlfdGltZW91",
            "dBgDIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJFCg5yZXRyeV9w",
            "cmlvcml0eRgEIAEoCzItLmVudm95LmFwaS52Mi5yb3V0ZS5SZXRyeVBvbGlj",
            "eS5SZXRyeVByaW9yaXR5ElAKFHJldHJ5X2hvc3RfcHJlZGljYXRlGAUgAygL",
            "MjIuZW52b3kuYXBpLnYyLnJvdXRlLlJldHJ5UG9saWN5LlJldHJ5SG9zdFBy",
            "ZWRpY2F0ZRIpCiFob3N0X3NlbGVjdGlvbl9yZXRyeV9tYXhfYXR0ZW1wdHMY",
            "BiABKAMSHgoWcmV0cmlhYmxlX3N0YXR1c19jb2RlcxgHIAMoDRJECg5yZXRy",
            "eV9iYWNrX29mZhgIIAEoCzIsLmVudm95LmFwaS52Mi5yb3V0ZS5SZXRyeVBv",
            "bGljeS5SZXRyeUJhY2tPZmYakAEKDVJldHJ5UHJpb3JpdHkSFwoEbmFtZRgB",
            "IAEoCUIJuunAAwRyAiABEikKBmNvbmZpZxgCIAEoCzIXLmdvb2dsZS5wcm90",
            "b2J1Zi5TdHJ1Y3RIABIsCgx0eXBlZF9jb25maWcYAyABKAsyFC5nb29nbGUu",
            "cHJvdG9idWYuQW55SABCDQoLY29uZmlnX3R5cGUalQEKElJldHJ5SG9zdFBy",
            "ZWRpY2F0ZRIXCgRuYW1lGAEgASgJQgm66cADBHICIAESKQoGY29uZmlnGAIg",
            "ASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdEgAEiwKDHR5cGVkX2NvbmZp",
            "ZxgDIAEoCzIULmdvb2dsZS5wcm90b2J1Zi5BbnlIAEINCgtjb25maWdfdHlw",
            "ZRqLAQoMUmV0cnlCYWNrT2ZmEj4KDWJhc2VfaW50ZXJ2YWwYASABKAsyGS5n",
            "b29nbGUucHJvdG9idWYuRHVyYXRpb25CDLrpwAMHqgEECAEqABI7CgxtYXhf",
            "aW50ZXJ2YWwYAiABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CCrrp",
            "wAMFqgECKgAitAEKC0hlZGdlUG9saWN5EkEKEGluaXRpYWxfcmVxdWVzdHMY",
            "ASABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCCbrpwAMEKgIo",
            "ARJAChlhZGRpdGlvbmFsX3JlcXVlc3RfY2hhbmNlGAIgASgLMh0uZW52b3ku",
            "dHlwZS5GcmFjdGlvbmFsUGVyY2VudBIgChhoZWRnZV9vbl9wZXJfdHJ5X3Rp",
            "bWVvdXQYAyABKAgixgMKDlJlZGlyZWN0QWN0aW9uEhgKDmh0dHBzX3JlZGly",
            "ZWN0GAQgASgISAASGQoPc2NoZW1lX3JlZGlyZWN0GAcgASgJSAASFQoNaG9z",
            "dF9yZWRpcmVjdBgBIAEoCRIVCg1wb3J0X3JlZGlyZWN0GAggASgNEhcKDXBh",
            "dGhfcmVkaXJlY3QYAiABKAlIARIYCg5wcmVmaXhfcmV3cml0ZRgFIAEoCUgB",
            "EloKDXJlc3BvbnNlX2NvZGUYAyABKA4yNy5lbnZveS5hcGkudjIucm91dGUu",
            "UmVkaXJlY3RBY3Rpb24uUmVkaXJlY3RSZXNwb25zZUNvZGVCCrrpwAMFggEC",
            "EAESEwoLc3RyaXBfcXVlcnkYBiABKAgidwoUUmVkaXJlY3RSZXNwb25zZUNv",
            "ZGUSFQoRTU9WRURfUEVSTUFORU5UTFkQABIJCgVGT1VORBABEg0KCVNFRV9P",
            "VEhFUhACEhYKElRFTVBPUkFSWV9SRURJUkVDVBADEhYKElBFUk1BTkVOVF9S",
            "RURJUkVDVBAEQhoKGHNjaGVtZV9yZXdyaXRlX3NwZWNpZmllckIYChZwYXRo",
            "X3Jld3JpdGVfc3BlY2lmaWVyImEKFERpcmVjdFJlc3BvbnNlQWN0aW9uEhwK",
            "BnN0YXR1cxgBIAEoDUIMuunAAwcqBRDYBChkEisKBGJvZHkYAiABKAsyHS5l",
            "bnZveS5hcGkudjIuY29yZS5EYXRhU291cmNlIikKCURlY29yYXRvchIcCglv",
            "cGVyYXRpb24YASABKAlCCbrpwAMEcgIgASKyAQoHVHJhY2luZxI2Cg9jbGll",
            "bnRfc2FtcGxpbmcYASABKAsyHS5lbnZveS50eXBlLkZyYWN0aW9uYWxQZXJj",
            "ZW50EjYKD3JhbmRvbV9zYW1wbGluZxgCIAEoCzIdLmVudm95LnR5cGUuRnJh",
            "Y3Rpb25hbFBlcmNlbnQSNwoQb3ZlcmFsbF9zYW1wbGluZxgDIAEoCzIdLmVu",
            "dm95LnR5cGUuRnJhY3Rpb25hbFBlcmNlbnQisgEKDlZpcnR1YWxDbHVzdGVy",
            "Eh0KB3BhdHRlcm4YASABKAlCDBgBuunAAwVyAyiACBIyCgdoZWFkZXJzGAQg",
            "AygLMiEuZW52b3kuYXBpLnYyLnJvdXRlLkhlYWRlck1hdGNoZXISFwoEbmFt",
            "ZRgCIAEoCUIJuunAAwRyAiABEjQKBm1ldGhvZBgDIAEoDjIgLmVudm95LmFw",
            "aS52Mi5jb3JlLlJlcXVlc3RNZXRob2RCAhgBIo4ICglSYXRlTGltaXQSNgoF",
            "c3RhZ2UYASABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCCbrp",
            "wAMEKgIYChITCgtkaXNhYmxlX2tleRgCIAEoCRJBCgdhY3Rpb25zGAMgAygL",
            "MiQuZW52b3kuYXBpLnYyLnJvdXRlLlJhdGVMaW1pdC5BY3Rpb25CCrrpwAMF",
            "kgECCAEa8AYKBkFjdGlvbhJMCg5zb3VyY2VfY2x1c3RlchgBIAEoCzIyLmVu",
            "dm95LmFwaS52Mi5yb3V0ZS5SYXRlTGltaXQuQWN0aW9uLlNvdXJjZUNsdXN0",
            "ZXJIABJWChNkZXN0aW5hdGlvbl9jbHVzdGVyGAIgASgLMjcuZW52b3kuYXBp",
            "LnYyLnJvdXRlLlJhdGVMaW1pdC5BY3Rpb24uRGVzdGluYXRpb25DbHVzdGVy",
            "SAASTgoPcmVxdWVzdF9oZWFkZXJzGAMgASgLMjMuZW52b3kuYXBpLnYyLnJv",
            "dXRlLlJhdGVMaW1pdC5BY3Rpb24uUmVxdWVzdEhlYWRlcnNIABJMCg5yZW1v",
            "dGVfYWRkcmVzcxgEIAEoCzIyLmVudm95LmFwaS52Mi5yb3V0ZS5SYXRlTGlt",
            "aXQuQWN0aW9uLlJlbW90ZUFkZHJlc3NIABJGCgtnZW5lcmljX2tleRgFIAEo",
            "CzIvLmVudm95LmFwaS52Mi5yb3V0ZS5SYXRlTGltaXQuQWN0aW9uLkdlbmVy",
            "aWNLZXlIABJTChJoZWFkZXJfdmFsdWVfbWF0Y2gYBiABKAsyNS5lbnZveS5h",
            "cGkudjIucm91dGUuUmF0ZUxpbWl0LkFjdGlvbi5IZWFkZXJWYWx1ZU1hdGNo",
            "SAAaDwoNU291cmNlQ2x1c3RlchoUChJEZXN0aW5hdGlvbkNsdXN0ZXIaUwoO",
            "UmVxdWVzdEhlYWRlcnMSHgoLaGVhZGVyX25hbWUYASABKAlCCbrpwAMEcgIg",
            "ARIhCg5kZXNjcmlwdG9yX2tleRgCIAEoCUIJuunAAwRyAiABGg8KDVJlbW90",
            "ZUFkZHJlc3MaMQoKR2VuZXJpY0tleRIjChBkZXNjcmlwdG9yX3ZhbHVlGAEg",
            "ASgJQgm66cADBHICIAEaqQEKEEhlYWRlclZhbHVlTWF0Y2gSIwoQZGVzY3Jp",
            "cHRvcl92YWx1ZRgBIAEoCUIJuunAAwRyAiABEjAKDGV4cGVjdF9tYXRjaBgC",
            "IAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUSPgoHaGVhZGVycxgD",
            "IAMoCzIhLmVudm95LmFwaS52Mi5yb3V0ZS5IZWFkZXJNYXRjaGVyQgq66cAD",
            "BZIBAggBQhkKEGFjdGlvbl9zcGVjaWZpZXISBbjpwAMBIuwCCg1IZWFkZXJN",
            "YXRjaGVyEhcKBG5hbWUYASABKAlCCbrpwAMEcgIgARIVCgtleGFjdF9tYXRj",
            "aBgEIAEoCUgAEiMKC3JlZ2V4X21hdGNoGAUgASgJQgwYAbrpwAMFcgMogAhI",
            "ABI8ChBzYWZlX3JlZ2V4X21hdGNoGAsgASgLMiAuZW52b3kudHlwZS5tYXRj",
            "aGVyLlJlZ2V4TWF0Y2hlckgAEi0KC3JhbmdlX21hdGNoGAYgASgLMhYuZW52",
            "b3kudHlwZS5JbnQ2NFJhbmdlSAASFwoNcHJlc2VudF9tYXRjaBgHIAEoCEgA",
            "EiEKDHByZWZpeF9tYXRjaBgJIAEoCUIJuunAAwRyAiABSAASIQoMc3VmZml4",
            "X21hdGNoGAogASgJQgm66cADBHICIAFIABIUCgxpbnZlcnRfbWF0Y2gYCCAB",
            "KAhCGAoWaGVhZGVyX21hdGNoX3NwZWNpZmllckoECAIQA0oECAMQBCL4AQoV",
            "UXVlcnlQYXJhbWV0ZXJNYXRjaGVyEhoKBG5hbWUYASABKAlCDLrpwAMHcgUg",
            "ASiACBIRCgV2YWx1ZRgDIAEoCUICGAESLQoFcmVnZXgYBCABKAsyGi5nb29n",
            "bGUucHJvdG9idWYuQm9vbFZhbHVlQgIYARJFCgxzdHJpbmdfbWF0Y2gYBSAB",
            "KAsyIS5lbnZveS50eXBlLm1hdGNoZXIuU3RyaW5nTWF0Y2hlckIKuunAAwWK",
            "AQIQAUgAEhcKDXByZXNlbnRfbWF0Y2gYBiABKAhIAEIhCh9xdWVyeV9wYXJh",
            "bWV0ZXJfbWF0Y2hfc3BlY2lmaWVyQjMKIGlvLmVudm95cHJveHkuZW52b3ku",
            "YXBpLnYyLnJvdXRlQgpSb3V0ZVByb3RvUAGIAQFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Type.Matcher.RegexReflection.Descriptor, global::Envoy.Type.Matcher.StringReflection.Descriptor, global::Envoy.Type.PercentReflection.Descriptor, global::Envoy.Type.RangeReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.VirtualHost), global::Envoy.Api.V2.Route.VirtualHost.Parser, new[]{ "Name", "Domains", "Routes", "RequireTls", "VirtualClusters", "RateLimits", "RequestHeadersToAdd", "RequestHeadersToRemove", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "Cors", "PerFilterConfig", "TypedPerFilterConfig", "IncludeRequestAttemptCount", "RetryPolicy", "HedgePolicy" }, null, new[]{ typeof(global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType) }, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.Route), global::Envoy.Api.V2.Route.Route.Parser, new[]{ "Name", "Match", "Route_", "Redirect", "DirectResponse", "Metadata", "Decorator", "PerFilterConfig", "TypedPerFilterConfig", "RequestHeadersToAdd", "RequestHeadersToRemove", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "Tracing" }, new[]{ "Action" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.WeightedCluster), global::Envoy.Api.V2.Route.WeightedCluster.Parser, new[]{ "Clusters", "TotalWeight", "RuntimeKeyPrefix" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight), global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight.Parser, new[]{ "Name", "Weight", "MetadataMatch", "RequestHeadersToAdd", "RequestHeadersToRemove", "ResponseHeadersToAdd", "ResponseHeadersToRemove", "PerFilterConfig", "TypedPerFilterConfig" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteMatch), global::Envoy.Api.V2.Route.RouteMatch.Parser, new[]{ "Prefix", "Path", "Regex", "SafeRegex", "CaseSensitive", "RuntimeFraction", "Headers", "QueryParameters", "Grpc" }, new[]{ "PathSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteMatch.Types.GrpcRouteMatchOptions), global::Envoy.Api.V2.Route.RouteMatch.Types.GrpcRouteMatchOptions.Parser, null, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.CorsPolicy), global::Envoy.Api.V2.Route.CorsPolicy.Parser, new[]{ "AllowOrigin", "AllowOriginRegex", "AllowOriginStringMatch", "AllowMethods", "AllowHeaders", "ExposeHeaders", "MaxAge", "AllowCredentials", "Enabled", "FilterEnabled", "ShadowEnabled" }, new[]{ "EnabledSpecifier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction), global::Envoy.Api.V2.Route.RouteAction.Parser, new[]{ "Cluster", "ClusterHeader", "WeightedClusters", "ClusterNotFoundResponseCode", "MetadataMatch", "PrefixRewrite", "HostRewrite", "AutoHostRewrite", "AutoHostRewriteHeader", "Timeout", "IdleTimeout", "RetryPolicy", "RequestMirrorPolicy", "Priority", "RateLimits", "IncludeVhRateLimits", "HashPolicy", "Cors", "MaxGrpcTimeout", "GrpcTimeoutOffset", "UpgradeConfigs", "InternalRedirectAction", "HedgePolicy" }, new[]{ "ClusterSpecifier", "HostRewriteSpecifier" }, new[]{ typeof(global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode), typeof(global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy), global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy.Parser, new[]{ "Cluster", "RuntimeKey", "RuntimeFraction" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy), global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Parser, new[]{ "Header", "Cookie", "ConnectionProperties", "Terminal" }, new[]{ "PolicySpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header), global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header.Parser, new[]{ "HeaderName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie), global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie.Parser, new[]{ "Name", "Ttl", "Path" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties), global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties.Parser, new[]{ "SourceIp" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RouteAction.Types.UpgradeConfig), global::Envoy.Api.V2.Route.RouteAction.Types.UpgradeConfig.Parser, new[]{ "UpgradeType", "Enabled" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RetryPolicy), global::Envoy.Api.V2.Route.RetryPolicy.Parser, new[]{ "RetryOn", "NumRetries", "PerTryTimeout", "RetryPriority", "RetryHostPredicate", "HostSelectionRetryMaxAttempts", "RetriableStatusCodes", "RetryBackOff" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryPriority), global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryPriority.Parser, new[]{ "Name", "Config", "TypedConfig" }, new[]{ "ConfigType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryHostPredicate), global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryHostPredicate.Parser, new[]{ "Name", "Config", "TypedConfig" }, new[]{ "ConfigType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryBackOff), global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryBackOff.Parser, new[]{ "BaseInterval", "MaxInterval" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.HedgePolicy), global::Envoy.Api.V2.Route.HedgePolicy.Parser, new[]{ "InitialRequests", "AdditionalRequestChance", "HedgeOnPerTryTimeout" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RedirectAction), global::Envoy.Api.V2.Route.RedirectAction.Parser, new[]{ "HttpsRedirect", "SchemeRedirect", "HostRedirect", "PortRedirect", "PathRedirect", "PrefixRewrite", "ResponseCode", "StripQuery" }, new[]{ "SchemeRewriteSpecifier", "PathRewriteSpecifier" }, new[]{ typeof(global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.DirectResponseAction), global::Envoy.Api.V2.Route.DirectResponseAction.Parser, new[]{ "Status", "Body" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.Decorator), global::Envoy.Api.V2.Route.Decorator.Parser, new[]{ "Operation" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.Tracing), global::Envoy.Api.V2.Route.Tracing.Parser, new[]{ "ClientSampling", "RandomSampling", "OverallSampling" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.VirtualCluster), global::Envoy.Api.V2.Route.VirtualCluster.Parser, new[]{ "Pattern", "Headers", "Name", "Method" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit), global::Envoy.Api.V2.Route.RateLimit.Parser, new[]{ "Stage", "DisableKey", "Actions" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Parser, new[]{ "SourceCluster", "DestinationCluster", "RequestHeaders", "RemoteAddress", "GenericKey", "HeaderValueMatch" }, new[]{ "ActionSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders.Parser, new[]{ "HeaderName", "DescriptorKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey.Parser, new[]{ "DescriptorValue" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch), global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch.Parser, new[]{ "DescriptorValue", "ExpectMatch", "Headers" }, null, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.HeaderMatcher), global::Envoy.Api.V2.Route.HeaderMatcher.Parser, new[]{ "Name", "ExactMatch", "RegexMatch", "SafeRegexMatch", "RangeMatch", "PresentMatch", "PrefixMatch", "SuffixMatch", "InvertMatch" }, new[]{ "HeaderMatchSpecifier" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Route.QueryParameterMatcher), global::Envoy.Api.V2.Route.QueryParameterMatcher.Parser, new[]{ "Name", "Value", "Regex", "StringMatch", "PresentMatch" }, new[]{ "QueryParameterMatchSpecifier" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// The top level element in the routing configuration is a virtual host. Each virtual host has
  /// a logical name as well as a set of domains that get routed to it based on the incoming request's
  /// host header. This allows a single listener to service multiple top level domain path trees. Once
  /// a virtual host is selected based on the domain, the routes are processed in order to see which
  /// upstream cluster to route to or whether to perform a redirect.
  /// [#comment:next free field: 17]
  /// </summary>
  public sealed partial class VirtualHost : pb::IMessage<VirtualHost> {
    private static readonly pb::MessageParser<VirtualHost> _parser = new pb::MessageParser<VirtualHost>(() => new VirtualHost());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VirtualHost> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualHost() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualHost(VirtualHost other) : this() {
      name_ = other.name_;
      domains_ = other.domains_.Clone();
      routes_ = other.routes_.Clone();
      requireTls_ = other.requireTls_;
      virtualClusters_ = other.virtualClusters_.Clone();
      rateLimits_ = other.rateLimits_.Clone();
      requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
      requestHeadersToRemove_ = other.requestHeadersToRemove_.Clone();
      responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
      responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
      cors_ = other.cors_ != null ? other.cors_.Clone() : null;
      perFilterConfig_ = other.perFilterConfig_.Clone();
      typedPerFilterConfig_ = other.typedPerFilterConfig_.Clone();
      includeRequestAttemptCount_ = other.includeRequestAttemptCount_;
      retryPolicy_ = other.retryPolicy_ != null ? other.retryPolicy_.Clone() : null;
      hedgePolicy_ = other.hedgePolicy_ != null ? other.hedgePolicy_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualHost Clone() {
      return new VirtualHost(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The logical name of the virtual host. This is used when emitting certain
    /// statistics but is not relevant for routing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domains" field.</summary>
    public const int DomainsFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_domains_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> domains_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A list of domains (host/authority header) that will be matched to this
    /// virtual host. Wildcard hosts are supported in the suffix or prefix form.
    ///
    /// Domain search order:
    ///  1. Exact domain names: ``www.foo.com``.
    ///  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
    ///  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
    ///  4. Special wildcard ``*`` matching any domain.
    ///
    /// .. note::
    ///
    ///   The wildcard will not match the empty string.
    ///   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
    ///   The longest wildcards match first.
    ///   Only a single virtual host in the entire route configuration can match on ``*``. A domain
    ///   must be unique across all virtual hosts or the config will fail to load.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Domains {
      get { return domains_; }
    }

    /// <summary>Field number for the "routes" field.</summary>
    public const int RoutesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.Route> _repeated_routes_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Route.Route.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.Route> routes_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.Route>();
    /// <summary>
    /// The list of routes that will be matched, in order, for incoming requests.
    /// The first route that matches will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.Route> Routes {
      get { return routes_; }
    }

    /// <summary>Field number for the "require_tls" field.</summary>
    public const int RequireTlsFieldNumber = 4;
    private global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType requireTls_ = global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType.None;
    /// <summary>
    /// Specifies the type of TLS enforcement the virtual host expects. If this option is not
    /// specified, there is no TLS requirement for the virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType RequireTls {
      get { return requireTls_; }
      set {
        requireTls_ = value;
      }
    }

    /// <summary>Field number for the "virtual_clusters" field.</summary>
    public const int VirtualClustersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.VirtualCluster> _repeated_virtualClusters_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Api.V2.Route.VirtualCluster.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.VirtualCluster> virtualClusters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.VirtualCluster>();
    /// <summary>
    /// A list of virtual clusters defined for this virtual host. Virtual clusters
    /// are used for additional statistics gathering.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.VirtualCluster> VirtualClusters {
      get { return virtualClusters_; }
    }

    /// <summary>Field number for the "rate_limits" field.</summary>
    public const int RateLimitsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RateLimit> _repeated_rateLimits_codec
        = pb::FieldCodec.ForMessage(50, global::Envoy.Api.V2.Route.RateLimit.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit> rateLimits_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit>();
    /// <summary>
    /// Specifies a set of rate limit configurations that will be applied to the
    /// virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit> RateLimits {
      get { return rateLimits_; }
    }

    /// <summary>Field number for the "request_headers_to_add" field.</summary>
    public const int RequestHeadersToAddFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_requestHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be added to each request
    /// handled by this virtual host. Headers specified at this level are applied
    /// after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
    /// enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> RequestHeadersToAdd {
      get { return requestHeadersToAdd_; }
    }

    /// <summary>Field number for the "request_headers_to_remove" field.</summary>
    public const int RequestHeadersToRemoveFieldNumber = 13;
    private static readonly pb::FieldCodec<string> _repeated_requestHeadersToRemove_codec
        = pb::FieldCodec.ForString(106);
    private readonly pbc::RepeatedField<string> requestHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each request
    /// handled by this virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> RequestHeadersToRemove {
      get { return requestHeadersToRemove_; }
    }

    /// <summary>Field number for the "response_headers_to_add" field.</summary>
    public const int ResponseHeadersToAddFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_responseHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(82, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be added to each response
    /// handled by this virtual host. Headers specified at this level are applied
    /// after headers from enclosed :ref:`envoy_api_msg_route.Route` and before headers from the
    /// enclosing :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> ResponseHeadersToAdd {
      get { return responseHeadersToAdd_; }
    }

    /// <summary>Field number for the "response_headers_to_remove" field.</summary>
    public const int ResponseHeadersToRemoveFieldNumber = 11;
    private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
        = pb::FieldCodec.ForString(90);
    private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each response
    /// handled by this virtual host.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ResponseHeadersToRemove {
      get { return responseHeadersToRemove_; }
    }

    /// <summary>Field number for the "cors" field.</summary>
    public const int CorsFieldNumber = 8;
    private global::Envoy.Api.V2.Route.CorsPolicy cors_;
    /// <summary>
    /// Indicates that the virtual host has a CORS policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.CorsPolicy Cors {
      get { return cors_; }
      set {
        cors_ = value;
      }
    }

    /// <summary>Field number for the "per_filter_config" field.</summary>
    public const int PerFilterConfigFieldNumber = 12;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec _map_perFilterConfig_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Struct.Parser), 98);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> perFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>();
    /// <summary>
    /// The per_filter_config field can be used to provide virtual host-specific
    /// configurations for filters. The key should match the filter name, such as
    /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
    /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>`
    /// for if and how it is utilized.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> PerFilterConfig {
      get { return perFilterConfig_; }
    }

    /// <summary>Field number for the "typed_per_filter_config" field.</summary>
    public const int TypedPerFilterConfigFieldNumber = 15;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedPerFilterConfig_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 122);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedPerFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// The per_filter_config field can be used to provide virtual host-specific
    /// configurations for filters. The key should match the filter name, such as
    /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
    /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>`
    /// for if and how it is utilized.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedPerFilterConfig {
      get { return typedPerFilterConfig_; }
    }

    /// <summary>Field number for the "include_request_attempt_count" field.</summary>
    public const int IncludeRequestAttemptCountFieldNumber = 14;
    private bool includeRequestAttemptCount_;
    /// <summary>
    /// Decides whether the :ref:`x-envoy-attempt-count
    /// &lt;config_http_filters_router_x-envoy-attempt-count>` header should be included
    /// in the upstream request. Setting this option will cause it to override any existing header
    /// value, so in the case of two Envoys on the request path with this option enabled, the upstream
    /// will see the attempt count as perceived by the second Envoy. Defaults to false.
    /// This header is unaffected by the
    /// :ref:`suppress_envoy_headers
    /// &lt;envoy_api_field_config.filter.http.router.v2.Router.suppress_envoy_headers>` flag.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeRequestAttemptCount {
      get { return includeRequestAttemptCount_; }
      set {
        includeRequestAttemptCount_ = value;
      }
    }

    /// <summary>Field number for the "retry_policy" field.</summary>
    public const int RetryPolicyFieldNumber = 16;
    private global::Envoy.Api.V2.Route.RetryPolicy retryPolicy_;
    /// <summary>
    /// Indicates the retry policy for all routes in this virtual host. Note that setting a
    /// route level entry will take precedence over this config and it'll be treated
    /// independently (e.g.: values are not inherited).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RetryPolicy RetryPolicy {
      get { return retryPolicy_; }
      set {
        retryPolicy_ = value;
      }
    }

    /// <summary>Field number for the "hedge_policy" field.</summary>
    public const int HedgePolicyFieldNumber = 17;
    private global::Envoy.Api.V2.Route.HedgePolicy hedgePolicy_;
    /// <summary>
    /// Indicates the hedge policy for all routes in this virtual host. Note that setting a
    /// route level entry will take precedence over this config and it'll be treated
    /// independently (e.g.: values are not inherited).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.HedgePolicy HedgePolicy {
      get { return hedgePolicy_; }
      set {
        hedgePolicy_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VirtualHost);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VirtualHost other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!domains_.Equals(other.domains_)) return false;
      if(!routes_.Equals(other.routes_)) return false;
      if (RequireTls != other.RequireTls) return false;
      if(!virtualClusters_.Equals(other.virtualClusters_)) return false;
      if(!rateLimits_.Equals(other.rateLimits_)) return false;
      if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
      if(!requestHeadersToRemove_.Equals(other.requestHeadersToRemove_)) return false;
      if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
      if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
      if (!object.Equals(Cors, other.Cors)) return false;
      if (!PerFilterConfig.Equals(other.PerFilterConfig)) return false;
      if (!TypedPerFilterConfig.Equals(other.TypedPerFilterConfig)) return false;
      if (IncludeRequestAttemptCount != other.IncludeRequestAttemptCount) return false;
      if (!object.Equals(RetryPolicy, other.RetryPolicy)) return false;
      if (!object.Equals(HedgePolicy, other.HedgePolicy)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= domains_.GetHashCode();
      hash ^= routes_.GetHashCode();
      if (RequireTls != global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType.None) hash ^= RequireTls.GetHashCode();
      hash ^= virtualClusters_.GetHashCode();
      hash ^= rateLimits_.GetHashCode();
      hash ^= requestHeadersToAdd_.GetHashCode();
      hash ^= requestHeadersToRemove_.GetHashCode();
      hash ^= responseHeadersToAdd_.GetHashCode();
      hash ^= responseHeadersToRemove_.GetHashCode();
      if (cors_ != null) hash ^= Cors.GetHashCode();
      hash ^= PerFilterConfig.GetHashCode();
      hash ^= TypedPerFilterConfig.GetHashCode();
      if (IncludeRequestAttemptCount != false) hash ^= IncludeRequestAttemptCount.GetHashCode();
      if (retryPolicy_ != null) hash ^= RetryPolicy.GetHashCode();
      if (hedgePolicy_ != null) hash ^= HedgePolicy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      domains_.WriteTo(output, _repeated_domains_codec);
      routes_.WriteTo(output, _repeated_routes_codec);
      if (RequireTls != global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType.None) {
        output.WriteRawTag(32);
        output.WriteEnum((int) RequireTls);
      }
      virtualClusters_.WriteTo(output, _repeated_virtualClusters_codec);
      rateLimits_.WriteTo(output, _repeated_rateLimits_codec);
      requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
      if (cors_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Cors);
      }
      responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
      responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
      perFilterConfig_.WriteTo(output, _map_perFilterConfig_codec);
      requestHeadersToRemove_.WriteTo(output, _repeated_requestHeadersToRemove_codec);
      if (IncludeRequestAttemptCount != false) {
        output.WriteRawTag(112);
        output.WriteBool(IncludeRequestAttemptCount);
      }
      typedPerFilterConfig_.WriteTo(output, _map_typedPerFilterConfig_codec);
      if (retryPolicy_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(RetryPolicy);
      }
      if (hedgePolicy_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(HedgePolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += domains_.CalculateSize(_repeated_domains_codec);
      size += routes_.CalculateSize(_repeated_routes_codec);
      if (RequireTls != global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType.None) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) RequireTls);
      }
      size += virtualClusters_.CalculateSize(_repeated_virtualClusters_codec);
      size += rateLimits_.CalculateSize(_repeated_rateLimits_codec);
      size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
      size += requestHeadersToRemove_.CalculateSize(_repeated_requestHeadersToRemove_codec);
      size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
      size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
      if (cors_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cors);
      }
      size += perFilterConfig_.CalculateSize(_map_perFilterConfig_codec);
      size += typedPerFilterConfig_.CalculateSize(_map_typedPerFilterConfig_codec);
      if (IncludeRequestAttemptCount != false) {
        size += 1 + 1;
      }
      if (retryPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RetryPolicy);
      }
      if (hedgePolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HedgePolicy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VirtualHost other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      domains_.Add(other.domains_);
      routes_.Add(other.routes_);
      if (other.RequireTls != global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType.None) {
        RequireTls = other.RequireTls;
      }
      virtualClusters_.Add(other.virtualClusters_);
      rateLimits_.Add(other.rateLimits_);
      requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
      requestHeadersToRemove_.Add(other.requestHeadersToRemove_);
      responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
      responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
      if (other.cors_ != null) {
        if (cors_ == null) {
          Cors = new global::Envoy.Api.V2.Route.CorsPolicy();
        }
        Cors.MergeFrom(other.Cors);
      }
      perFilterConfig_.Add(other.perFilterConfig_);
      typedPerFilterConfig_.Add(other.typedPerFilterConfig_);
      if (other.IncludeRequestAttemptCount != false) {
        IncludeRequestAttemptCount = other.IncludeRequestAttemptCount;
      }
      if (other.retryPolicy_ != null) {
        if (retryPolicy_ == null) {
          RetryPolicy = new global::Envoy.Api.V2.Route.RetryPolicy();
        }
        RetryPolicy.MergeFrom(other.RetryPolicy);
      }
      if (other.hedgePolicy_ != null) {
        if (hedgePolicy_ == null) {
          HedgePolicy = new global::Envoy.Api.V2.Route.HedgePolicy();
        }
        HedgePolicy.MergeFrom(other.HedgePolicy);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            domains_.AddEntriesFrom(input, _repeated_domains_codec);
            break;
          }
          case 26: {
            routes_.AddEntriesFrom(input, _repeated_routes_codec);
            break;
          }
          case 32: {
            RequireTls = (global::Envoy.Api.V2.Route.VirtualHost.Types.TlsRequirementType) input.ReadEnum();
            break;
          }
          case 42: {
            virtualClusters_.AddEntriesFrom(input, _repeated_virtualClusters_codec);
            break;
          }
          case 50: {
            rateLimits_.AddEntriesFrom(input, _repeated_rateLimits_codec);
            break;
          }
          case 58: {
            requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
            break;
          }
          case 66: {
            if (cors_ == null) {
              Cors = new global::Envoy.Api.V2.Route.CorsPolicy();
            }
            input.ReadMessage(Cors);
            break;
          }
          case 82: {
            responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
            break;
          }
          case 90: {
            responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
            break;
          }
          case 98: {
            perFilterConfig_.AddEntriesFrom(input, _map_perFilterConfig_codec);
            break;
          }
          case 106: {
            requestHeadersToRemove_.AddEntriesFrom(input, _repeated_requestHeadersToRemove_codec);
            break;
          }
          case 112: {
            IncludeRequestAttemptCount = input.ReadBool();
            break;
          }
          case 122: {
            typedPerFilterConfig_.AddEntriesFrom(input, _map_typedPerFilterConfig_codec);
            break;
          }
          case 130: {
            if (retryPolicy_ == null) {
              RetryPolicy = new global::Envoy.Api.V2.Route.RetryPolicy();
            }
            input.ReadMessage(RetryPolicy);
            break;
          }
          case 138: {
            if (hedgePolicy_ == null) {
              HedgePolicy = new global::Envoy.Api.V2.Route.HedgePolicy();
            }
            input.ReadMessage(HedgePolicy);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the VirtualHost message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum TlsRequirementType {
        /// <summary>
        /// No TLS requirement for the virtual host.
        /// </summary>
        [pbr::OriginalName("NONE")] None = 0,
        /// <summary>
        /// External requests must use TLS. If a request is external and it is not
        /// using TLS, a 301 redirect will be sent telling the client to use HTTPS.
        /// </summary>
        [pbr::OriginalName("EXTERNAL_ONLY")] ExternalOnly = 1,
        /// <summary>
        /// All requests must use TLS. If a request is not using TLS, a 301 redirect
        /// will be sent telling the client to use HTTPS.
        /// </summary>
        [pbr::OriginalName("ALL")] All = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// A route is both a specification of how to match a request as well as an indication of what to do
  /// next (e.g., redirect, forward, rewrite, etc.).
  ///
  /// .. attention::
  ///
  ///   Envoy supports routing on HTTP method via :ref:`header matching
  ///   &lt;envoy_api_msg_route.HeaderMatcher>`.
  /// [#comment:next free field: 15]
  /// </summary>
  public sealed partial class Route : pb::IMessage<Route> {
    private static readonly pb::MessageParser<Route> _parser = new pb::MessageParser<Route>(() => new Route());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Route> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Route() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Route(Route other) : this() {
      name_ = other.name_;
      match_ = other.match_ != null ? other.match_.Clone() : null;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      decorator_ = other.decorator_ != null ? other.decorator_.Clone() : null;
      perFilterConfig_ = other.perFilterConfig_.Clone();
      typedPerFilterConfig_ = other.typedPerFilterConfig_.Clone();
      requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
      requestHeadersToRemove_ = other.requestHeadersToRemove_.Clone();
      responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
      responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
      tracing_ = other.tracing_ != null ? other.tracing_.Clone() : null;
      switch (other.ActionCase) {
        case ActionOneofCase.Route_:
          Route_ = other.Route_.Clone();
          break;
        case ActionOneofCase.Redirect:
          Redirect = other.Redirect.Clone();
          break;
        case ActionOneofCase.DirectResponse:
          DirectResponse = other.DirectResponse.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Route Clone() {
      return new Route(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 14;
    private string name_ = "";
    /// <summary>
    /// Name for the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "match" field.</summary>
    public const int MatchFieldNumber = 1;
    private global::Envoy.Api.V2.Route.RouteMatch match_;
    /// <summary>
    /// Route matching parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteMatch Match {
      get { return match_; }
      set {
        match_ = value;
      }
    }

    /// <summary>Field number for the "route" field.</summary>
    public const int Route_FieldNumber = 2;
    /// <summary>
    /// Route request to some upstream cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction Route_ {
      get { return actionCase_ == ActionOneofCase.Route_ ? (global::Envoy.Api.V2.Route.RouteAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.Route_;
      }
    }

    /// <summary>Field number for the "redirect" field.</summary>
    public const int RedirectFieldNumber = 3;
    /// <summary>
    /// Return a redirect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RedirectAction Redirect {
      get { return actionCase_ == ActionOneofCase.Redirect ? (global::Envoy.Api.V2.Route.RedirectAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.Redirect;
      }
    }

    /// <summary>Field number for the "direct_response" field.</summary>
    public const int DirectResponseFieldNumber = 7;
    /// <summary>
    /// Return an arbitrary HTTP response directly, without proxying.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.DirectResponseAction DirectResponse {
      get { return actionCase_ == ActionOneofCase.DirectResponse ? (global::Envoy.Api.V2.Route.DirectResponseAction) action_ : null; }
      set {
        action_ = value;
        actionCase_ = value == null ? ActionOneofCase.None : ActionOneofCase.DirectResponse;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 4;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// The Metadata field can be used to provide additional information
    /// about the route. It can be used for configuration, stats, and logging.
    /// The metadata should go under the filter namespace that will need it.
    /// For instance, if the metadata is intended for the Router filter,
    /// the filter name should be specified as *envoy.router*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "decorator" field.</summary>
    public const int DecoratorFieldNumber = 5;
    private global::Envoy.Api.V2.Route.Decorator decorator_;
    /// <summary>
    /// Decorator for the matched route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.Decorator Decorator {
      get { return decorator_; }
      set {
        decorator_ = value;
      }
    }

    /// <summary>Field number for the "per_filter_config" field.</summary>
    public const int PerFilterConfigFieldNumber = 8;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec _map_perFilterConfig_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Struct.Parser), 66);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> perFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>();
    /// <summary>
    /// The per_filter_config field can be used to provide route-specific
    /// configurations for filters. The key should match the filter name, such as
    /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
    /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>` for
    /// if and how it is utilized.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> PerFilterConfig {
      get { return perFilterConfig_; }
    }

    /// <summary>Field number for the "typed_per_filter_config" field.</summary>
    public const int TypedPerFilterConfigFieldNumber = 13;
    private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedPerFilterConfig_codec
        = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 106);
    private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedPerFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
    /// <summary>
    /// The per_filter_config field can be used to provide route-specific
    /// configurations for filters. The key should match the filter name, such as
    /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
    /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>` for
    /// if and how it is utilized.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedPerFilterConfig {
      get { return typedPerFilterConfig_; }
    }

    /// <summary>Field number for the "request_headers_to_add" field.</summary>
    public const int RequestHeadersToAddFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_requestHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
    /// <summary>
    /// Specifies a set of headers that will be added to requests matching this
    /// route. Headers specified at this level are applied before headers from the
    /// enclosing :ref:`envoy_api_msg_route.VirtualHost` and
    /// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
    /// header value syntax, see the documentation on :ref:`custom request headers
    /// &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> RequestHeadersToAdd {
      get { return requestHeadersToAdd_; }
    }

    /// <summary>Field number for the "request_headers_to_remove" field.</summary>
    public const int RequestHeadersToRemoveFieldNumber = 12;
    private static readonly pb::FieldCodec<string> _repeated_requestHeadersToRemove_codec
        = pb::FieldCodec.ForString(98);
    private readonly pbc::RepeatedField<string> requestHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each request
    /// matching this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> RequestHeadersToRemove {
      get { return requestHeadersToRemove_; }
    }

    /// <summary>Field number for the "response_headers_to_add" field.</summary>
    public const int ResponseHeadersToAddFieldNumber = 10;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_responseHeadersToAdd_codec
        = pb::FieldCodec.ForMessage(82, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
    /// <summary>
    /// Specifies a set of headers that will be added to responses to requests
    /// matching this route. Headers specified at this level are applied before
    /// headers from the enclosing :ref:`envoy_api_msg_route.VirtualHost` and
    /// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including
    /// details on header value syntax, see the documentation on
    /// :ref:`custom request headers &lt;config_http_conn_man_headers_custom_request_headers>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> ResponseHeadersToAdd {
      get { return responseHeadersToAdd_; }
    }

    /// <summary>Field number for the "response_headers_to_remove" field.</summary>
    public const int ResponseHeadersToRemoveFieldNumber = 11;
    private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
        = pb::FieldCodec.ForString(90);
    private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies a list of HTTP headers that should be removed from each response
    /// to requests matching this route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ResponseHeadersToRemove {
      get { return responseHeadersToRemove_; }
    }

    /// <summary>Field number for the "tracing" field.</summary>
    public const int TracingFieldNumber = 15;
    private global::Envoy.Api.V2.Route.Tracing tracing_;
    /// <summary>
    /// Presence of the object defines whether the connection manager's tracing configuration
    /// is overridden by this route specific instance.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.Tracing Tracing {
      get { return tracing_; }
      set {
        tracing_ = value;
      }
    }

    private object action_;
    /// <summary>Enum of possible cases for the "action" oneof.</summary>
    public enum ActionOneofCase {
      None = 0,
      Route_ = 2,
      Redirect = 3,
      DirectResponse = 7,
    }
    private ActionOneofCase actionCase_ = ActionOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ActionOneofCase ActionCase {
      get { return actionCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAction() {
      actionCase_ = ActionOneofCase.None;
      action_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Route);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Route other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Match, other.Match)) return false;
      if (!object.Equals(Route_, other.Route_)) return false;
      if (!object.Equals(Redirect, other.Redirect)) return false;
      if (!object.Equals(DirectResponse, other.DirectResponse)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Decorator, other.Decorator)) return false;
      if (!PerFilterConfig.Equals(other.PerFilterConfig)) return false;
      if (!TypedPerFilterConfig.Equals(other.TypedPerFilterConfig)) return false;
      if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
      if(!requestHeadersToRemove_.Equals(other.requestHeadersToRemove_)) return false;
      if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
      if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
      if (!object.Equals(Tracing, other.Tracing)) return false;
      if (ActionCase != other.ActionCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (match_ != null) hash ^= Match.GetHashCode();
      if (actionCase_ == ActionOneofCase.Route_) hash ^= Route_.GetHashCode();
      if (actionCase_ == ActionOneofCase.Redirect) hash ^= Redirect.GetHashCode();
      if (actionCase_ == ActionOneofCase.DirectResponse) hash ^= DirectResponse.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (decorator_ != null) hash ^= Decorator.GetHashCode();
      hash ^= PerFilterConfig.GetHashCode();
      hash ^= TypedPerFilterConfig.GetHashCode();
      hash ^= requestHeadersToAdd_.GetHashCode();
      hash ^= requestHeadersToRemove_.GetHashCode();
      hash ^= responseHeadersToAdd_.GetHashCode();
      hash ^= responseHeadersToRemove_.GetHashCode();
      if (tracing_ != null) hash ^= Tracing.GetHashCode();
      hash ^= (int) actionCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (match_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Match);
      }
      if (actionCase_ == ActionOneofCase.Route_) {
        output.WriteRawTag(18);
        output.WriteMessage(Route_);
      }
      if (actionCase_ == ActionOneofCase.Redirect) {
        output.WriteRawTag(26);
        output.WriteMessage(Redirect);
      }
      if (metadata_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Metadata);
      }
      if (decorator_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Decorator);
      }
      if (actionCase_ == ActionOneofCase.DirectResponse) {
        output.WriteRawTag(58);
        output.WriteMessage(DirectResponse);
      }
      perFilterConfig_.WriteTo(output, _map_perFilterConfig_codec);
      requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
      responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
      responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
      requestHeadersToRemove_.WriteTo(output, _repeated_requestHeadersToRemove_codec);
      typedPerFilterConfig_.WriteTo(output, _map_typedPerFilterConfig_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(Name);
      }
      if (tracing_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Tracing);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (match_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Match);
      }
      if (actionCase_ == ActionOneofCase.Route_) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Route_);
      }
      if (actionCase_ == ActionOneofCase.Redirect) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Redirect);
      }
      if (actionCase_ == ActionOneofCase.DirectResponse) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DirectResponse);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (decorator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Decorator);
      }
      size += perFilterConfig_.CalculateSize(_map_perFilterConfig_codec);
      size += typedPerFilterConfig_.CalculateSize(_map_typedPerFilterConfig_codec);
      size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
      size += requestHeadersToRemove_.CalculateSize(_repeated_requestHeadersToRemove_codec);
      size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
      size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
      if (tracing_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tracing);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Route other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.match_ != null) {
        if (match_ == null) {
          Match = new global::Envoy.Api.V2.Route.RouteMatch();
        }
        Match.MergeFrom(other.Match);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.decorator_ != null) {
        if (decorator_ == null) {
          Decorator = new global::Envoy.Api.V2.Route.Decorator();
        }
        Decorator.MergeFrom(other.Decorator);
      }
      perFilterConfig_.Add(other.perFilterConfig_);
      typedPerFilterConfig_.Add(other.typedPerFilterConfig_);
      requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
      requestHeadersToRemove_.Add(other.requestHeadersToRemove_);
      responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
      responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
      if (other.tracing_ != null) {
        if (tracing_ == null) {
          Tracing = new global::Envoy.Api.V2.Route.Tracing();
        }
        Tracing.MergeFrom(other.Tracing);
      }
      switch (other.ActionCase) {
        case ActionOneofCase.Route_:
          if (Route_ == null) {
            Route_ = new global::Envoy.Api.V2.Route.RouteAction();
          }
          Route_.MergeFrom(other.Route_);
          break;
        case ActionOneofCase.Redirect:
          if (Redirect == null) {
            Redirect = new global::Envoy.Api.V2.Route.RedirectAction();
          }
          Redirect.MergeFrom(other.Redirect);
          break;
        case ActionOneofCase.DirectResponse:
          if (DirectResponse == null) {
            DirectResponse = new global::Envoy.Api.V2.Route.DirectResponseAction();
          }
          DirectResponse.MergeFrom(other.DirectResponse);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (match_ == null) {
              Match = new global::Envoy.Api.V2.Route.RouteMatch();
            }
            input.ReadMessage(Match);
            break;
          }
          case 18: {
            global::Envoy.Api.V2.Route.RouteAction subBuilder = new global::Envoy.Api.V2.Route.RouteAction();
            if (actionCase_ == ActionOneofCase.Route_) {
              subBuilder.MergeFrom(Route_);
            }
            input.ReadMessage(subBuilder);
            Route_ = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Api.V2.Route.RedirectAction subBuilder = new global::Envoy.Api.V2.Route.RedirectAction();
            if (actionCase_ == ActionOneofCase.Redirect) {
              subBuilder.MergeFrom(Redirect);
            }
            input.ReadMessage(subBuilder);
            Redirect = subBuilder;
            break;
          }
          case 34: {
            if (metadata_ == null) {
              Metadata = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 42: {
            if (decorator_ == null) {
              Decorator = new global::Envoy.Api.V2.Route.Decorator();
            }
            input.ReadMessage(Decorator);
            break;
          }
          case 58: {
            global::Envoy.Api.V2.Route.DirectResponseAction subBuilder = new global::Envoy.Api.V2.Route.DirectResponseAction();
            if (actionCase_ == ActionOneofCase.DirectResponse) {
              subBuilder.MergeFrom(DirectResponse);
            }
            input.ReadMessage(subBuilder);
            DirectResponse = subBuilder;
            break;
          }
          case 66: {
            perFilterConfig_.AddEntriesFrom(input, _map_perFilterConfig_codec);
            break;
          }
          case 74: {
            requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
            break;
          }
          case 82: {
            responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
            break;
          }
          case 90: {
            responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
            break;
          }
          case 98: {
            requestHeadersToRemove_.AddEntriesFrom(input, _repeated_requestHeadersToRemove_codec);
            break;
          }
          case 106: {
            typedPerFilterConfig_.AddEntriesFrom(input, _map_typedPerFilterConfig_codec);
            break;
          }
          case 114: {
            Name = input.ReadString();
            break;
          }
          case 122: {
            if (tracing_ == null) {
              Tracing = new global::Envoy.Api.V2.Route.Tracing();
            }
            input.ReadMessage(Tracing);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Compared to the :ref:`cluster &lt;envoy_api_field_route.RouteAction.cluster>` field that specifies a
  /// single upstream cluster as the target of a request, the :ref:`weighted_clusters
  /// &lt;envoy_api_field_route.RouteAction.weighted_clusters>` option allows for specification of
  /// multiple upstream clusters along with weights that indicate the percentage of
  /// traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
  /// weights.
  /// [#comment:next free field: 11]
  /// </summary>
  public sealed partial class WeightedCluster : pb::IMessage<WeightedCluster> {
    private static readonly pb::MessageParser<WeightedCluster> _parser = new pb::MessageParser<WeightedCluster>(() => new WeightedCluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightedCluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedCluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedCluster(WeightedCluster other) : this() {
      clusters_ = other.clusters_.Clone();
      TotalWeight = other.TotalWeight;
      runtimeKeyPrefix_ = other.runtimeKeyPrefix_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedCluster Clone() {
      return new WeightedCluster(this);
    }

    /// <summary>Field number for the "clusters" field.</summary>
    public const int ClustersFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight> _repeated_clusters_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight> clusters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight>();
    /// <summary>
    /// Specifies one or more upstream clusters associated with the route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.WeightedCluster.Types.ClusterWeight> Clusters {
      get { return clusters_; }
    }

    /// <summary>Field number for the "total_weight" field.</summary>
    public const int TotalWeightFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_totalWeight_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? totalWeight_;
    /// <summary>
    /// Specifies the total weight across all clusters. The sum of all cluster weights must equal this
    /// value, which must be greater than 0. Defaults to 100.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? TotalWeight {
      get { return totalWeight_; }
      set {
        totalWeight_ = value;
      }
    }


    /// <summary>Field number for the "runtime_key_prefix" field.</summary>
    public const int RuntimeKeyPrefixFieldNumber = 2;
    private string runtimeKeyPrefix_ = "";
    /// <summary>
    /// Specifies the runtime key prefix that should be used to construct the
    /// runtime keys associated with each cluster. When the *runtime_key_prefix* is
    /// specified, the router will look for weights associated with each upstream
    /// cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
    /// *cluster[i]* denotes an entry in the clusters array field. If the runtime
    /// key for the cluster does not exist, the value specified in the
    /// configuration file will be used as the default weight. See the :ref:`runtime documentation
    /// &lt;operations_runtime>` for how key names map to the underlying implementation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RuntimeKeyPrefix {
      get { return runtimeKeyPrefix_; }
      set {
        runtimeKeyPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightedCluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightedCluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!clusters_.Equals(other.clusters_)) return false;
      if (TotalWeight != other.TotalWeight) return false;
      if (RuntimeKeyPrefix != other.RuntimeKeyPrefix) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= clusters_.GetHashCode();
      if (totalWeight_ != null) hash ^= TotalWeight.GetHashCode();
      if (RuntimeKeyPrefix.Length != 0) hash ^= RuntimeKeyPrefix.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      clusters_.WriteTo(output, _repeated_clusters_codec);
      if (RuntimeKeyPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RuntimeKeyPrefix);
      }
      if (totalWeight_ != null) {
        _single_totalWeight_codec.WriteTagAndValue(output, TotalWeight);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += clusters_.CalculateSize(_repeated_clusters_codec);
      if (totalWeight_ != null) {
        size += _single_totalWeight_codec.CalculateSizeWithTag(TotalWeight);
      }
      if (RuntimeKeyPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RuntimeKeyPrefix);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightedCluster other) {
      if (other == null) {
        return;
      }
      clusters_.Add(other.clusters_);
      if (other.totalWeight_ != null) {
        if (totalWeight_ == null || other.TotalWeight != 0) {
          TotalWeight = other.TotalWeight;
        }
      }
      if (other.RuntimeKeyPrefix.Length != 0) {
        RuntimeKeyPrefix = other.RuntimeKeyPrefix;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            clusters_.AddEntriesFrom(input, _repeated_clusters_codec);
            break;
          }
          case 18: {
            RuntimeKeyPrefix = input.ReadString();
            break;
          }
          case 26: {
            uint? value = _single_totalWeight_codec.Read(input);
            if (totalWeight_ == null || value != 0) {
              TotalWeight = value;
            }
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the WeightedCluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class ClusterWeight : pb::IMessage<ClusterWeight> {
        private static readonly pb::MessageParser<ClusterWeight> _parser = new pb::MessageParser<ClusterWeight>(() => new ClusterWeight());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ClusterWeight> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.WeightedCluster.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ClusterWeight() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ClusterWeight(ClusterWeight other) : this() {
          name_ = other.name_;
          Weight = other.Weight;
          metadataMatch_ = other.metadataMatch_ != null ? other.metadataMatch_.Clone() : null;
          requestHeadersToAdd_ = other.requestHeadersToAdd_.Clone();
          requestHeadersToRemove_ = other.requestHeadersToRemove_.Clone();
          responseHeadersToAdd_ = other.responseHeadersToAdd_.Clone();
          responseHeadersToRemove_ = other.responseHeadersToRemove_.Clone();
          perFilterConfig_ = other.perFilterConfig_.Clone();
          typedPerFilterConfig_ = other.typedPerFilterConfig_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ClusterWeight Clone() {
          return new ClusterWeight(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// Name of the upstream cluster. The cluster must exist in the
        /// :ref:`cluster manager configuration &lt;config_cluster_manager>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "weight" field.</summary>
        public const int WeightFieldNumber = 2;
        private static readonly pb::FieldCodec<uint?> _single_weight_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
        private uint? weight_;
        /// <summary>
        /// An integer between 0 and :ref:`total_weight
        /// &lt;envoy_api_field_route.WeightedCluster.total_weight>`. When a request matches the route,
        /// the choice of an upstream cluster is determined by its weight. The sum of weights across all
        /// entries in the clusters array must add up to the total_weight, which defaults to 100.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint? Weight {
          get { return weight_; }
          set {
            weight_ = value;
          }
        }


        /// <summary>Field number for the "metadata_match" field.</summary>
        public const int MetadataMatchFieldNumber = 3;
        private global::Envoy.Api.V2.Core.Metadata metadataMatch_;
        /// <summary>
        /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
        /// the upstream cluster with metadata matching what is set in this field will be considered for
        /// load balancing. Note that this will be merged with what's provided in :ref:
        /// `RouteAction.MetadataMatch &lt;envoy_api_field_route.RouteAction.metadata_match>`, with values
        /// here taking precedence. The filter name should be specified as *envoy.lb*.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.Metadata MetadataMatch {
          get { return metadataMatch_; }
          set {
            metadataMatch_ = value;
          }
        }

        /// <summary>Field number for the "request_headers_to_add" field.</summary>
        public const int RequestHeadersToAddFieldNumber = 4;
        private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_requestHeadersToAdd_codec
            = pb::FieldCodec.ForMessage(34, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> requestHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
        /// <summary>
        /// Specifies a list of headers to be added to requests when this cluster is selected
        /// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
        /// Headers specified at this level are applied before headers from the enclosing
        /// :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
        /// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
        /// header value syntax, see the documentation on :ref:`custom request headers
        /// &lt;config_http_conn_man_headers_custom_request_headers>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> RequestHeadersToAdd {
          get { return requestHeadersToAdd_; }
        }

        /// <summary>Field number for the "request_headers_to_remove" field.</summary>
        public const int RequestHeadersToRemoveFieldNumber = 9;
        private static readonly pb::FieldCodec<string> _repeated_requestHeadersToRemove_codec
            = pb::FieldCodec.ForString(74);
        private readonly pbc::RepeatedField<string> requestHeadersToRemove_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Specifies a list of HTTP headers that should be removed from each request when
        /// this cluster is selected through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> RequestHeadersToRemove {
          get { return requestHeadersToRemove_; }
        }

        /// <summary>Field number for the "response_headers_to_add" field.</summary>
        public const int ResponseHeadersToAddFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HeaderValueOption> _repeated_responseHeadersToAdd_codec
            = pb::FieldCodec.ForMessage(42, global::Envoy.Api.V2.Core.HeaderValueOption.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> responseHeadersToAdd_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption>();
        /// <summary>
        /// Specifies a list of headers to be added to responses when this cluster is selected
        /// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
        /// Headers specified at this level are applied before headers from the enclosing
        /// :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_route.VirtualHost`, and
        /// :ref:`envoy_api_msg_RouteConfiguration`. For more information, including details on
        /// header value syntax, see the documentation on :ref:`custom request headers
        /// &lt;config_http_conn_man_headers_custom_request_headers>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Api.V2.Core.HeaderValueOption> ResponseHeadersToAdd {
          get { return responseHeadersToAdd_; }
        }

        /// <summary>Field number for the "response_headers_to_remove" field.</summary>
        public const int ResponseHeadersToRemoveFieldNumber = 6;
        private static readonly pb::FieldCodec<string> _repeated_responseHeadersToRemove_codec
            = pb::FieldCodec.ForString(50);
        private readonly pbc::RepeatedField<string> responseHeadersToRemove_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// Specifies a list of headers to be removed from responses when this cluster is selected
        /// through the enclosing :ref:`envoy_api_msg_route.RouteAction`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> ResponseHeadersToRemove {
          get { return responseHeadersToRemove_; }
        }

        /// <summary>Field number for the "per_filter_config" field.</summary>
        public const int PerFilterConfigFieldNumber = 8;
        private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec _map_perFilterConfig_codec
            = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Struct.Parser), 66);
        private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> perFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct>();
        /// <summary>
        /// The per_filter_config field can be used to provide weighted cluster-specific
        /// configurations for filters. The key should match the filter name, such as
        /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
        /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>`
        /// for if and how it is utilized.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Struct> PerFilterConfig {
          get { return perFilterConfig_; }
        }

        /// <summary>Field number for the "typed_per_filter_config" field.</summary>
        public const int TypedPerFilterConfigFieldNumber = 10;
        private static readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec _map_typedPerFilterConfig_codec
            = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Google.Protobuf.WellKnownTypes.Any.Parser), 82);
        private readonly pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> typedPerFilterConfig_ = new pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any>();
        /// <summary>
        /// The per_filter_config field can be used to provide weighted cluster-specific
        /// configurations for filters. The key should match the filter name, such as
        /// *envoy.buffer* for the HTTP buffer filter. Use of this field is filter
        /// specific; see the :ref:`HTTP filter documentation &lt;config_http_filters>`
        /// for if and how it is utilized.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, global::Google.Protobuf.WellKnownTypes.Any> TypedPerFilterConfig {
          get { return typedPerFilterConfig_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ClusterWeight);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ClusterWeight other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Weight != other.Weight) return false;
          if (!object.Equals(MetadataMatch, other.MetadataMatch)) return false;
          if(!requestHeadersToAdd_.Equals(other.requestHeadersToAdd_)) return false;
          if(!requestHeadersToRemove_.Equals(other.requestHeadersToRemove_)) return false;
          if(!responseHeadersToAdd_.Equals(other.responseHeadersToAdd_)) return false;
          if(!responseHeadersToRemove_.Equals(other.responseHeadersToRemove_)) return false;
          if (!PerFilterConfig.Equals(other.PerFilterConfig)) return false;
          if (!TypedPerFilterConfig.Equals(other.TypedPerFilterConfig)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (weight_ != null) hash ^= Weight.GetHashCode();
          if (metadataMatch_ != null) hash ^= MetadataMatch.GetHashCode();
          hash ^= requestHeadersToAdd_.GetHashCode();
          hash ^= requestHeadersToRemove_.GetHashCode();
          hash ^= responseHeadersToAdd_.GetHashCode();
          hash ^= responseHeadersToRemove_.GetHashCode();
          hash ^= PerFilterConfig.GetHashCode();
          hash ^= TypedPerFilterConfig.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (weight_ != null) {
            _single_weight_codec.WriteTagAndValue(output, Weight);
          }
          if (metadataMatch_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(MetadataMatch);
          }
          requestHeadersToAdd_.WriteTo(output, _repeated_requestHeadersToAdd_codec);
          responseHeadersToAdd_.WriteTo(output, _repeated_responseHeadersToAdd_codec);
          responseHeadersToRemove_.WriteTo(output, _repeated_responseHeadersToRemove_codec);
          perFilterConfig_.WriteTo(output, _map_perFilterConfig_codec);
          requestHeadersToRemove_.WriteTo(output, _repeated_requestHeadersToRemove_codec);
          typedPerFilterConfig_.WriteTo(output, _map_typedPerFilterConfig_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (weight_ != null) {
            size += _single_weight_codec.CalculateSizeWithTag(Weight);
          }
          if (metadataMatch_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataMatch);
          }
          size += requestHeadersToAdd_.CalculateSize(_repeated_requestHeadersToAdd_codec);
          size += requestHeadersToRemove_.CalculateSize(_repeated_requestHeadersToRemove_codec);
          size += responseHeadersToAdd_.CalculateSize(_repeated_responseHeadersToAdd_codec);
          size += responseHeadersToRemove_.CalculateSize(_repeated_responseHeadersToRemove_codec);
          size += perFilterConfig_.CalculateSize(_map_perFilterConfig_codec);
          size += typedPerFilterConfig_.CalculateSize(_map_typedPerFilterConfig_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ClusterWeight other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.weight_ != null) {
            if (weight_ == null || other.Weight != 0) {
              Weight = other.Weight;
            }
          }
          if (other.metadataMatch_ != null) {
            if (metadataMatch_ == null) {
              MetadataMatch = new global::Envoy.Api.V2.Core.Metadata();
            }
            MetadataMatch.MergeFrom(other.MetadataMatch);
          }
          requestHeadersToAdd_.Add(other.requestHeadersToAdd_);
          requestHeadersToRemove_.Add(other.requestHeadersToRemove_);
          responseHeadersToAdd_.Add(other.responseHeadersToAdd_);
          responseHeadersToRemove_.Add(other.responseHeadersToRemove_);
          perFilterConfig_.Add(other.perFilterConfig_);
          typedPerFilterConfig_.Add(other.typedPerFilterConfig_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                uint? value = _single_weight_codec.Read(input);
                if (weight_ == null || value != 0) {
                  Weight = value;
                }
                break;
              }
              case 26: {
                if (metadataMatch_ == null) {
                  MetadataMatch = new global::Envoy.Api.V2.Core.Metadata();
                }
                input.ReadMessage(MetadataMatch);
                break;
              }
              case 34: {
                requestHeadersToAdd_.AddEntriesFrom(input, _repeated_requestHeadersToAdd_codec);
                break;
              }
              case 42: {
                responseHeadersToAdd_.AddEntriesFrom(input, _repeated_responseHeadersToAdd_codec);
                break;
              }
              case 50: {
                responseHeadersToRemove_.AddEntriesFrom(input, _repeated_responseHeadersToRemove_codec);
                break;
              }
              case 66: {
                perFilterConfig_.AddEntriesFrom(input, _map_perFilterConfig_codec);
                break;
              }
              case 74: {
                requestHeadersToRemove_.AddEntriesFrom(input, _repeated_requestHeadersToRemove_codec);
                break;
              }
              case 82: {
                typedPerFilterConfig_.AddEntriesFrom(input, _map_typedPerFilterConfig_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class RouteMatch : pb::IMessage<RouteMatch> {
    private static readonly pb::MessageParser<RouteMatch> _parser = new pb::MessageParser<RouteMatch>(() => new RouteMatch());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RouteMatch> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteMatch() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteMatch(RouteMatch other) : this() {
      CaseSensitive = other.CaseSensitive;
      runtimeFraction_ = other.runtimeFraction_ != null ? other.runtimeFraction_.Clone() : null;
      headers_ = other.headers_.Clone();
      queryParameters_ = other.queryParameters_.Clone();
      grpc_ = other.grpc_ != null ? other.grpc_.Clone() : null;
      switch (other.PathSpecifierCase) {
        case PathSpecifierOneofCase.Prefix:
          Prefix = other.Prefix;
          break;
        case PathSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case PathSpecifierOneofCase.Regex:
          Regex = other.Regex;
          break;
        case PathSpecifierOneofCase.SafeRegex:
          SafeRegex = other.SafeRegex.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteMatch Clone() {
      return new RouteMatch(this);
    }

    /// <summary>Field number for the "prefix" field.</summary>
    public const int PrefixFieldNumber = 1;
    /// <summary>
    /// If specified, the route is a prefix rule meaning that the prefix must
    /// match the beginning of the *:path* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Prefix {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.Prefix ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.Prefix;
      }
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    /// <summary>
    /// If specified, the route is an exact path rule meaning that the path must
    /// exactly match the *:path* header once the query string is removed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Path {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.Path ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.Path;
      }
    }

    /// <summary>Field number for the "regex" field.</summary>
    public const int RegexFieldNumber = 3;
    /// <summary>
    /// If specified, the route is a regular expression rule meaning that the
    /// regex must match the *:path* header once the query string is removed. The entire path
    /// (without the query string) must match the regex. The rule will not match if only a
    /// subsequence of the *:path* header matches the regex. The regex grammar is defined `here
    /// &lt;https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
    ///
    /// Examples:
    ///
    /// * The regex */b[io]t* matches the path */bit*
    /// * The regex */b[io]t* matches the path */bot*
    /// * The regex */b[io]t* does not match the path */bite*
    /// * The regex */b[io]t* does not match the path */bit/bot*
    ///
    /// .. attention::
    ///   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
    ///   untrusted input in all cases.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Regex {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.Regex ? (string) pathSpecifier_ : ""; }
      set {
        pathSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathSpecifierCase_ = PathSpecifierOneofCase.Regex;
      }
    }

    /// <summary>Field number for the "safe_regex" field.</summary>
    public const int SafeRegexFieldNumber = 10;
    /// <summary>
    /// If specified, the route is a regular expression rule meaning that the
    /// regex must match the *:path* header once the query string is removed. The entire path
    /// (without the query string) must match the regex. The rule will not match if only a
    /// subsequence of the *:path* header matches the regex.
    ///
    /// [#next-major-version: In the v3 API we should redo how path specification works such
    /// that we utilize StringMatcher, and additionally have consistent options around whether we
    /// strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
    /// to deprecate the existing options. We should even consider whether we want to do away with
    /// path_specifier entirely and just rely on a set of header matchers which can already match
    /// on :path, etc. The issue with that is it is unclear how to generically deal with query string
    /// stripping. This needs more thought.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.RegexMatcher SafeRegex {
      get { return pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex ? (global::Envoy.Type.Matcher.RegexMatcher) pathSpecifier_ : null; }
      set {
        pathSpecifier_ = value;
        pathSpecifierCase_ = value == null ? PathSpecifierOneofCase.None : PathSpecifierOneofCase.SafeRegex;
      }
    }

    /// <summary>Field number for the "case_sensitive" field.</summary>
    public const int CaseSensitiveFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_caseSensitive_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? caseSensitive_;
    /// <summary>
    /// Indicates that prefix/path matching should be case insensitive. The default
    /// is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? CaseSensitive {
      get { return caseSensitive_; }
      set {
        caseSensitive_ = value;
      }
    }


    /// <summary>Field number for the "runtime_fraction" field.</summary>
    public const int RuntimeFractionFieldNumber = 9;
    private global::Envoy.Api.V2.Core.RuntimeFractionalPercent runtimeFraction_;
    /// <summary>
    /// Indicates that the route should additionally match on a runtime key. Every time the route
    /// is considered for a match, it must also fall under the percentage of matches indicated by
    /// this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
    /// number is &lt;= the value of the numerator N, or if the key is not present, the default
    /// value, the router continues to evaluate the remaining match criteria. A runtime_fraction
    /// route configuration can be used to roll out route changes in a gradual manner without full
    /// code/config deploys. Refer to the :ref:`traffic shifting
    /// &lt;config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
    ///
    /// .. note::
    ///
    ///    Parsing this field is implemented such that the runtime key's data may be represented
    ///    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
    ///    integer with the assumption that the value is an integral percentage out of 100. For
    ///    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
    ///    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RuntimeFractionalPercent RuntimeFraction {
      get { return runtimeFraction_; }
      set {
        runtimeFraction_ = value;
      }
    }

    /// <summary>Field number for the "headers" field.</summary>
    public const int HeadersFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.HeaderMatcher> _repeated_headers_codec
        = pb::FieldCodec.ForMessage(50, global::Envoy.Api.V2.Route.HeaderMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> headers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher>();
    /// <summary>
    /// Specifies a set of headers that the route should match on. The router will
    /// check the request’s headers against all the specified headers in the route
    /// config. A match will happen if all the headers in the route are present in
    /// the request with the same values (or based on presence if the value field
    /// is not in the config).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> Headers {
      get { return headers_; }
    }

    /// <summary>Field number for the "query_parameters" field.</summary>
    public const int QueryParametersFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.QueryParameterMatcher> _repeated_queryParameters_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Api.V2.Route.QueryParameterMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.QueryParameterMatcher> queryParameters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.QueryParameterMatcher>();
    /// <summary>
    /// Specifies a set of URL query parameters on which the route should
    /// match. The router will check the query string from the *path* header
    /// against all the specified query parameters. If the number of specified
    /// query parameters is nonzero, they all must match the *path* header's
    /// query string for a match to occur.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.QueryParameterMatcher> QueryParameters {
      get { return queryParameters_; }
    }

    /// <summary>Field number for the "grpc" field.</summary>
    public const int GrpcFieldNumber = 8;
    private global::Envoy.Api.V2.Route.RouteMatch.Types.GrpcRouteMatchOptions grpc_;
    /// <summary>
    /// If specified, only gRPC requests will be matched. The router will check
    /// that the content-type header has a application/grpc or one of the various
    /// application/grpc+ values.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteMatch.Types.GrpcRouteMatchOptions Grpc {
      get { return grpc_; }
      set {
        grpc_ = value;
      }
    }

    private object pathSpecifier_;
    /// <summary>Enum of possible cases for the "path_specifier" oneof.</summary>
    public enum PathSpecifierOneofCase {
      None = 0,
      Prefix = 1,
      Path = 2,
      Regex = 3,
      SafeRegex = 10,
    }
    private PathSpecifierOneofCase pathSpecifierCase_ = PathSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PathSpecifierOneofCase PathSpecifierCase {
      get { return pathSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPathSpecifier() {
      pathSpecifierCase_ = PathSpecifierOneofCase.None;
      pathSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RouteMatch);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RouteMatch other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Prefix != other.Prefix) return false;
      if (Path != other.Path) return false;
      if (Regex != other.Regex) return false;
      if (!object.Equals(SafeRegex, other.SafeRegex)) return false;
      if (CaseSensitive != other.CaseSensitive) return false;
      if (!object.Equals(RuntimeFraction, other.RuntimeFraction)) return false;
      if(!headers_.Equals(other.headers_)) return false;
      if(!queryParameters_.Equals(other.queryParameters_)) return false;
      if (!object.Equals(Grpc, other.Grpc)) return false;
      if (PathSpecifierCase != other.PathSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) hash ^= Prefix.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) hash ^= Path.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Regex) hash ^= Regex.GetHashCode();
      if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) hash ^= SafeRegex.GetHashCode();
      if (caseSensitive_ != null) hash ^= CaseSensitive.GetHashCode();
      if (runtimeFraction_ != null) hash ^= RuntimeFraction.GetHashCode();
      hash ^= headers_.GetHashCode();
      hash ^= queryParameters_.GetHashCode();
      if (grpc_ != null) hash ^= Grpc.GetHashCode();
      hash ^= (int) pathSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) {
        output.WriteRawTag(10);
        output.WriteString(Prefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Regex) {
        output.WriteRawTag(26);
        output.WriteString(Regex);
      }
      if (caseSensitive_ != null) {
        _single_caseSensitive_codec.WriteTagAndValue(output, CaseSensitive);
      }
      headers_.WriteTo(output, _repeated_headers_codec);
      queryParameters_.WriteTo(output, _repeated_queryParameters_codec);
      if (grpc_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Grpc);
      }
      if (runtimeFraction_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(RuntimeFraction);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) {
        output.WriteRawTag(82);
        output.WriteMessage(SafeRegex);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Prefix) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Prefix);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Path) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.Regex) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Regex);
      }
      if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SafeRegex);
      }
      if (caseSensitive_ != null) {
        size += _single_caseSensitive_codec.CalculateSizeWithTag(CaseSensitive);
      }
      if (runtimeFraction_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RuntimeFraction);
      }
      size += headers_.CalculateSize(_repeated_headers_codec);
      size += queryParameters_.CalculateSize(_repeated_queryParameters_codec);
      if (grpc_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Grpc);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RouteMatch other) {
      if (other == null) {
        return;
      }
      if (other.caseSensitive_ != null) {
        if (caseSensitive_ == null || other.CaseSensitive != false) {
          CaseSensitive = other.CaseSensitive;
        }
      }
      if (other.runtimeFraction_ != null) {
        if (runtimeFraction_ == null) {
          RuntimeFraction = new global::Envoy.Api.V2.Core.RuntimeFractionalPercent();
        }
        RuntimeFraction.MergeFrom(other.RuntimeFraction);
      }
      headers_.Add(other.headers_);
      queryParameters_.Add(other.queryParameters_);
      if (other.grpc_ != null) {
        if (grpc_ == null) {
          Grpc = new global::Envoy.Api.V2.Route.RouteMatch.Types.GrpcRouteMatchOptions();
        }
        Grpc.MergeFrom(other.Grpc);
      }
      switch (other.PathSpecifierCase) {
        case PathSpecifierOneofCase.Prefix:
          Prefix = other.Prefix;
          break;
        case PathSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case PathSpecifierOneofCase.Regex:
          Regex = other.Regex;
          break;
        case PathSpecifierOneofCase.SafeRegex:
          if (SafeRegex == null) {
            SafeRegex = new global::Envoy.Type.Matcher.RegexMatcher();
          }
          SafeRegex.MergeFrom(other.SafeRegex);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Prefix = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 26: {
            Regex = input.ReadString();
            break;
          }
          case 34: {
            bool? value = _single_caseSensitive_codec.Read(input);
            if (caseSensitive_ == null || value != false) {
              CaseSensitive = value;
            }
            break;
          }
          case 50: {
            headers_.AddEntriesFrom(input, _repeated_headers_codec);
            break;
          }
          case 58: {
            queryParameters_.AddEntriesFrom(input, _repeated_queryParameters_codec);
            break;
          }
          case 66: {
            if (grpc_ == null) {
              Grpc = new global::Envoy.Api.V2.Route.RouteMatch.Types.GrpcRouteMatchOptions();
            }
            input.ReadMessage(Grpc);
            break;
          }
          case 74: {
            if (runtimeFraction_ == null) {
              RuntimeFraction = new global::Envoy.Api.V2.Core.RuntimeFractionalPercent();
            }
            input.ReadMessage(RuntimeFraction);
            break;
          }
          case 82: {
            global::Envoy.Type.Matcher.RegexMatcher subBuilder = new global::Envoy.Type.Matcher.RegexMatcher();
            if (pathSpecifierCase_ == PathSpecifierOneofCase.SafeRegex) {
              subBuilder.MergeFrom(SafeRegex);
            }
            input.ReadMessage(subBuilder);
            SafeRegex = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RouteMatch message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class GrpcRouteMatchOptions : pb::IMessage<GrpcRouteMatchOptions> {
        private static readonly pb::MessageParser<GrpcRouteMatchOptions> _parser = new pb::MessageParser<GrpcRouteMatchOptions>(() => new GrpcRouteMatchOptions());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<GrpcRouteMatchOptions> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RouteMatch.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GrpcRouteMatchOptions() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GrpcRouteMatchOptions(GrpcRouteMatchOptions other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public GrpcRouteMatchOptions Clone() {
          return new GrpcRouteMatchOptions(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as GrpcRouteMatchOptions);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(GrpcRouteMatchOptions other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(GrpcRouteMatchOptions other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// [#comment:next free field: 11]
  /// </summary>
  public sealed partial class CorsPolicy : pb::IMessage<CorsPolicy> {
    private static readonly pb::MessageParser<CorsPolicy> _parser = new pb::MessageParser<CorsPolicy>(() => new CorsPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CorsPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorsPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorsPolicy(CorsPolicy other) : this() {
      allowOrigin_ = other.allowOrigin_.Clone();
      allowOriginRegex_ = other.allowOriginRegex_.Clone();
      allowOriginStringMatch_ = other.allowOriginStringMatch_.Clone();
      allowMethods_ = other.allowMethods_;
      allowHeaders_ = other.allowHeaders_;
      exposeHeaders_ = other.exposeHeaders_;
      maxAge_ = other.maxAge_;
      AllowCredentials = other.AllowCredentials;
      shadowEnabled_ = other.shadowEnabled_ != null ? other.shadowEnabled_.Clone() : null;
      switch (other.EnabledSpecifierCase) {
        case EnabledSpecifierOneofCase.Enabled:
          Enabled = other.Enabled;
          break;
        case EnabledSpecifierOneofCase.FilterEnabled:
          FilterEnabled = other.FilterEnabled.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CorsPolicy Clone() {
      return new CorsPolicy(this);
    }

    /// <summary>Field number for the "allow_origin" field.</summary>
    public const int AllowOriginFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_allowOrigin_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> allowOrigin_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies the origins that will be allowed to do CORS requests.
    ///
    /// An origin is allowed if either allow_origin or allow_origin_regex match.
    ///
    /// .. attention::
    ///  This field has been deprecated in favor of `allow_origin_string_match`.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AllowOrigin {
      get { return allowOrigin_; }
    }

    /// <summary>Field number for the "allow_origin_regex" field.</summary>
    public const int AllowOriginRegexFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_allowOriginRegex_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> allowOriginRegex_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specifies regex patterns that match allowed origins.
    ///
    /// An origin is allowed if either allow_origin or allow_origin_regex match.
    ///
    /// .. attention::
    ///   This field has been deprecated in favor of `allow_origin_string_match` as it is not safe for
    ///   use with untrusted input in all cases.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> AllowOriginRegex {
      get { return allowOriginRegex_; }
    }

    /// <summary>Field number for the "allow_origin_string_match" field.</summary>
    public const int AllowOriginStringMatchFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Envoy.Type.Matcher.StringMatcher> _repeated_allowOriginStringMatch_codec
        = pb::FieldCodec.ForMessage(90, global::Envoy.Type.Matcher.StringMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Type.Matcher.StringMatcher> allowOriginStringMatch_ = new pbc::RepeatedField<global::Envoy.Type.Matcher.StringMatcher>();
    /// <summary>
    /// Specifies string patterns that match allowed origins. An origin is allowed if any of the
    /// string matchers match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Type.Matcher.StringMatcher> AllowOriginStringMatch {
      get { return allowOriginStringMatch_; }
    }

    /// <summary>Field number for the "allow_methods" field.</summary>
    public const int AllowMethodsFieldNumber = 2;
    private string allowMethods_ = "";
    /// <summary>
    /// Specifies the content for the *access-control-allow-methods* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AllowMethods {
      get { return allowMethods_; }
      set {
        allowMethods_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_headers" field.</summary>
    public const int AllowHeadersFieldNumber = 3;
    private string allowHeaders_ = "";
    /// <summary>
    /// Specifies the content for the *access-control-allow-headers* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AllowHeaders {
      get { return allowHeaders_; }
      set {
        allowHeaders_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "expose_headers" field.</summary>
    public const int ExposeHeadersFieldNumber = 4;
    private string exposeHeaders_ = "";
    /// <summary>
    /// Specifies the content for the *access-control-expose-headers* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExposeHeaders {
      get { return exposeHeaders_; }
      set {
        exposeHeaders_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_age" field.</summary>
    public const int MaxAgeFieldNumber = 5;
    private string maxAge_ = "";
    /// <summary>
    /// Specifies the content for the *access-control-max-age* header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MaxAge {
      get { return maxAge_; }
      set {
        maxAge_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "allow_credentials" field.</summary>
    public const int AllowCredentialsFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_allowCredentials_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? allowCredentials_;
    /// <summary>
    /// Specifies whether the resource allows credentials.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? AllowCredentials {
      get { return allowCredentials_; }
      set {
        allowCredentials_ = value;
      }
    }


    /// <summary>Field number for the "enabled" field.</summary>
    public const int EnabledFieldNumber = 7;
    private static readonly pb::FieldCodec<bool?> _oneof_enabled_codec = pb::FieldCodec.ForStructWrapper<bool>(58);
    /// <summary>
    /// Specifies if CORS is enabled. Defaults to true. Only effective on route.
    ///
    /// .. attention::
    ///
    ///   **This field is deprecated**. Set the
    ///   :ref:`filter_enabled&lt;envoy_api_field_route.CorsPolicy.filter_enabled>` field instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Enabled {
      get { return enabledSpecifierCase_ == EnabledSpecifierOneofCase.Enabled ? (bool?) enabledSpecifier_ : (bool?) null; }
      set {
        enabledSpecifier_ = value;
        enabledSpecifierCase_ = value == null ? EnabledSpecifierOneofCase.None : EnabledSpecifierOneofCase.Enabled;
      }
    }

    /// <summary>Field number for the "filter_enabled" field.</summary>
    public const int FilterEnabledFieldNumber = 9;
    /// <summary>
    /// Specifies if CORS is enabled.
    ///
    /// More information on how this can be controlled via runtime can be found
    /// :ref:`here &lt;cors-runtime>`.
    ///
    /// .. note::
    ///
    ///   This field defaults to 100/:ref:`HUNDRED
    ///   &lt;envoy_api_enum_type.FractionalPercent.DenominatorType>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RuntimeFractionalPercent FilterEnabled {
      get { return enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled ? (global::Envoy.Api.V2.Core.RuntimeFractionalPercent) enabledSpecifier_ : null; }
      set {
        enabledSpecifier_ = value;
        enabledSpecifierCase_ = value == null ? EnabledSpecifierOneofCase.None : EnabledSpecifierOneofCase.FilterEnabled;
      }
    }

    /// <summary>Field number for the "shadow_enabled" field.</summary>
    public const int ShadowEnabledFieldNumber = 10;
    private global::Envoy.Api.V2.Core.RuntimeFractionalPercent shadowEnabled_;
    /// <summary>
    /// Specifies if CORS policies are evaluated and tracked when filter is off but
    /// does not enforce any policies.
    ///
    /// More information on how this can be controlled via runtime can be found
    /// :ref:`here &lt;cors-runtime>`.
    ///
    /// .. note::
    ///
    ///   This field defaults to 100/:ref:`HUNDRED
    ///   &lt;envoy_api_enum_type.FractionalPercent.DenominatorType>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RuntimeFractionalPercent ShadowEnabled {
      get { return shadowEnabled_; }
      set {
        shadowEnabled_ = value;
      }
    }

    private object enabledSpecifier_;
    /// <summary>Enum of possible cases for the "enabled_specifier" oneof.</summary>
    public enum EnabledSpecifierOneofCase {
      None = 0,
      Enabled = 7,
      FilterEnabled = 9,
    }
    private EnabledSpecifierOneofCase enabledSpecifierCase_ = EnabledSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EnabledSpecifierOneofCase EnabledSpecifierCase {
      get { return enabledSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearEnabledSpecifier() {
      enabledSpecifierCase_ = EnabledSpecifierOneofCase.None;
      enabledSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CorsPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CorsPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!allowOrigin_.Equals(other.allowOrigin_)) return false;
      if(!allowOriginRegex_.Equals(other.allowOriginRegex_)) return false;
      if(!allowOriginStringMatch_.Equals(other.allowOriginStringMatch_)) return false;
      if (AllowMethods != other.AllowMethods) return false;
      if (AllowHeaders != other.AllowHeaders) return false;
      if (ExposeHeaders != other.ExposeHeaders) return false;
      if (MaxAge != other.MaxAge) return false;
      if (AllowCredentials != other.AllowCredentials) return false;
      if (Enabled != other.Enabled) return false;
      if (!object.Equals(FilterEnabled, other.FilterEnabled)) return false;
      if (!object.Equals(ShadowEnabled, other.ShadowEnabled)) return false;
      if (EnabledSpecifierCase != other.EnabledSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= allowOrigin_.GetHashCode();
      hash ^= allowOriginRegex_.GetHashCode();
      hash ^= allowOriginStringMatch_.GetHashCode();
      if (AllowMethods.Length != 0) hash ^= AllowMethods.GetHashCode();
      if (AllowHeaders.Length != 0) hash ^= AllowHeaders.GetHashCode();
      if (ExposeHeaders.Length != 0) hash ^= ExposeHeaders.GetHashCode();
      if (MaxAge.Length != 0) hash ^= MaxAge.GetHashCode();
      if (allowCredentials_ != null) hash ^= AllowCredentials.GetHashCode();
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.Enabled) hash ^= Enabled.GetHashCode();
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) hash ^= FilterEnabled.GetHashCode();
      if (shadowEnabled_ != null) hash ^= ShadowEnabled.GetHashCode();
      hash ^= (int) enabledSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      allowOrigin_.WriteTo(output, _repeated_allowOrigin_codec);
      if (AllowMethods.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AllowMethods);
      }
      if (AllowHeaders.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(AllowHeaders);
      }
      if (ExposeHeaders.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(ExposeHeaders);
      }
      if (MaxAge.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(MaxAge);
      }
      if (allowCredentials_ != null) {
        _single_allowCredentials_codec.WriteTagAndValue(output, AllowCredentials);
      }
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.Enabled) {
        _oneof_enabled_codec.WriteTagAndValue(output, (bool?) enabledSpecifier_);
      }
      allowOriginRegex_.WriteTo(output, _repeated_allowOriginRegex_codec);
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) {
        output.WriteRawTag(74);
        output.WriteMessage(FilterEnabled);
      }
      if (shadowEnabled_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(ShadowEnabled);
      }
      allowOriginStringMatch_.WriteTo(output, _repeated_allowOriginStringMatch_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += allowOrigin_.CalculateSize(_repeated_allowOrigin_codec);
      size += allowOriginRegex_.CalculateSize(_repeated_allowOriginRegex_codec);
      size += allowOriginStringMatch_.CalculateSize(_repeated_allowOriginStringMatch_codec);
      if (AllowMethods.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AllowMethods);
      }
      if (AllowHeaders.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AllowHeaders);
      }
      if (ExposeHeaders.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExposeHeaders);
      }
      if (MaxAge.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MaxAge);
      }
      if (allowCredentials_ != null) {
        size += _single_allowCredentials_codec.CalculateSizeWithTag(AllowCredentials);
      }
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.Enabled) {
        size += _oneof_enabled_codec.CalculateSizeWithTag(Enabled);
      }
      if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FilterEnabled);
      }
      if (shadowEnabled_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ShadowEnabled);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CorsPolicy other) {
      if (other == null) {
        return;
      }
      allowOrigin_.Add(other.allowOrigin_);
      allowOriginRegex_.Add(other.allowOriginRegex_);
      allowOriginStringMatch_.Add(other.allowOriginStringMatch_);
      if (other.AllowMethods.Length != 0) {
        AllowMethods = other.AllowMethods;
      }
      if (other.AllowHeaders.Length != 0) {
        AllowHeaders = other.AllowHeaders;
      }
      if (other.ExposeHeaders.Length != 0) {
        ExposeHeaders = other.ExposeHeaders;
      }
      if (other.MaxAge.Length != 0) {
        MaxAge = other.MaxAge;
      }
      if (other.allowCredentials_ != null) {
        if (allowCredentials_ == null || other.AllowCredentials != false) {
          AllowCredentials = other.AllowCredentials;
        }
      }
      if (other.shadowEnabled_ != null) {
        if (shadowEnabled_ == null) {
          ShadowEnabled = new global::Envoy.Api.V2.Core.RuntimeFractionalPercent();
        }
        ShadowEnabled.MergeFrom(other.ShadowEnabled);
      }
      switch (other.EnabledSpecifierCase) {
        case EnabledSpecifierOneofCase.Enabled:
          Enabled = other.Enabled;
          break;
        case EnabledSpecifierOneofCase.FilterEnabled:
          if (FilterEnabled == null) {
            FilterEnabled = new global::Envoy.Api.V2.Core.RuntimeFractionalPercent();
          }
          FilterEnabled.MergeFrom(other.FilterEnabled);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            allowOrigin_.AddEntriesFrom(input, _repeated_allowOrigin_codec);
            break;
          }
          case 18: {
            AllowMethods = input.ReadString();
            break;
          }
          case 26: {
            AllowHeaders = input.ReadString();
            break;
          }
          case 34: {
            ExposeHeaders = input.ReadString();
            break;
          }
          case 42: {
            MaxAge = input.ReadString();
            break;
          }
          case 50: {
            bool? value = _single_allowCredentials_codec.Read(input);
            if (allowCredentials_ == null || value != false) {
              AllowCredentials = value;
            }
            break;
          }
          case 58: {
            Enabled = _oneof_enabled_codec.Read(input);
            break;
          }
          case 66: {
            allowOriginRegex_.AddEntriesFrom(input, _repeated_allowOriginRegex_codec);
            break;
          }
          case 74: {
            global::Envoy.Api.V2.Core.RuntimeFractionalPercent subBuilder = new global::Envoy.Api.V2.Core.RuntimeFractionalPercent();
            if (enabledSpecifierCase_ == EnabledSpecifierOneofCase.FilterEnabled) {
              subBuilder.MergeFrom(FilterEnabled);
            }
            input.ReadMessage(subBuilder);
            FilterEnabled = subBuilder;
            break;
          }
          case 82: {
            if (shadowEnabled_ == null) {
              ShadowEnabled = new global::Envoy.Api.V2.Core.RuntimeFractionalPercent();
            }
            input.ReadMessage(ShadowEnabled);
            break;
          }
          case 90: {
            allowOriginStringMatch_.AddEntriesFrom(input, _repeated_allowOriginStringMatch_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// [#comment:next free field: 30]
  /// </summary>
  public sealed partial class RouteAction : pb::IMessage<RouteAction> {
    private static readonly pb::MessageParser<RouteAction> _parser = new pb::MessageParser<RouteAction>(() => new RouteAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RouteAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteAction(RouteAction other) : this() {
      clusterNotFoundResponseCode_ = other.clusterNotFoundResponseCode_;
      metadataMatch_ = other.metadataMatch_ != null ? other.metadataMatch_.Clone() : null;
      prefixRewrite_ = other.prefixRewrite_;
      timeout_ = other.timeout_ != null ? other.timeout_.Clone() : null;
      idleTimeout_ = other.idleTimeout_ != null ? other.idleTimeout_.Clone() : null;
      retryPolicy_ = other.retryPolicy_ != null ? other.retryPolicy_.Clone() : null;
      requestMirrorPolicy_ = other.requestMirrorPolicy_ != null ? other.requestMirrorPolicy_.Clone() : null;
      priority_ = other.priority_;
      rateLimits_ = other.rateLimits_.Clone();
      IncludeVhRateLimits = other.IncludeVhRateLimits;
      hashPolicy_ = other.hashPolicy_.Clone();
      cors_ = other.cors_ != null ? other.cors_.Clone() : null;
      maxGrpcTimeout_ = other.maxGrpcTimeout_ != null ? other.maxGrpcTimeout_.Clone() : null;
      grpcTimeoutOffset_ = other.grpcTimeoutOffset_ != null ? other.grpcTimeoutOffset_.Clone() : null;
      upgradeConfigs_ = other.upgradeConfigs_.Clone();
      internalRedirectAction_ = other.internalRedirectAction_;
      hedgePolicy_ = other.hedgePolicy_ != null ? other.hedgePolicy_.Clone() : null;
      switch (other.ClusterSpecifierCase) {
        case ClusterSpecifierOneofCase.Cluster:
          Cluster = other.Cluster;
          break;
        case ClusterSpecifierOneofCase.ClusterHeader:
          ClusterHeader = other.ClusterHeader;
          break;
        case ClusterSpecifierOneofCase.WeightedClusters:
          WeightedClusters = other.WeightedClusters.Clone();
          break;
      }

      switch (other.HostRewriteSpecifierCase) {
        case HostRewriteSpecifierOneofCase.HostRewrite:
          HostRewrite = other.HostRewrite;
          break;
        case HostRewriteSpecifierOneofCase.AutoHostRewrite:
          AutoHostRewrite = other.AutoHostRewrite;
          break;
        case HostRewriteSpecifierOneofCase.AutoHostRewriteHeader:
          AutoHostRewriteHeader = other.AutoHostRewriteHeader;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteAction Clone() {
      return new RouteAction(this);
    }

    /// <summary>Field number for the "cluster" field.</summary>
    public const int ClusterFieldNumber = 1;
    /// <summary>
    /// Indicates the upstream cluster to which the request should be routed
    /// to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Cluster {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster ? (string) clusterSpecifier_ : ""; }
      set {
        clusterSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterSpecifierCase_ = ClusterSpecifierOneofCase.Cluster;
      }
    }

    /// <summary>Field number for the "cluster_header" field.</summary>
    public const int ClusterHeaderFieldNumber = 2;
    /// <summary>
    /// Envoy will determine the cluster to route to by reading the value of the
    /// HTTP header named by cluster_header from the request headers. If the
    /// header is not found or the referenced cluster does not exist, Envoy will
    /// return a 404 response.
    ///
    /// .. attention::
    ///
    ///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
    ///   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ClusterHeader {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader ? (string) clusterSpecifier_ : ""; }
      set {
        clusterSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        clusterSpecifierCase_ = ClusterSpecifierOneofCase.ClusterHeader;
      }
    }

    /// <summary>Field number for the "weighted_clusters" field.</summary>
    public const int WeightedClustersFieldNumber = 3;
    /// <summary>
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster. See
    /// :ref:`traffic splitting &lt;config_http_conn_man_route_table_traffic_splitting_split>`
    /// for additional documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.WeightedCluster WeightedClusters {
      get { return clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters ? (global::Envoy.Api.V2.Route.WeightedCluster) clusterSpecifier_ : null; }
      set {
        clusterSpecifier_ = value;
        clusterSpecifierCase_ = value == null ? ClusterSpecifierOneofCase.None : ClusterSpecifierOneofCase.WeightedClusters;
      }
    }

    /// <summary>Field number for the "cluster_not_found_response_code" field.</summary>
    public const int ClusterNotFoundResponseCodeFieldNumber = 20;
    private global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode clusterNotFoundResponseCode_ = global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable;
    /// <summary>
    /// The HTTP status code to use when configured cluster is not found.
    /// The default response code is 503 Service Unavailable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode ClusterNotFoundResponseCode {
      get { return clusterNotFoundResponseCode_; }
      set {
        clusterNotFoundResponseCode_ = value;
      }
    }

    /// <summary>Field number for the "metadata_match" field.</summary>
    public const int MetadataMatchFieldNumber = 4;
    private global::Envoy.Api.V2.Core.Metadata metadataMatch_;
    /// <summary>
    /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
    /// in the upstream cluster with metadata matching what's set in this field will be considered
    /// for load balancing. If using :ref:`weighted_clusters
    /// &lt;envoy_api_field_route.RouteAction.weighted_clusters>`, metadata will be merged, with values
    /// provided there taking precedence. The filter name should be specified as *envoy.lb*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata MetadataMatch {
      get { return metadataMatch_; }
      set {
        metadataMatch_ = value;
      }
    }

    /// <summary>Field number for the "prefix_rewrite" field.</summary>
    public const int PrefixRewriteFieldNumber = 5;
    private string prefixRewrite_ = "";
    /// <summary>
    /// Indicates that during forwarding, the matched prefix (or path) should be
    /// swapped with this value. This option allows application URLs to be rooted
    /// at a different path from those exposed at the reverse proxy layer. The router filter will
    /// place the original path before rewrite into the :ref:`x-envoy-original-path
    /// &lt;config_http_filters_router_x-envoy-original-path>` header.
    ///
    /// .. attention::
    ///
    ///   Pay careful attention to the use of trailing slashes in the
    ///   :ref:`route's match &lt;envoy_api_field_route.Route.match>` prefix value.
    ///   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
    ///   rewriting */prefix* to */* and */prefix/etc* to */etc* cannot be done in a single
    ///   :ref:`Route &lt;envoy_api_msg_route.Route>`, as shown by the below config entries:
    ///
    ///   .. code-block:: yaml
    ///
    ///     - match:
    ///         prefix: "/prefix/"
    ///       route:
    ///         prefix_rewrite: "/"
    ///     - match:
    ///         prefix: "/prefix"
    ///       route:
    ///         prefix_rewrite: "/"
    ///
    ///   Having above entries in the config, requests to */prefix* will be stripped to */*, while
    ///   requests to */prefix/etc* will be stripped to */etc*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PrefixRewrite {
      get { return prefixRewrite_; }
      set {
        prefixRewrite_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "host_rewrite" field.</summary>
    public const int HostRewriteFieldNumber = 6;
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with
    /// this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HostRewrite {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewrite ? (string) hostRewriteSpecifier_ : ""; }
      set {
        hostRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.HostRewrite;
      }
    }

    /// <summary>Field number for the "auto_host_rewrite" field.</summary>
    public const int AutoHostRewriteFieldNumber = 7;
    private static readonly pb::FieldCodec<bool?> _oneof_autoHostRewrite_codec = pb::FieldCodec.ForStructWrapper<bool>(58);
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with
    /// the hostname of the upstream host chosen by the cluster manager. This
    /// option is applicable only when the destination cluster for a route is of
    /// type *strict_dns* or *logical_dns*. Setting this to true with other cluster
    /// types has no effect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? AutoHostRewrite {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite ? (bool?) hostRewriteSpecifier_ : (bool?) null; }
      set {
        hostRewriteSpecifier_ = value;
        hostRewriteSpecifierCase_ = value == null ? HostRewriteSpecifierOneofCase.None : HostRewriteSpecifierOneofCase.AutoHostRewrite;
      }
    }

    /// <summary>Field number for the "auto_host_rewrite_header" field.</summary>
    public const int AutoHostRewriteHeaderFieldNumber = 29;
    /// <summary>
    /// Indicates that during forwarding, the host header will be swapped with the content of given
    /// downstream or :ref:`custom &lt;config_http_conn_man_headers_custom_request_headers>` header.
    /// If header value is empty, host header is left intact.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the potential security implications of using this option. Provided header
    ///   must come from trusted source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AutoHostRewriteHeader {
      get { return hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewriteHeader ? (string) hostRewriteSpecifier_ : ""; }
      set {
        hostRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.AutoHostRewriteHeader;
      }
    }

    /// <summary>Field number for the "timeout" field.</summary>
    public const int TimeoutFieldNumber = 8;
    private global::Google.Protobuf.WellKnownTypes.Duration timeout_;
    /// <summary>
    /// Specifies the upstream timeout for the route. If not specified, the default is 15s. This
    /// spans between the point at which the entire downstream request (i.e. end-of-stream) has been
    /// processed and when the upstream response has been completely processed. A value of 0 will
    /// disable the route's timeout.
    ///
    /// .. note::
    ///
    ///   This timeout includes all retries. See also
    ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
    ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
    ///   :ref:`retry overview &lt;arch_overview_http_routing_retry>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration Timeout {
      get { return timeout_; }
      set {
        timeout_ = value;
      }
    }

    /// <summary>Field number for the "idle_timeout" field.</summary>
    public const int IdleTimeoutFieldNumber = 24;
    private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
    /// <summary>
    /// Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
    /// although the connection manager wide :ref:`stream_idle_timeout
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.stream_idle_timeout>`
    /// will still apply. A value of 0 will completely disable the route's idle timeout, even if a
    /// connection manager stream idle timeout is configured.
    ///
    /// The idle timeout is distinct to :ref:`timeout
    /// &lt;envoy_api_field_route.RouteAction.timeout>`, which provides an upper bound
    /// on the upstream response time; :ref:`idle_timeout
    /// &lt;envoy_api_field_route.RouteAction.idle_timeout>` instead bounds the amount
    /// of time the request's stream may be idle.
    ///
    /// After header decoding, the idle timeout will apply on downstream and
    /// upstream request events. Each time an encode/decode event for headers or
    /// data is processed for the stream, the timer will be reset. If the timeout
    /// fires, the stream is terminated with a 408 Request Timeout error code if no
    /// upstream response header has been received, otherwise a stream reset
    /// occurs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
      get { return idleTimeout_; }
      set {
        idleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "retry_policy" field.</summary>
    public const int RetryPolicyFieldNumber = 9;
    private global::Envoy.Api.V2.Route.RetryPolicy retryPolicy_;
    /// <summary>
    /// Indicates that the route has a retry policy. Note that if this is set,
    /// it'll take precedence over the virtual host level retry policy entirely
    /// (e.g.: policies are not merged, most internal one becomes the enforced policy).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RetryPolicy RetryPolicy {
      get { return retryPolicy_; }
      set {
        retryPolicy_ = value;
      }
    }

    /// <summary>Field number for the "request_mirror_policy" field.</summary>
    public const int RequestMirrorPolicyFieldNumber = 10;
    private global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy requestMirrorPolicy_;
    /// <summary>
    /// Indicates that the route has a request mirroring policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy RequestMirrorPolicy {
      get { return requestMirrorPolicy_; }
      set {
        requestMirrorPolicy_ = value;
      }
    }

    /// <summary>Field number for the "priority" field.</summary>
    public const int PriorityFieldNumber = 11;
    private global::Envoy.Api.V2.Core.RoutingPriority priority_ = global::Envoy.Api.V2.Core.RoutingPriority.Default;
    /// <summary>
    /// Optionally specifies the :ref:`routing priority &lt;arch_overview_http_routing_priority>`.
    /// [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
    /// https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RoutingPriority Priority {
      get { return priority_; }
      set {
        priority_ = value;
      }
    }

    /// <summary>Field number for the "rate_limits" field.</summary>
    public const int RateLimitsFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RateLimit> _repeated_rateLimits_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Api.V2.Route.RateLimit.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit> rateLimits_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit>();
    /// <summary>
    /// Specifies a set of rate limit configurations that could be applied to the
    /// route.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit> RateLimits {
      get { return rateLimits_; }
    }

    /// <summary>Field number for the "include_vh_rate_limits" field.</summary>
    public const int IncludeVhRateLimitsFieldNumber = 14;
    private static readonly pb::FieldCodec<bool?> _single_includeVhRateLimits_codec = pb::FieldCodec.ForStructWrapper<bool>(114);
    private bool? includeVhRateLimits_;
    /// <summary>
    /// Specifies if the rate limit filter should include the virtual host rate
    /// limits. By default, if the route configured rate limits, the virtual host
    /// :ref:`rate_limits &lt;envoy_api_field_route.VirtualHost.rate_limits>` are not applied to the
    /// request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? IncludeVhRateLimits {
      get { return includeVhRateLimits_; }
      set {
        includeVhRateLimits_ = value;
      }
    }


    /// <summary>Field number for the "hash_policy" field.</summary>
    public const int HashPolicyFieldNumber = 15;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy> _repeated_hashPolicy_codec
        = pb::FieldCodec.ForMessage(122, global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy> hashPolicy_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy>();
    /// <summary>
    /// Specifies a list of hash policies to use for ring hash load balancing. Each
    /// hash policy is evaluated individually and the combined result is used to
    /// route the request. The method of combination is deterministic such that
    /// identical lists of hash policies will produce the same hash. Since a hash
    /// policy examines specific parts of a request, it can fail to produce a hash
    /// (i.e. if the hashed header is not present). If (and only if) all configured
    /// hash policies fail to generate a hash, no hash will be produced for
    /// the route. In this case, the behavior is the same as if no hash policies
    /// were specified (i.e. the ring hash load balancer will choose a random
    /// backend). If a hash policy has the "terminal" attribute set to true, and
    /// there is already a hash generated, the hash is returned immediately,
    /// ignoring the rest of the hash policy list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy> HashPolicy {
      get { return hashPolicy_; }
    }

    /// <summary>Field number for the "cors" field.</summary>
    public const int CorsFieldNumber = 17;
    private global::Envoy.Api.V2.Route.CorsPolicy cors_;
    /// <summary>
    /// Indicates that the route has a CORS policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.CorsPolicy Cors {
      get { return cors_; }
      set {
        cors_ = value;
      }
    }

    /// <summary>Field number for the "max_grpc_timeout" field.</summary>
    public const int MaxGrpcTimeoutFieldNumber = 23;
    private global::Google.Protobuf.WellKnownTypes.Duration maxGrpcTimeout_;
    /// <summary>
    /// If present, and the request is a gRPC request, use the
    /// `grpc-timeout header &lt;https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
    /// or its default value (infinity) instead of
    /// :ref:`timeout &lt;envoy_api_field_route.RouteAction.timeout>`, but limit the applied timeout
    /// to the maximum value specified here. If configured as 0, the maximum allowed timeout for
    /// gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
    /// and gRPC requests time out like any other requests using
    /// :ref:`timeout &lt;envoy_api_field_route.RouteAction.timeout>` or its default.
    /// This can be used to prevent unexpected upstream request timeouts due to potentially long
    /// time gaps between gRPC request and response in gRPC streaming mode.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration MaxGrpcTimeout {
      get { return maxGrpcTimeout_; }
      set {
        maxGrpcTimeout_ = value;
      }
    }

    /// <summary>Field number for the "grpc_timeout_offset" field.</summary>
    public const int GrpcTimeoutOffsetFieldNumber = 28;
    private global::Google.Protobuf.WellKnownTypes.Duration grpcTimeoutOffset_;
    /// <summary>
    /// If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
    /// the provided duration from the header. This is useful in allowing Envoy to set its global
    /// timeout to be less than that of the deadline imposed by the calling client, which makes it more
    /// likely that Envoy will handle the timeout instead of having the call canceled by the client.
    /// The offset will only be applied if the provided grpc_timeout is greater than the offset. This
    /// ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
    /// infinity).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration GrpcTimeoutOffset {
      get { return grpcTimeoutOffset_; }
      set {
        grpcTimeoutOffset_ = value;
      }
    }

    /// <summary>Field number for the "upgrade_configs" field.</summary>
    public const int UpgradeConfigsFieldNumber = 25;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RouteAction.Types.UpgradeConfig> _repeated_upgradeConfigs_codec
        = pb::FieldCodec.ForMessage(202, global::Envoy.Api.V2.Route.RouteAction.Types.UpgradeConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.UpgradeConfig> upgradeConfigs_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.UpgradeConfig>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RouteAction.Types.UpgradeConfig> UpgradeConfigs {
      get { return upgradeConfigs_; }
    }

    /// <summary>Field number for the "internal_redirect_action" field.</summary>
    public const int InternalRedirectActionFieldNumber = 26;
    private global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction internalRedirectAction_ = global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction InternalRedirectAction {
      get { return internalRedirectAction_; }
      set {
        internalRedirectAction_ = value;
      }
    }

    /// <summary>Field number for the "hedge_policy" field.</summary>
    public const int HedgePolicyFieldNumber = 27;
    private global::Envoy.Api.V2.Route.HedgePolicy hedgePolicy_;
    /// <summary>
    /// Indicates that the route has a hedge policy. Note that if this is set,
    /// it'll take precedence over the virtual host level hedge policy entirely
    /// (e.g.: policies are not merged, most internal one becomes the enforced policy).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.HedgePolicy HedgePolicy {
      get { return hedgePolicy_; }
      set {
        hedgePolicy_ = value;
      }
    }

    private object clusterSpecifier_;
    /// <summary>Enum of possible cases for the "cluster_specifier" oneof.</summary>
    public enum ClusterSpecifierOneofCase {
      None = 0,
      Cluster = 1,
      ClusterHeader = 2,
      WeightedClusters = 3,
    }
    private ClusterSpecifierOneofCase clusterSpecifierCase_ = ClusterSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterSpecifierOneofCase ClusterSpecifierCase {
      get { return clusterSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClusterSpecifier() {
      clusterSpecifierCase_ = ClusterSpecifierOneofCase.None;
      clusterSpecifier_ = null;
    }

    private object hostRewriteSpecifier_;
    /// <summary>Enum of possible cases for the "host_rewrite_specifier" oneof.</summary>
    public enum HostRewriteSpecifierOneofCase {
      None = 0,
      HostRewrite = 6,
      AutoHostRewrite = 7,
      AutoHostRewriteHeader = 29,
    }
    private HostRewriteSpecifierOneofCase hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HostRewriteSpecifierOneofCase HostRewriteSpecifierCase {
      get { return hostRewriteSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHostRewriteSpecifier() {
      hostRewriteSpecifierCase_ = HostRewriteSpecifierOneofCase.None;
      hostRewriteSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RouteAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RouteAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Cluster != other.Cluster) return false;
      if (ClusterHeader != other.ClusterHeader) return false;
      if (!object.Equals(WeightedClusters, other.WeightedClusters)) return false;
      if (ClusterNotFoundResponseCode != other.ClusterNotFoundResponseCode) return false;
      if (!object.Equals(MetadataMatch, other.MetadataMatch)) return false;
      if (PrefixRewrite != other.PrefixRewrite) return false;
      if (HostRewrite != other.HostRewrite) return false;
      if (AutoHostRewrite != other.AutoHostRewrite) return false;
      if (AutoHostRewriteHeader != other.AutoHostRewriteHeader) return false;
      if (!object.Equals(Timeout, other.Timeout)) return false;
      if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
      if (!object.Equals(RetryPolicy, other.RetryPolicy)) return false;
      if (!object.Equals(RequestMirrorPolicy, other.RequestMirrorPolicy)) return false;
      if (Priority != other.Priority) return false;
      if(!rateLimits_.Equals(other.rateLimits_)) return false;
      if (IncludeVhRateLimits != other.IncludeVhRateLimits) return false;
      if(!hashPolicy_.Equals(other.hashPolicy_)) return false;
      if (!object.Equals(Cors, other.Cors)) return false;
      if (!object.Equals(MaxGrpcTimeout, other.MaxGrpcTimeout)) return false;
      if (!object.Equals(GrpcTimeoutOffset, other.GrpcTimeoutOffset)) return false;
      if(!upgradeConfigs_.Equals(other.upgradeConfigs_)) return false;
      if (InternalRedirectAction != other.InternalRedirectAction) return false;
      if (!object.Equals(HedgePolicy, other.HedgePolicy)) return false;
      if (ClusterSpecifierCase != other.ClusterSpecifierCase) return false;
      if (HostRewriteSpecifierCase != other.HostRewriteSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) hash ^= Cluster.GetHashCode();
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) hash ^= ClusterHeader.GetHashCode();
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) hash ^= WeightedClusters.GetHashCode();
      if (ClusterNotFoundResponseCode != global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) hash ^= ClusterNotFoundResponseCode.GetHashCode();
      if (metadataMatch_ != null) hash ^= MetadataMatch.GetHashCode();
      if (PrefixRewrite.Length != 0) hash ^= PrefixRewrite.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewrite) hash ^= HostRewrite.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) hash ^= AutoHostRewrite.GetHashCode();
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewriteHeader) hash ^= AutoHostRewriteHeader.GetHashCode();
      if (timeout_ != null) hash ^= Timeout.GetHashCode();
      if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
      if (retryPolicy_ != null) hash ^= RetryPolicy.GetHashCode();
      if (requestMirrorPolicy_ != null) hash ^= RequestMirrorPolicy.GetHashCode();
      if (Priority != global::Envoy.Api.V2.Core.RoutingPriority.Default) hash ^= Priority.GetHashCode();
      hash ^= rateLimits_.GetHashCode();
      if (includeVhRateLimits_ != null) hash ^= IncludeVhRateLimits.GetHashCode();
      hash ^= hashPolicy_.GetHashCode();
      if (cors_ != null) hash ^= Cors.GetHashCode();
      if (maxGrpcTimeout_ != null) hash ^= MaxGrpcTimeout.GetHashCode();
      if (grpcTimeoutOffset_ != null) hash ^= GrpcTimeoutOffset.GetHashCode();
      hash ^= upgradeConfigs_.GetHashCode();
      if (InternalRedirectAction != global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) hash ^= InternalRedirectAction.GetHashCode();
      if (hedgePolicy_ != null) hash ^= HedgePolicy.GetHashCode();
      hash ^= (int) clusterSpecifierCase_;
      hash ^= (int) hostRewriteSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) {
        output.WriteRawTag(10);
        output.WriteString(Cluster);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) {
        output.WriteRawTag(18);
        output.WriteString(ClusterHeader);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
        output.WriteRawTag(26);
        output.WriteMessage(WeightedClusters);
      }
      if (metadataMatch_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(MetadataMatch);
      }
      if (PrefixRewrite.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(PrefixRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewrite) {
        output.WriteRawTag(50);
        output.WriteString(HostRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) {
        _oneof_autoHostRewrite_codec.WriteTagAndValue(output, (bool?) hostRewriteSpecifier_);
      }
      if (timeout_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Timeout);
      }
      if (retryPolicy_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(RetryPolicy);
      }
      if (requestMirrorPolicy_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(RequestMirrorPolicy);
      }
      if (Priority != global::Envoy.Api.V2.Core.RoutingPriority.Default) {
        output.WriteRawTag(88);
        output.WriteEnum((int) Priority);
      }
      rateLimits_.WriteTo(output, _repeated_rateLimits_codec);
      if (includeVhRateLimits_ != null) {
        _single_includeVhRateLimits_codec.WriteTagAndValue(output, IncludeVhRateLimits);
      }
      hashPolicy_.WriteTo(output, _repeated_hashPolicy_codec);
      if (cors_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Cors);
      }
      if (ClusterNotFoundResponseCode != global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) {
        output.WriteRawTag(160, 1);
        output.WriteEnum((int) ClusterNotFoundResponseCode);
      }
      if (maxGrpcTimeout_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(MaxGrpcTimeout);
      }
      if (idleTimeout_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(IdleTimeout);
      }
      upgradeConfigs_.WriteTo(output, _repeated_upgradeConfigs_codec);
      if (InternalRedirectAction != global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) InternalRedirectAction);
      }
      if (hedgePolicy_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(HedgePolicy);
      }
      if (grpcTimeoutOffset_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(GrpcTimeoutOffset);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewriteHeader) {
        output.WriteRawTag(234, 1);
        output.WriteString(AutoHostRewriteHeader);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.Cluster) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.ClusterHeader) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterHeader);
      }
      if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedClusters);
      }
      if (ClusterNotFoundResponseCode != global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ClusterNotFoundResponseCode);
      }
      if (metadataMatch_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MetadataMatch);
      }
      if (PrefixRewrite.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.HostRewrite) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewrite) {
        size += _oneof_autoHostRewrite_codec.CalculateSizeWithTag(AutoHostRewrite);
      }
      if (hostRewriteSpecifierCase_ == HostRewriteSpecifierOneofCase.AutoHostRewriteHeader) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(AutoHostRewriteHeader);
      }
      if (timeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timeout);
      }
      if (idleTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
      }
      if (retryPolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryPolicy);
      }
      if (requestMirrorPolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestMirrorPolicy);
      }
      if (Priority != global::Envoy.Api.V2.Core.RoutingPriority.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Priority);
      }
      size += rateLimits_.CalculateSize(_repeated_rateLimits_codec);
      if (includeVhRateLimits_ != null) {
        size += _single_includeVhRateLimits_codec.CalculateSizeWithTag(IncludeVhRateLimits);
      }
      size += hashPolicy_.CalculateSize(_repeated_hashPolicy_codec);
      if (cors_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Cors);
      }
      if (maxGrpcTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MaxGrpcTimeout);
      }
      if (grpcTimeoutOffset_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(GrpcTimeoutOffset);
      }
      size += upgradeConfigs_.CalculateSize(_repeated_upgradeConfigs_codec);
      if (InternalRedirectAction != global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) InternalRedirectAction);
      }
      if (hedgePolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(HedgePolicy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RouteAction other) {
      if (other == null) {
        return;
      }
      if (other.ClusterNotFoundResponseCode != global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode.ServiceUnavailable) {
        ClusterNotFoundResponseCode = other.ClusterNotFoundResponseCode;
      }
      if (other.metadataMatch_ != null) {
        if (metadataMatch_ == null) {
          MetadataMatch = new global::Envoy.Api.V2.Core.Metadata();
        }
        MetadataMatch.MergeFrom(other.MetadataMatch);
      }
      if (other.PrefixRewrite.Length != 0) {
        PrefixRewrite = other.PrefixRewrite;
      }
      if (other.timeout_ != null) {
        if (timeout_ == null) {
          Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        Timeout.MergeFrom(other.Timeout);
      }
      if (other.idleTimeout_ != null) {
        if (idleTimeout_ == null) {
          IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        IdleTimeout.MergeFrom(other.IdleTimeout);
      }
      if (other.retryPolicy_ != null) {
        if (retryPolicy_ == null) {
          RetryPolicy = new global::Envoy.Api.V2.Route.RetryPolicy();
        }
        RetryPolicy.MergeFrom(other.RetryPolicy);
      }
      if (other.requestMirrorPolicy_ != null) {
        if (requestMirrorPolicy_ == null) {
          RequestMirrorPolicy = new global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy();
        }
        RequestMirrorPolicy.MergeFrom(other.RequestMirrorPolicy);
      }
      if (other.Priority != global::Envoy.Api.V2.Core.RoutingPriority.Default) {
        Priority = other.Priority;
      }
      rateLimits_.Add(other.rateLimits_);
      if (other.includeVhRateLimits_ != null) {
        if (includeVhRateLimits_ == null || other.IncludeVhRateLimits != false) {
          IncludeVhRateLimits = other.IncludeVhRateLimits;
        }
      }
      hashPolicy_.Add(other.hashPolicy_);
      if (other.cors_ != null) {
        if (cors_ == null) {
          Cors = new global::Envoy.Api.V2.Route.CorsPolicy();
        }
        Cors.MergeFrom(other.Cors);
      }
      if (other.maxGrpcTimeout_ != null) {
        if (maxGrpcTimeout_ == null) {
          MaxGrpcTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        MaxGrpcTimeout.MergeFrom(other.MaxGrpcTimeout);
      }
      if (other.grpcTimeoutOffset_ != null) {
        if (grpcTimeoutOffset_ == null) {
          GrpcTimeoutOffset = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        GrpcTimeoutOffset.MergeFrom(other.GrpcTimeoutOffset);
      }
      upgradeConfigs_.Add(other.upgradeConfigs_);
      if (other.InternalRedirectAction != global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction.PassThroughInternalRedirect) {
        InternalRedirectAction = other.InternalRedirectAction;
      }
      if (other.hedgePolicy_ != null) {
        if (hedgePolicy_ == null) {
          HedgePolicy = new global::Envoy.Api.V2.Route.HedgePolicy();
        }
        HedgePolicy.MergeFrom(other.HedgePolicy);
      }
      switch (other.ClusterSpecifierCase) {
        case ClusterSpecifierOneofCase.Cluster:
          Cluster = other.Cluster;
          break;
        case ClusterSpecifierOneofCase.ClusterHeader:
          ClusterHeader = other.ClusterHeader;
          break;
        case ClusterSpecifierOneofCase.WeightedClusters:
          if (WeightedClusters == null) {
            WeightedClusters = new global::Envoy.Api.V2.Route.WeightedCluster();
          }
          WeightedClusters.MergeFrom(other.WeightedClusters);
          break;
      }

      switch (other.HostRewriteSpecifierCase) {
        case HostRewriteSpecifierOneofCase.HostRewrite:
          HostRewrite = other.HostRewrite;
          break;
        case HostRewriteSpecifierOneofCase.AutoHostRewrite:
          AutoHostRewrite = other.AutoHostRewrite;
          break;
        case HostRewriteSpecifierOneofCase.AutoHostRewriteHeader:
          AutoHostRewriteHeader = other.AutoHostRewriteHeader;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Cluster = input.ReadString();
            break;
          }
          case 18: {
            ClusterHeader = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Api.V2.Route.WeightedCluster subBuilder = new global::Envoy.Api.V2.Route.WeightedCluster();
            if (clusterSpecifierCase_ == ClusterSpecifierOneofCase.WeightedClusters) {
              subBuilder.MergeFrom(WeightedClusters);
            }
            input.ReadMessage(subBuilder);
            WeightedClusters = subBuilder;
            break;
          }
          case 34: {
            if (metadataMatch_ == null) {
              MetadataMatch = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(MetadataMatch);
            break;
          }
          case 42: {
            PrefixRewrite = input.ReadString();
            break;
          }
          case 50: {
            HostRewrite = input.ReadString();
            break;
          }
          case 58: {
            AutoHostRewrite = _oneof_autoHostRewrite_codec.Read(input);
            break;
          }
          case 66: {
            if (timeout_ == null) {
              Timeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(Timeout);
            break;
          }
          case 74: {
            if (retryPolicy_ == null) {
              RetryPolicy = new global::Envoy.Api.V2.Route.RetryPolicy();
            }
            input.ReadMessage(RetryPolicy);
            break;
          }
          case 82: {
            if (requestMirrorPolicy_ == null) {
              RequestMirrorPolicy = new global::Envoy.Api.V2.Route.RouteAction.Types.RequestMirrorPolicy();
            }
            input.ReadMessage(RequestMirrorPolicy);
            break;
          }
          case 88: {
            Priority = (global::Envoy.Api.V2.Core.RoutingPriority) input.ReadEnum();
            break;
          }
          case 106: {
            rateLimits_.AddEntriesFrom(input, _repeated_rateLimits_codec);
            break;
          }
          case 114: {
            bool? value = _single_includeVhRateLimits_codec.Read(input);
            if (includeVhRateLimits_ == null || value != false) {
              IncludeVhRateLimits = value;
            }
            break;
          }
          case 122: {
            hashPolicy_.AddEntriesFrom(input, _repeated_hashPolicy_codec);
            break;
          }
          case 138: {
            if (cors_ == null) {
              Cors = new global::Envoy.Api.V2.Route.CorsPolicy();
            }
            input.ReadMessage(Cors);
            break;
          }
          case 160: {
            ClusterNotFoundResponseCode = (global::Envoy.Api.V2.Route.RouteAction.Types.ClusterNotFoundResponseCode) input.ReadEnum();
            break;
          }
          case 186: {
            if (maxGrpcTimeout_ == null) {
              MaxGrpcTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(MaxGrpcTimeout);
            break;
          }
          case 194: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 202: {
            upgradeConfigs_.AddEntriesFrom(input, _repeated_upgradeConfigs_codec);
            break;
          }
          case 208: {
            InternalRedirectAction = (global::Envoy.Api.V2.Route.RouteAction.Types.InternalRedirectAction) input.ReadEnum();
            break;
          }
          case 218: {
            if (hedgePolicy_ == null) {
              HedgePolicy = new global::Envoy.Api.V2.Route.HedgePolicy();
            }
            input.ReadMessage(HedgePolicy);
            break;
          }
          case 226: {
            if (grpcTimeoutOffset_ == null) {
              GrpcTimeoutOffset = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(GrpcTimeoutOffset);
            break;
          }
          case 234: {
            AutoHostRewriteHeader = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RouteAction message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum ClusterNotFoundResponseCode {
        /// <summary>
        /// HTTP status code - 503 Service Unavailable.
        /// </summary>
        [pbr::OriginalName("SERVICE_UNAVAILABLE")] ServiceUnavailable = 0,
        /// <summary>
        /// HTTP status code - 404 Not Found.
        /// </summary>
        [pbr::OriginalName("NOT_FOUND")] NotFound = 1,
      }

      /// <summary>
      /// Configures :ref:`internal redirect &lt;arch_overview_internal_redirects>` behavior.
      /// </summary>
      public enum InternalRedirectAction {
        [pbr::OriginalName("PASS_THROUGH_INTERNAL_REDIRECT")] PassThroughInternalRedirect = 0,
        [pbr::OriginalName("HANDLE_INTERNAL_REDIRECT")] HandleInternalRedirect = 1,
      }

      /// <summary>
      /// The router is capable of shadowing traffic from one cluster to another. The current
      /// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
      /// respond before returning the response from the primary cluster. All normal statistics are
      /// collected for the shadow cluster making this feature useful for testing.
      ///
      /// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
      /// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
      /// </summary>
      public sealed partial class RequestMirrorPolicy : pb::IMessage<RequestMirrorPolicy> {
        private static readonly pb::MessageParser<RequestMirrorPolicy> _parser = new pb::MessageParser<RequestMirrorPolicy>(() => new RequestMirrorPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RequestMirrorPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RouteAction.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RequestMirrorPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RequestMirrorPolicy(RequestMirrorPolicy other) : this() {
          cluster_ = other.cluster_;
          runtimeKey_ = other.runtimeKey_;
          runtimeFraction_ = other.runtimeFraction_ != null ? other.runtimeFraction_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RequestMirrorPolicy Clone() {
          return new RequestMirrorPolicy(this);
        }

        /// <summary>Field number for the "cluster" field.</summary>
        public const int ClusterFieldNumber = 1;
        private string cluster_ = "";
        /// <summary>
        /// Specifies the cluster that requests will be mirrored to. The cluster must
        /// exist in the cluster manager configuration.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Cluster {
          get { return cluster_; }
          set {
            cluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "runtime_key" field.</summary>
        public const int RuntimeKeyFieldNumber = 2;
        private string runtimeKey_ = "";
        /// <summary>
        /// If not specified, all requests to the target cluster will be mirrored. If
        /// specified, Envoy will lookup the runtime key to get the % of requests to
        /// mirror. Valid values are from 0 to 10000, allowing for increments of
        /// 0.01% of requests to be mirrored. If the runtime key is specified in the
        /// configuration but not present in runtime, 0 is the default and thus 0% of
        /// requests will be mirrored.
        ///
        /// .. attention::
        ///
        ///   **This field is deprecated**. Set the
        ///   :ref:`runtime_fraction
        ///   &lt;envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_fraction>` field instead.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string RuntimeKey {
          get { return runtimeKey_; }
          set {
            runtimeKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "runtime_fraction" field.</summary>
        public const int RuntimeFractionFieldNumber = 3;
        private global::Envoy.Api.V2.Core.RuntimeFractionalPercent runtimeFraction_;
        /// <summary>
        /// If both :ref:`runtime_key
        /// &lt;envoy_api_field_route.RouteAction.RequestMirrorPolicy.runtime_key>` and this field are not
        /// specified, all requests to the target cluster will be mirrored.
        ///
        /// If specified, this field takes precedence over the `runtime_key` field and requests must also
        /// fall under the percentage of matches indicated by this field.
        ///
        /// For some fraction N/D, a random number in the range [0,D) is selected. If the
        /// number is &lt;= the value of the numerator N, or if the key is not present, the default
        /// value, the request will be mirrored.
        ///
        /// .. note::
        ///
        ///   Parsing this field is implemented such that the runtime key's data may be represented
        ///   as a :ref:`FractionalPercent &lt;envoy_api_msg_type.FractionalPercent>` proto represented
        ///   as JSON/YAML and may also be represented as an integer with the assumption that the value
        ///   is an integral percentage out of 100. For instance, a runtime key lookup returning the
        ///   value "42" would parse as a `FractionalPercent` whose numerator is 42 and denominator is
        ///   HUNDRED. This is behaviour is different to that of the deprecated `runtime_key` field,
        ///   where the implicit denominator is 10000.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.RuntimeFractionalPercent RuntimeFraction {
          get { return runtimeFraction_; }
          set {
            runtimeFraction_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RequestMirrorPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RequestMirrorPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Cluster != other.Cluster) return false;
          if (RuntimeKey != other.RuntimeKey) return false;
          if (!object.Equals(RuntimeFraction, other.RuntimeFraction)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Cluster.Length != 0) hash ^= Cluster.GetHashCode();
          if (RuntimeKey.Length != 0) hash ^= RuntimeKey.GetHashCode();
          if (runtimeFraction_ != null) hash ^= RuntimeFraction.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Cluster.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Cluster);
          }
          if (RuntimeKey.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(RuntimeKey);
          }
          if (runtimeFraction_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(RuntimeFraction);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Cluster.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
          }
          if (RuntimeKey.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(RuntimeKey);
          }
          if (runtimeFraction_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RuntimeFraction);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RequestMirrorPolicy other) {
          if (other == null) {
            return;
          }
          if (other.Cluster.Length != 0) {
            Cluster = other.Cluster;
          }
          if (other.RuntimeKey.Length != 0) {
            RuntimeKey = other.RuntimeKey;
          }
          if (other.runtimeFraction_ != null) {
            if (runtimeFraction_ == null) {
              RuntimeFraction = new global::Envoy.Api.V2.Core.RuntimeFractionalPercent();
            }
            RuntimeFraction.MergeFrom(other.RuntimeFraction);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Cluster = input.ReadString();
                break;
              }
              case 18: {
                RuntimeKey = input.ReadString();
                break;
              }
              case 26: {
                if (runtimeFraction_ == null) {
                  RuntimeFraction = new global::Envoy.Api.V2.Core.RuntimeFractionalPercent();
                }
                input.ReadMessage(RuntimeFraction);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
      /// &lt;arch_overview_load_balancing_types>`.
      /// </summary>
      public sealed partial class HashPolicy : pb::IMessage<HashPolicy> {
        private static readonly pb::MessageParser<HashPolicy> _parser = new pb::MessageParser<HashPolicy>(() => new HashPolicy());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HashPolicy> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RouteAction.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HashPolicy() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HashPolicy(HashPolicy other) : this() {
          terminal_ = other.terminal_;
          switch (other.PolicySpecifierCase) {
            case PolicySpecifierOneofCase.Header:
              Header = other.Header.Clone();
              break;
            case PolicySpecifierOneofCase.Cookie:
              Cookie = other.Cookie.Clone();
              break;
            case PolicySpecifierOneofCase.ConnectionProperties:
              ConnectionProperties = other.ConnectionProperties.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HashPolicy Clone() {
          return new HashPolicy(this);
        }

        /// <summary>Field number for the "header" field.</summary>
        public const int HeaderFieldNumber = 1;
        /// <summary>
        /// Header hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header Header {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.Header ? (global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.Header;
          }
        }

        /// <summary>Field number for the "cookie" field.</summary>
        public const int CookieFieldNumber = 2;
        /// <summary>
        /// Cookie hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie Cookie {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.Cookie ? (global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.Cookie;
          }
        }

        /// <summary>Field number for the "connection_properties" field.</summary>
        public const int ConnectionPropertiesFieldNumber = 3;
        /// <summary>
        /// Connection properties hash policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties ConnectionProperties {
          get { return policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties ? (global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties) policySpecifier_ : null; }
          set {
            policySpecifier_ = value;
            policySpecifierCase_ = value == null ? PolicySpecifierOneofCase.None : PolicySpecifierOneofCase.ConnectionProperties;
          }
        }

        /// <summary>Field number for the "terminal" field.</summary>
        public const int TerminalFieldNumber = 4;
        private bool terminal_;
        /// <summary>
        /// The flag that shortcircuits the hash computing. This field provides a
        /// 'fallback' style of configuration: "if a terminal policy doesn't work,
        /// fallback to rest of the policy list", it saves time when the terminal
        /// policy works.
        ///
        /// If true, and there is already a hash computed, ignore rest of the
        /// list of hash polices.
        /// For example, if the following hash methods are configured:
        ///
        ///  ========= ========
        ///  specifier terminal
        ///  ========= ========
        ///  Header A  true
        ///  Header B  false
        ///  Header C  false
        ///  ========= ========
        ///
        /// The generateHash process ends if policy "header A" generates a hash, as
        /// it's a terminal policy.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Terminal {
          get { return terminal_; }
          set {
            terminal_ = value;
          }
        }

        private object policySpecifier_;
        /// <summary>Enum of possible cases for the "policy_specifier" oneof.</summary>
        public enum PolicySpecifierOneofCase {
          None = 0,
          Header = 1,
          Cookie = 2,
          ConnectionProperties = 3,
        }
        private PolicySpecifierOneofCase policySpecifierCase_ = PolicySpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PolicySpecifierOneofCase PolicySpecifierCase {
          get { return policySpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearPolicySpecifier() {
          policySpecifierCase_ = PolicySpecifierOneofCase.None;
          policySpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HashPolicy);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HashPolicy other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Header, other.Header)) return false;
          if (!object.Equals(Cookie, other.Cookie)) return false;
          if (!object.Equals(ConnectionProperties, other.ConnectionProperties)) return false;
          if (Terminal != other.Terminal) return false;
          if (PolicySpecifierCase != other.PolicySpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) hash ^= Header.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) hash ^= Cookie.GetHashCode();
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) hash ^= ConnectionProperties.GetHashCode();
          if (Terminal != false) hash ^= Terminal.GetHashCode();
          hash ^= (int) policySpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
            output.WriteRawTag(10);
            output.WriteMessage(Header);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
            output.WriteRawTag(18);
            output.WriteMessage(Cookie);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
            output.WriteRawTag(26);
            output.WriteMessage(ConnectionProperties);
          }
          if (Terminal != false) {
            output.WriteRawTag(32);
            output.WriteBool(Terminal);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cookie);
          }
          if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectionProperties);
          }
          if (Terminal != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HashPolicy other) {
          if (other == null) {
            return;
          }
          if (other.Terminal != false) {
            Terminal = other.Terminal;
          }
          switch (other.PolicySpecifierCase) {
            case PolicySpecifierOneofCase.Header:
              if (Header == null) {
                Header = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header();
              }
              Header.MergeFrom(other.Header);
              break;
            case PolicySpecifierOneofCase.Cookie:
              if (Cookie == null) {
                Cookie = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie();
              }
              Cookie.MergeFrom(other.Cookie);
              break;
            case PolicySpecifierOneofCase.ConnectionProperties:
              if (ConnectionProperties == null) {
                ConnectionProperties = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties();
              }
              ConnectionProperties.MergeFrom(other.ConnectionProperties);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header subBuilder = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Header();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.Header) {
                  subBuilder.MergeFrom(Header);
                }
                input.ReadMessage(subBuilder);
                Header = subBuilder;
                break;
              }
              case 18: {
                global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie subBuilder = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.Cookie();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.Cookie) {
                  subBuilder.MergeFrom(Cookie);
                }
                input.ReadMessage(subBuilder);
                Cookie = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties subBuilder = new global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Types.ConnectionProperties();
                if (policySpecifierCase_ == PolicySpecifierOneofCase.ConnectionProperties) {
                  subBuilder.MergeFrom(ConnectionProperties);
                }
                input.ReadMessage(subBuilder);
                ConnectionProperties = subBuilder;
                break;
              }
              case 32: {
                Terminal = input.ReadBool();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the HashPolicy message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class Header : pb::IMessage<Header> {
            private static readonly pb::MessageParser<Header> _parser = new pb::MessageParser<Header>(() => new Header());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Header> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Header() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Header(Header other) : this() {
              headerName_ = other.headerName_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Header Clone() {
              return new Header(this);
            }

            /// <summary>Field number for the "header_name" field.</summary>
            public const int HeaderNameFieldNumber = 1;
            private string headerName_ = "";
            /// <summary>
            /// The name of the request header that will be used to obtain the hash
            /// key. If the request header is not present, no hash will be produced.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string HeaderName {
              get { return headerName_; }
              set {
                headerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Header);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Header other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (HeaderName != other.HeaderName) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (HeaderName.Length != 0) hash ^= HeaderName.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (HeaderName.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(HeaderName);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (HeaderName.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(HeaderName);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Header other) {
              if (other == null) {
                return;
              }
              if (other.HeaderName.Length != 0) {
                HeaderName = other.HeaderName;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    HeaderName = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// Envoy supports two types of cookie affinity:
          ///
          /// 1. Passive. Envoy takes a cookie that's present in the cookies header and
          ///    hashes on its value.
          ///
          /// 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
          ///    on the first request from the client in its response to the client,
          ///    based on the endpoint the request gets sent to. The client then
          ///    presents this on the next and all subsequent requests. The hash of
          ///    this is sufficient to ensure these requests get sent to the same
          ///    endpoint. The cookie is generated by hashing the source and
          ///    destination ports and addresses so that multiple independent HTTP2
          ///    streams on the same connection will independently receive the same
          ///    cookie, even if they arrive at the Envoy simultaneously.
          /// </summary>
          public sealed partial class Cookie : pb::IMessage<Cookie> {
            private static readonly pb::MessageParser<Cookie> _parser = new pb::MessageParser<Cookie>(() => new Cookie());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Cookie> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Cookie() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Cookie(Cookie other) : this() {
              name_ = other.name_;
              ttl_ = other.ttl_ != null ? other.ttl_.Clone() : null;
              path_ = other.path_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Cookie Clone() {
              return new Cookie(this);
            }

            /// <summary>Field number for the "name" field.</summary>
            public const int NameFieldNumber = 1;
            private string name_ = "";
            /// <summary>
            /// The name of the cookie that will be used to obtain the hash key. If the
            /// cookie is not present and ttl below is not set, no hash will be
            /// produced.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Name {
              get { return name_; }
              set {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "ttl" field.</summary>
            public const int TtlFieldNumber = 2;
            private global::Google.Protobuf.WellKnownTypes.Duration ttl_;
            /// <summary>
            /// If specified, a cookie with the TTL will be generated if the cookie is
            /// not present. If the TTL is present and zero, the generated cookie will
            /// be a session cookie.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Google.Protobuf.WellKnownTypes.Duration Ttl {
              get { return ttl_; }
              set {
                ttl_ = value;
              }
            }

            /// <summary>Field number for the "path" field.</summary>
            public const int PathFieldNumber = 3;
            private string path_ = "";
            /// <summary>
            /// The name of the path for the cookie. If no path is specified here, no path
            /// will be set for the cookie.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Path {
              get { return path_; }
              set {
                path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Cookie);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Cookie other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Name != other.Name) return false;
              if (!object.Equals(Ttl, other.Ttl)) return false;
              if (Path != other.Path) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Name.Length != 0) hash ^= Name.GetHashCode();
              if (ttl_ != null) hash ^= Ttl.GetHashCode();
              if (Path.Length != 0) hash ^= Path.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              if (ttl_ != null) {
                output.WriteRawTag(18);
                output.WriteMessage(Ttl);
              }
              if (Path.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(Path);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Name.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
              }
              if (ttl_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ttl);
              }
              if (Path.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Cookie other) {
              if (other == null) {
                return;
              }
              if (other.Name.Length != 0) {
                Name = other.Name;
              }
              if (other.ttl_ != null) {
                if (ttl_ == null) {
                  Ttl = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                Ttl.MergeFrom(other.Ttl);
              }
              if (other.Path.Length != 0) {
                Path = other.Path;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                  case 18: {
                    if (ttl_ == null) {
                      Ttl = new global::Google.Protobuf.WellKnownTypes.Duration();
                    }
                    input.ReadMessage(Ttl);
                    break;
                  }
                  case 26: {
                    Path = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

          public sealed partial class ConnectionProperties : pb::IMessage<ConnectionProperties> {
            private static readonly pb::MessageParser<ConnectionProperties> _parser = new pb::MessageParser<ConnectionProperties>(() => new ConnectionProperties());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<ConnectionProperties> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RouteAction.Types.HashPolicy.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ConnectionProperties() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ConnectionProperties(ConnectionProperties other) : this() {
              sourceIp_ = other.sourceIp_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ConnectionProperties Clone() {
              return new ConnectionProperties(this);
            }

            /// <summary>Field number for the "source_ip" field.</summary>
            public const int SourceIpFieldNumber = 1;
            private bool sourceIp_;
            /// <summary>
            /// Hash on source IP address.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool SourceIp {
              get { return sourceIp_; }
              set {
                sourceIp_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as ConnectionProperties);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(ConnectionProperties other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (SourceIp != other.SourceIp) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (SourceIp != false) hash ^= SourceIp.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (SourceIp != false) {
                output.WriteRawTag(8);
                output.WriteBool(SourceIp);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (SourceIp != false) {
                size += 1 + 1;
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(ConnectionProperties other) {
              if (other == null) {
                return;
              }
              if (other.SourceIp != false) {
                SourceIp = other.SourceIp;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    SourceIp = input.ReadBool();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Allows enabling and disabling upgrades on a per-route basis.
      /// This overrides any enabled/disabled upgrade filter chain specified in the
      /// HttpConnectionManager
      /// :ref:upgrade_configs`
      /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.upgrade_configs>`
      /// but does not affect any custom filter chain specified there.
      /// </summary>
      public sealed partial class UpgradeConfig : pb::IMessage<UpgradeConfig> {
        private static readonly pb::MessageParser<UpgradeConfig> _parser = new pb::MessageParser<UpgradeConfig>(() => new UpgradeConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<UpgradeConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RouteAction.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public UpgradeConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public UpgradeConfig(UpgradeConfig other) : this() {
          upgradeType_ = other.upgradeType_;
          Enabled = other.Enabled;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public UpgradeConfig Clone() {
          return new UpgradeConfig(this);
        }

        /// <summary>Field number for the "upgrade_type" field.</summary>
        public const int UpgradeTypeFieldNumber = 1;
        private string upgradeType_ = "";
        /// <summary>
        /// The case-insensitive name of this upgrade, e.g. "websocket".
        /// For each upgrade type present in upgrade_configs, requests with
        /// Upgrade: [upgrade_type] will be proxied upstream.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string UpgradeType {
          get { return upgradeType_; }
          set {
            upgradeType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "enabled" field.</summary>
        public const int EnabledFieldNumber = 2;
        private static readonly pb::FieldCodec<bool?> _single_enabled_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
        private bool? enabled_;
        /// <summary>
        /// Determines if upgrades are available on this route. Defaults to true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? Enabled {
          get { return enabled_; }
          set {
            enabled_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as UpgradeConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(UpgradeConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UpgradeType != other.UpgradeType) return false;
          if (Enabled != other.Enabled) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (UpgradeType.Length != 0) hash ^= UpgradeType.GetHashCode();
          if (enabled_ != null) hash ^= Enabled.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (UpgradeType.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(UpgradeType);
          }
          if (enabled_ != null) {
            _single_enabled_codec.WriteTagAndValue(output, Enabled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (UpgradeType.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(UpgradeType);
          }
          if (enabled_ != null) {
            size += _single_enabled_codec.CalculateSizeWithTag(Enabled);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(UpgradeConfig other) {
          if (other == null) {
            return;
          }
          if (other.UpgradeType.Length != 0) {
            UpgradeType = other.UpgradeType;
          }
          if (other.enabled_ != null) {
            if (enabled_ == null || other.Enabled != false) {
              Enabled = other.Enabled;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                UpgradeType = input.ReadString();
                break;
              }
              case 18: {
                bool? value = _single_enabled_codec.Read(input);
                if (enabled_ == null || value != false) {
                  Enabled = value;
                }
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// HTTP retry :ref:`architecture overview &lt;arch_overview_http_routing_retry>`.
  /// [#comment:next free field: 9]
  /// </summary>
  public sealed partial class RetryPolicy : pb::IMessage<RetryPolicy> {
    private static readonly pb::MessageParser<RetryPolicy> _parser = new pb::MessageParser<RetryPolicy>(() => new RetryPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RetryPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RetryPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RetryPolicy(RetryPolicy other) : this() {
      retryOn_ = other.retryOn_;
      NumRetries = other.NumRetries;
      perTryTimeout_ = other.perTryTimeout_ != null ? other.perTryTimeout_.Clone() : null;
      retryPriority_ = other.retryPriority_ != null ? other.retryPriority_.Clone() : null;
      retryHostPredicate_ = other.retryHostPredicate_.Clone();
      hostSelectionRetryMaxAttempts_ = other.hostSelectionRetryMaxAttempts_;
      retriableStatusCodes_ = other.retriableStatusCodes_.Clone();
      retryBackOff_ = other.retryBackOff_ != null ? other.retryBackOff_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RetryPolicy Clone() {
      return new RetryPolicy(this);
    }

    /// <summary>Field number for the "retry_on" field.</summary>
    public const int RetryOnFieldNumber = 1;
    private string retryOn_ = "";
    /// <summary>
    /// Specifies the conditions under which retry takes place. These are the same
    /// conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
    /// :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RetryOn {
      get { return retryOn_; }
      set {
        retryOn_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "num_retries" field.</summary>
    public const int NumRetriesFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_numRetries_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? numRetries_;
    /// <summary>
    /// Specifies the allowed number of retries. This parameter is optional and
    /// defaults to 1. These are the same conditions documented for
    /// :ref:`config_http_filters_router_x-envoy-max-retries`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? NumRetries {
      get { return numRetries_; }
      set {
        numRetries_ = value;
      }
    }


    /// <summary>Field number for the "per_try_timeout" field.</summary>
    public const int PerTryTimeoutFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration perTryTimeout_;
    /// <summary>
    /// Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The
    /// same conditions documented for
    /// :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
    ///
    /// .. note::
    ///
    ///   If left unspecified, Envoy will use the global
    ///   :ref:`route timeout &lt;envoy_api_field_route.RouteAction.timeout>` for the request.
    ///   Consequently, when using a :ref:`5xx &lt;config_http_filters_router_x-envoy-retry-on>` based
    ///   retry policy, a request that times out will not be retried as the total timeout budget
    ///   would have been exhausted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration PerTryTimeout {
      get { return perTryTimeout_; }
      set {
        perTryTimeout_ = value;
      }
    }

    /// <summary>Field number for the "retry_priority" field.</summary>
    public const int RetryPriorityFieldNumber = 4;
    private global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryPriority retryPriority_;
    /// <summary>
    /// Specifies an implementation of a RetryPriority which is used to determine the
    /// distribution of load across priorities used for retries. Refer to
    /// :ref:`retry plugin configuration &lt;arch_overview_http_retry_plugins>` for more details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryPriority RetryPriority {
      get { return retryPriority_; }
      set {
        retryPriority_ = value;
      }
    }

    /// <summary>Field number for the "retry_host_predicate" field.</summary>
    public const int RetryHostPredicateFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryHostPredicate> _repeated_retryHostPredicate_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryHostPredicate.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryHostPredicate> retryHostPredicate_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryHostPredicate>();
    /// <summary>
    /// Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
    /// for retries. If any of the predicates reject the host, host selection will be reattempted.
    /// Refer to :ref:`retry plugin configuration &lt;arch_overview_http_retry_plugins>` for more
    /// details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryHostPredicate> RetryHostPredicate {
      get { return retryHostPredicate_; }
    }

    /// <summary>Field number for the "host_selection_retry_max_attempts" field.</summary>
    public const int HostSelectionRetryMaxAttemptsFieldNumber = 6;
    private long hostSelectionRetryMaxAttempts_;
    /// <summary>
    /// The maximum number of times host selection will be reattempted before giving up, at which
    /// point the host that was last selected will be routed to. If unspecified, this will default to
    /// retrying once.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long HostSelectionRetryMaxAttempts {
      get { return hostSelectionRetryMaxAttempts_; }
      set {
        hostSelectionRetryMaxAttempts_ = value;
      }
    }

    /// <summary>Field number for the "retriable_status_codes" field.</summary>
    public const int RetriableStatusCodesFieldNumber = 7;
    private static readonly pb::FieldCodec<uint> _repeated_retriableStatusCodes_codec
        = pb::FieldCodec.ForUInt32(58);
    private readonly pbc::RepeatedField<uint> retriableStatusCodes_ = new pbc::RepeatedField<uint>();
    /// <summary>
    /// HTTP status codes that should trigger a retry in addition to those specified by retry_on.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<uint> RetriableStatusCodes {
      get { return retriableStatusCodes_; }
    }

    /// <summary>Field number for the "retry_back_off" field.</summary>
    public const int RetryBackOffFieldNumber = 8;
    private global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryBackOff retryBackOff_;
    /// <summary>
    /// Specifies parameters that control retry back off. This parameter is optional, in which case the
    /// default base interval is 25 milliseconds or, if set, the current value of the
    /// `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times
    /// the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
    /// describes Envoy's back-off algorithm.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryBackOff RetryBackOff {
      get { return retryBackOff_; }
      set {
        retryBackOff_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RetryPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RetryPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RetryOn != other.RetryOn) return false;
      if (NumRetries != other.NumRetries) return false;
      if (!object.Equals(PerTryTimeout, other.PerTryTimeout)) return false;
      if (!object.Equals(RetryPriority, other.RetryPriority)) return false;
      if(!retryHostPredicate_.Equals(other.retryHostPredicate_)) return false;
      if (HostSelectionRetryMaxAttempts != other.HostSelectionRetryMaxAttempts) return false;
      if(!retriableStatusCodes_.Equals(other.retriableStatusCodes_)) return false;
      if (!object.Equals(RetryBackOff, other.RetryBackOff)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (RetryOn.Length != 0) hash ^= RetryOn.GetHashCode();
      if (numRetries_ != null) hash ^= NumRetries.GetHashCode();
      if (perTryTimeout_ != null) hash ^= PerTryTimeout.GetHashCode();
      if (retryPriority_ != null) hash ^= RetryPriority.GetHashCode();
      hash ^= retryHostPredicate_.GetHashCode();
      if (HostSelectionRetryMaxAttempts != 0L) hash ^= HostSelectionRetryMaxAttempts.GetHashCode();
      hash ^= retriableStatusCodes_.GetHashCode();
      if (retryBackOff_ != null) hash ^= RetryBackOff.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (RetryOn.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(RetryOn);
      }
      if (numRetries_ != null) {
        _single_numRetries_codec.WriteTagAndValue(output, NumRetries);
      }
      if (perTryTimeout_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PerTryTimeout);
      }
      if (retryPriority_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(RetryPriority);
      }
      retryHostPredicate_.WriteTo(output, _repeated_retryHostPredicate_codec);
      if (HostSelectionRetryMaxAttempts != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(HostSelectionRetryMaxAttempts);
      }
      retriableStatusCodes_.WriteTo(output, _repeated_retriableStatusCodes_codec);
      if (retryBackOff_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(RetryBackOff);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (RetryOn.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RetryOn);
      }
      if (numRetries_ != null) {
        size += _single_numRetries_codec.CalculateSizeWithTag(NumRetries);
      }
      if (perTryTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PerTryTimeout);
      }
      if (retryPriority_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryPriority);
      }
      size += retryHostPredicate_.CalculateSize(_repeated_retryHostPredicate_codec);
      if (HostSelectionRetryMaxAttempts != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(HostSelectionRetryMaxAttempts);
      }
      size += retriableStatusCodes_.CalculateSize(_repeated_retriableStatusCodes_codec);
      if (retryBackOff_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RetryBackOff);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RetryPolicy other) {
      if (other == null) {
        return;
      }
      if (other.RetryOn.Length != 0) {
        RetryOn = other.RetryOn;
      }
      if (other.numRetries_ != null) {
        if (numRetries_ == null || other.NumRetries != 0) {
          NumRetries = other.NumRetries;
        }
      }
      if (other.perTryTimeout_ != null) {
        if (perTryTimeout_ == null) {
          PerTryTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        PerTryTimeout.MergeFrom(other.PerTryTimeout);
      }
      if (other.retryPriority_ != null) {
        if (retryPriority_ == null) {
          RetryPriority = new global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryPriority();
        }
        RetryPriority.MergeFrom(other.RetryPriority);
      }
      retryHostPredicate_.Add(other.retryHostPredicate_);
      if (other.HostSelectionRetryMaxAttempts != 0L) {
        HostSelectionRetryMaxAttempts = other.HostSelectionRetryMaxAttempts;
      }
      retriableStatusCodes_.Add(other.retriableStatusCodes_);
      if (other.retryBackOff_ != null) {
        if (retryBackOff_ == null) {
          RetryBackOff = new global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryBackOff();
        }
        RetryBackOff.MergeFrom(other.RetryBackOff);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            RetryOn = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_numRetries_codec.Read(input);
            if (numRetries_ == null || value != 0) {
              NumRetries = value;
            }
            break;
          }
          case 26: {
            if (perTryTimeout_ == null) {
              PerTryTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(PerTryTimeout);
            break;
          }
          case 34: {
            if (retryPriority_ == null) {
              RetryPriority = new global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryPriority();
            }
            input.ReadMessage(RetryPriority);
            break;
          }
          case 42: {
            retryHostPredicate_.AddEntriesFrom(input, _repeated_retryHostPredicate_codec);
            break;
          }
          case 48: {
            HostSelectionRetryMaxAttempts = input.ReadInt64();
            break;
          }
          case 58:
          case 56: {
            retriableStatusCodes_.AddEntriesFrom(input, _repeated_retriableStatusCodes_codec);
            break;
          }
          case 66: {
            if (retryBackOff_ == null) {
              RetryBackOff = new global::Envoy.Api.V2.Route.RetryPolicy.Types.RetryBackOff();
            }
            input.ReadMessage(RetryBackOff);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RetryPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class RetryPriority : pb::IMessage<RetryPriority> {
        private static readonly pb::MessageParser<RetryPriority> _parser = new pb::MessageParser<RetryPriority>(() => new RetryPriority());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RetryPriority> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RetryPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPriority() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPriority(RetryPriority other) : this() {
          name_ = other.name_;
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.Config:
              Config = other.Config.Clone();
              break;
            case ConfigTypeOneofCase.TypedConfig:
              TypedConfig = other.TypedConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryPriority Clone() {
          return new RetryPriority(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "config" field.</summary>
        public const int ConfigFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Struct Config {
          get { return configTypeCase_ == ConfigTypeOneofCase.Config ? (global::Google.Protobuf.WellKnownTypes.Struct) configType_ : null; }
          set {
            configType_ = value;
            configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.Config;
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return configTypeCase_ == ConfigTypeOneofCase.TypedConfig ? (global::Google.Protobuf.WellKnownTypes.Any) configType_ : null; }
          set {
            configType_ = value;
            configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.TypedConfig;
          }
        }

        private object configType_;
        /// <summary>Enum of possible cases for the "config_type" oneof.</summary>
        public enum ConfigTypeOneofCase {
          None = 0,
          Config = 2,
          TypedConfig = 3,
        }
        private ConfigTypeOneofCase configTypeCase_ = ConfigTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ConfigTypeOneofCase ConfigTypeCase {
          get { return configTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearConfigType() {
          configTypeCase_ = ConfigTypeOneofCase.None;
          configType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RetryPriority);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RetryPriority other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Config, other.Config)) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          if (ConfigTypeCase != other.ConfigTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (configTypeCase_ == ConfigTypeOneofCase.Config) hash ^= Config.GetHashCode();
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
          hash ^= (int) configTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.Config) {
            output.WriteRawTag(18);
            output.WriteMessage(Config);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.Config) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RetryPriority other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.Config:
              if (Config == null) {
                Config = new global::Google.Protobuf.WellKnownTypes.Struct();
              }
              Config.MergeFrom(other.Config);
              break;
            case ConfigTypeOneofCase.TypedConfig:
              if (TypedConfig == null) {
                TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
              }
              TypedConfig.MergeFrom(other.TypedConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                global::Google.Protobuf.WellKnownTypes.Struct subBuilder = new global::Google.Protobuf.WellKnownTypes.Struct();
                if (configTypeCase_ == ConfigTypeOneofCase.Config) {
                  subBuilder.MergeFrom(Config);
                }
                input.ReadMessage(subBuilder);
                Config = subBuilder;
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
                if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        }

      }

      public sealed partial class RetryHostPredicate : pb::IMessage<RetryHostPredicate> {
        private static readonly pb::MessageParser<RetryHostPredicate> _parser = new pb::MessageParser<RetryHostPredicate>(() => new RetryHostPredicate());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RetryHostPredicate> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RetryPolicy.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryHostPredicate() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryHostPredicate(RetryHostPredicate other) : this() {
          name_ = other.name_;
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.Config:
              Config = other.Config.Clone();
              break;
            case ConfigTypeOneofCase.TypedConfig:
              TypedConfig = other.TypedConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryHostPredicate Clone() {
          return new RetryHostPredicate(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "config" field.</summary>
        public const int ConfigFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Struct Config {
          get { return configTypeCase_ == ConfigTypeOneofCase.Config ? (global::Google.Protobuf.WellKnownTypes.Struct) configType_ : null; }
          set {
            configType_ = value;
            configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.Config;
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return configTypeCase_ == ConfigTypeOneofCase.TypedConfig ? (global::Google.Protobuf.WellKnownTypes.Any) configType_ : null; }
          set {
            configType_ = value;
            configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.TypedConfig;
          }
        }

        private object configType_;
        /// <summary>Enum of possible cases for the "config_type" oneof.</summary>
        public enum ConfigTypeOneofCase {
          None = 0,
          Config = 2,
          TypedConfig = 3,
        }
        private ConfigTypeOneofCase configTypeCase_ = ConfigTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ConfigTypeOneofCase ConfigTypeCase {
          get { return configTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearConfigType() {
          configTypeCase_ = ConfigTypeOneofCase.None;
          configType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RetryHostPredicate);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RetryHostPredicate other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Config, other.Config)) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          if (ConfigTypeCase != other.ConfigTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (configTypeCase_ == ConfigTypeOneofCase.Config) hash ^= Config.GetHashCode();
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
          hash ^= (int) configTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.Config) {
            output.WriteRawTag(18);
            output.WriteMessage(Config);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.Config) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RetryHostPredicate other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.Config:
              if (Config == null) {
                Config = new global::Google.Protobuf.WellKnownTypes.Struct();
              }
              Config.MergeFrom(other.Config);
              break;
            case ConfigTypeOneofCase.TypedConfig:
              if (TypedConfig == null) {
                TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
              }
              TypedConfig.MergeFrom(other.TypedConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                global::Google.Protobuf.WellKnownTypes.Struct subBuilder = new global::Google.Protobuf.WellKnownTypes.Struct();
                if (configTypeCase_ == ConfigTypeOneofCase.Config) {
                  subBuilder.MergeFrom(Config);
                }
                input.ReadMessage(subBuilder);
                Config = subBuilder;
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
                if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        }

      }

      public sealed partial class RetryBackOff : pb::IMessage<RetryBackOff> {
        private static readonly pb::MessageParser<RetryBackOff> _parser = new pb::MessageParser<RetryBackOff>(() => new RetryBackOff());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RetryBackOff> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RetryPolicy.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryBackOff() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryBackOff(RetryBackOff other) : this() {
          baseInterval_ = other.baseInterval_ != null ? other.baseInterval_.Clone() : null;
          maxInterval_ = other.maxInterval_ != null ? other.maxInterval_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RetryBackOff Clone() {
          return new RetryBackOff(this);
        }

        /// <summary>Field number for the "base_interval" field.</summary>
        public const int BaseIntervalFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration baseInterval_;
        /// <summary>
        /// Specifies the base interval between retries. This parameter is required and must be greater
        /// than zero. Values less than 1 ms are rounded up to 1 ms.
        /// See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
        /// back-off algorithm.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration BaseInterval {
          get { return baseInterval_; }
          set {
            baseInterval_ = value;
          }
        }

        /// <summary>Field number for the "max_interval" field.</summary>
        public const int MaxIntervalFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Duration maxInterval_;
        /// <summary>
        /// Specifies the maximum interval between retries. This parameter is optional, but must be
        /// greater than or equal to the `base_interval` if set. The default is 10 times the
        /// `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
        /// of Envoy's back-off algorithm.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration MaxInterval {
          get { return maxInterval_; }
          set {
            maxInterval_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RetryBackOff);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RetryBackOff other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(BaseInterval, other.BaseInterval)) return false;
          if (!object.Equals(MaxInterval, other.MaxInterval)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (baseInterval_ != null) hash ^= BaseInterval.GetHashCode();
          if (maxInterval_ != null) hash ^= MaxInterval.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (baseInterval_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(BaseInterval);
          }
          if (maxInterval_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(MaxInterval);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (baseInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BaseInterval);
          }
          if (maxInterval_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaxInterval);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RetryBackOff other) {
          if (other == null) {
            return;
          }
          if (other.baseInterval_ != null) {
            if (baseInterval_ == null) {
              BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            BaseInterval.MergeFrom(other.BaseInterval);
          }
          if (other.maxInterval_ != null) {
            if (maxInterval_ == null) {
              MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            MaxInterval.MergeFrom(other.MaxInterval);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (baseInterval_ == null) {
                  BaseInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BaseInterval);
                break;
              }
              case 18: {
                if (maxInterval_ == null) {
                  MaxInterval = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(MaxInterval);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// HTTP request hedging :ref:`architecture overview &lt;arch_overview_http_routing_hedging>`.
  /// </summary>
  public sealed partial class HedgePolicy : pb::IMessage<HedgePolicy> {
    private static readonly pb::MessageParser<HedgePolicy> _parser = new pb::MessageParser<HedgePolicy>(() => new HedgePolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HedgePolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HedgePolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HedgePolicy(HedgePolicy other) : this() {
      InitialRequests = other.InitialRequests;
      additionalRequestChance_ = other.additionalRequestChance_ != null ? other.additionalRequestChance_.Clone() : null;
      hedgeOnPerTryTimeout_ = other.hedgeOnPerTryTimeout_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HedgePolicy Clone() {
      return new HedgePolicy(this);
    }

    /// <summary>Field number for the "initial_requests" field.</summary>
    public const int InitialRequestsFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_initialRequests_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? initialRequests_;
    /// <summary>
    /// Specifies the number of initial requests that should be sent upstream.
    /// Must be at least 1.
    /// Defaults to 1.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? InitialRequests {
      get { return initialRequests_; }
      set {
        initialRequests_ = value;
      }
    }


    /// <summary>Field number for the "additional_request_chance" field.</summary>
    public const int AdditionalRequestChanceFieldNumber = 2;
    private global::Envoy.Type.FractionalPercent additionalRequestChance_;
    /// <summary>
    /// Specifies a probability that an additional upstream request should be sent
    /// on top of what is specified by initial_requests.
    /// Defaults to 0.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.FractionalPercent AdditionalRequestChance {
      get { return additionalRequestChance_; }
      set {
        additionalRequestChance_ = value;
      }
    }

    /// <summary>Field number for the "hedge_on_per_try_timeout" field.</summary>
    public const int HedgeOnPerTryTimeoutFieldNumber = 3;
    private bool hedgeOnPerTryTimeout_;
    /// <summary>
    /// Indicates that a hedged request should be sent when the per-try timeout
    /// is hit. This will only occur if the retry policy also indicates that a
    /// timed out request should be retried.
    /// Once a timed out request is retried due to per try timeout, the router
    /// filter will ensure that it is not retried again even if the returned
    /// response headers would otherwise be retried according the specified
    /// :ref:`RetryPolicy &lt;envoy_api_msg_route.RetryPolicy>`.
    /// Defaults to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HedgeOnPerTryTimeout {
      get { return hedgeOnPerTryTimeout_; }
      set {
        hedgeOnPerTryTimeout_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HedgePolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HedgePolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (InitialRequests != other.InitialRequests) return false;
      if (!object.Equals(AdditionalRequestChance, other.AdditionalRequestChance)) return false;
      if (HedgeOnPerTryTimeout != other.HedgeOnPerTryTimeout) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (initialRequests_ != null) hash ^= InitialRequests.GetHashCode();
      if (additionalRequestChance_ != null) hash ^= AdditionalRequestChance.GetHashCode();
      if (HedgeOnPerTryTimeout != false) hash ^= HedgeOnPerTryTimeout.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (initialRequests_ != null) {
        _single_initialRequests_codec.WriteTagAndValue(output, InitialRequests);
      }
      if (additionalRequestChance_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AdditionalRequestChance);
      }
      if (HedgeOnPerTryTimeout != false) {
        output.WriteRawTag(24);
        output.WriteBool(HedgeOnPerTryTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (initialRequests_ != null) {
        size += _single_initialRequests_codec.CalculateSizeWithTag(InitialRequests);
      }
      if (additionalRequestChance_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AdditionalRequestChance);
      }
      if (HedgeOnPerTryTimeout != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HedgePolicy other) {
      if (other == null) {
        return;
      }
      if (other.initialRequests_ != null) {
        if (initialRequests_ == null || other.InitialRequests != 0) {
          InitialRequests = other.InitialRequests;
        }
      }
      if (other.additionalRequestChance_ != null) {
        if (additionalRequestChance_ == null) {
          AdditionalRequestChance = new global::Envoy.Type.FractionalPercent();
        }
        AdditionalRequestChance.MergeFrom(other.AdditionalRequestChance);
      }
      if (other.HedgeOnPerTryTimeout != false) {
        HedgeOnPerTryTimeout = other.HedgeOnPerTryTimeout;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_initialRequests_codec.Read(input);
            if (initialRequests_ == null || value != 0) {
              InitialRequests = value;
            }
            break;
          }
          case 18: {
            if (additionalRequestChance_ == null) {
              AdditionalRequestChance = new global::Envoy.Type.FractionalPercent();
            }
            input.ReadMessage(AdditionalRequestChance);
            break;
          }
          case 24: {
            HedgeOnPerTryTimeout = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class RedirectAction : pb::IMessage<RedirectAction> {
    private static readonly pb::MessageParser<RedirectAction> _parser = new pb::MessageParser<RedirectAction>(() => new RedirectAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RedirectAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedirectAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedirectAction(RedirectAction other) : this() {
      hostRedirect_ = other.hostRedirect_;
      portRedirect_ = other.portRedirect_;
      responseCode_ = other.responseCode_;
      stripQuery_ = other.stripQuery_;
      switch (other.SchemeRewriteSpecifierCase) {
        case SchemeRewriteSpecifierOneofCase.HttpsRedirect:
          HttpsRedirect = other.HttpsRedirect;
          break;
        case SchemeRewriteSpecifierOneofCase.SchemeRedirect:
          SchemeRedirect = other.SchemeRedirect;
          break;
      }

      switch (other.PathRewriteSpecifierCase) {
        case PathRewriteSpecifierOneofCase.PathRedirect:
          PathRedirect = other.PathRedirect;
          break;
        case PathRewriteSpecifierOneofCase.PrefixRewrite:
          PrefixRewrite = other.PrefixRewrite;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedirectAction Clone() {
      return new RedirectAction(this);
    }

    /// <summary>Field number for the "https_redirect" field.</summary>
    public const int HttpsRedirectFieldNumber = 4;
    /// <summary>
    /// The scheme portion of the URL will be swapped with "https".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HttpsRedirect {
      get { return schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect ? (bool) schemeRewriteSpecifier_ : false; }
      set {
        schemeRewriteSpecifier_ = value;
        schemeRewriteSpecifierCase_ = SchemeRewriteSpecifierOneofCase.HttpsRedirect;
      }
    }

    /// <summary>Field number for the "scheme_redirect" field.</summary>
    public const int SchemeRedirectFieldNumber = 7;
    /// <summary>
    /// The scheme portion of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SchemeRedirect {
      get { return schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect ? (string) schemeRewriteSpecifier_ : ""; }
      set {
        schemeRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        schemeRewriteSpecifierCase_ = SchemeRewriteSpecifierOneofCase.SchemeRedirect;
      }
    }

    /// <summary>Field number for the "host_redirect" field.</summary>
    public const int HostRedirectFieldNumber = 1;
    private string hostRedirect_ = "";
    /// <summary>
    /// The host portion of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HostRedirect {
      get { return hostRedirect_; }
      set {
        hostRedirect_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "port_redirect" field.</summary>
    public const int PortRedirectFieldNumber = 8;
    private uint portRedirect_;
    /// <summary>
    /// The port value of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PortRedirect {
      get { return portRedirect_; }
      set {
        portRedirect_ = value;
      }
    }

    /// <summary>Field number for the "path_redirect" field.</summary>
    public const int PathRedirectFieldNumber = 2;
    /// <summary>
    /// The path portion of the URL will be swapped with this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PathRedirect {
      get { return pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect ? (string) pathRewriteSpecifier_ : ""; }
      set {
        pathRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.PathRedirect;
      }
    }

    /// <summary>Field number for the "prefix_rewrite" field.</summary>
    public const int PrefixRewriteFieldNumber = 5;
    /// <summary>
    /// Indicates that during redirection, the matched prefix (or path)
    /// should be swapped with this value. This option allows redirect URLs be dynamically created
    /// based on the request.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the use of trailing slashes as mentioned in
    ///   :ref:`RouteAction's prefix_rewrite &lt;envoy_api_field_route.RouteAction.prefix_rewrite>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PrefixRewrite {
      get { return pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite ? (string) pathRewriteSpecifier_ : ""; }
      set {
        pathRewriteSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.PrefixRewrite;
      }
    }

    /// <summary>Field number for the "response_code" field.</summary>
    public const int ResponseCodeFieldNumber = 3;
    private global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode responseCode_ = global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode.MovedPermanently;
    /// <summary>
    /// The HTTP status code to use in the redirect response. The default response
    /// code is MOVED_PERMANENTLY (301).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode ResponseCode {
      get { return responseCode_; }
      set {
        responseCode_ = value;
      }
    }

    /// <summary>Field number for the "strip_query" field.</summary>
    public const int StripQueryFieldNumber = 6;
    private bool stripQuery_;
    /// <summary>
    /// Indicates that during redirection, the query portion of the URL will
    /// be removed. Default value is false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StripQuery {
      get { return stripQuery_; }
      set {
        stripQuery_ = value;
      }
    }

    private object schemeRewriteSpecifier_;
    /// <summary>Enum of possible cases for the "scheme_rewrite_specifier" oneof.</summary>
    public enum SchemeRewriteSpecifierOneofCase {
      None = 0,
      HttpsRedirect = 4,
      SchemeRedirect = 7,
    }
    private SchemeRewriteSpecifierOneofCase schemeRewriteSpecifierCase_ = SchemeRewriteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SchemeRewriteSpecifierOneofCase SchemeRewriteSpecifierCase {
      get { return schemeRewriteSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearSchemeRewriteSpecifier() {
      schemeRewriteSpecifierCase_ = SchemeRewriteSpecifierOneofCase.None;
      schemeRewriteSpecifier_ = null;
    }

    private object pathRewriteSpecifier_;
    /// <summary>Enum of possible cases for the "path_rewrite_specifier" oneof.</summary>
    public enum PathRewriteSpecifierOneofCase {
      None = 0,
      PathRedirect = 2,
      PrefixRewrite = 5,
    }
    private PathRewriteSpecifierOneofCase pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PathRewriteSpecifierOneofCase PathRewriteSpecifierCase {
      get { return pathRewriteSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPathRewriteSpecifier() {
      pathRewriteSpecifierCase_ = PathRewriteSpecifierOneofCase.None;
      pathRewriteSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RedirectAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RedirectAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HttpsRedirect != other.HttpsRedirect) return false;
      if (SchemeRedirect != other.SchemeRedirect) return false;
      if (HostRedirect != other.HostRedirect) return false;
      if (PortRedirect != other.PortRedirect) return false;
      if (PathRedirect != other.PathRedirect) return false;
      if (PrefixRewrite != other.PrefixRewrite) return false;
      if (ResponseCode != other.ResponseCode) return false;
      if (StripQuery != other.StripQuery) return false;
      if (SchemeRewriteSpecifierCase != other.SchemeRewriteSpecifierCase) return false;
      if (PathRewriteSpecifierCase != other.PathRewriteSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect) hash ^= HttpsRedirect.GetHashCode();
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect) hash ^= SchemeRedirect.GetHashCode();
      if (HostRedirect.Length != 0) hash ^= HostRedirect.GetHashCode();
      if (PortRedirect != 0) hash ^= PortRedirect.GetHashCode();
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) hash ^= PathRedirect.GetHashCode();
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) hash ^= PrefixRewrite.GetHashCode();
      if (ResponseCode != global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode.MovedPermanently) hash ^= ResponseCode.GetHashCode();
      if (StripQuery != false) hash ^= StripQuery.GetHashCode();
      hash ^= (int) schemeRewriteSpecifierCase_;
      hash ^= (int) pathRewriteSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HostRedirect.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(HostRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) {
        output.WriteRawTag(18);
        output.WriteString(PathRedirect);
      }
      if (ResponseCode != global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode.MovedPermanently) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ResponseCode);
      }
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect) {
        output.WriteRawTag(32);
        output.WriteBool(HttpsRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) {
        output.WriteRawTag(42);
        output.WriteString(PrefixRewrite);
      }
      if (StripQuery != false) {
        output.WriteRawTag(48);
        output.WriteBool(StripQuery);
      }
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect) {
        output.WriteRawTag(58);
        output.WriteString(SchemeRedirect);
      }
      if (PortRedirect != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(PortRedirect);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.HttpsRedirect) {
        size += 1 + 1;
      }
      if (schemeRewriteSpecifierCase_ == SchemeRewriteSpecifierOneofCase.SchemeRedirect) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SchemeRedirect);
      }
      if (HostRedirect.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostRedirect);
      }
      if (PortRedirect != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PortRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PathRedirect) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PathRedirect);
      }
      if (pathRewriteSpecifierCase_ == PathRewriteSpecifierOneofCase.PrefixRewrite) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixRewrite);
      }
      if (ResponseCode != global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode.MovedPermanently) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ResponseCode);
      }
      if (StripQuery != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RedirectAction other) {
      if (other == null) {
        return;
      }
      if (other.HostRedirect.Length != 0) {
        HostRedirect = other.HostRedirect;
      }
      if (other.PortRedirect != 0) {
        PortRedirect = other.PortRedirect;
      }
      if (other.ResponseCode != global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode.MovedPermanently) {
        ResponseCode = other.ResponseCode;
      }
      if (other.StripQuery != false) {
        StripQuery = other.StripQuery;
      }
      switch (other.SchemeRewriteSpecifierCase) {
        case SchemeRewriteSpecifierOneofCase.HttpsRedirect:
          HttpsRedirect = other.HttpsRedirect;
          break;
        case SchemeRewriteSpecifierOneofCase.SchemeRedirect:
          SchemeRedirect = other.SchemeRedirect;
          break;
      }

      switch (other.PathRewriteSpecifierCase) {
        case PathRewriteSpecifierOneofCase.PathRedirect:
          PathRedirect = other.PathRedirect;
          break;
        case PathRewriteSpecifierOneofCase.PrefixRewrite:
          PrefixRewrite = other.PrefixRewrite;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            HostRedirect = input.ReadString();
            break;
          }
          case 18: {
            PathRedirect = input.ReadString();
            break;
          }
          case 24: {
            ResponseCode = (global::Envoy.Api.V2.Route.RedirectAction.Types.RedirectResponseCode) input.ReadEnum();
            break;
          }
          case 32: {
            HttpsRedirect = input.ReadBool();
            break;
          }
          case 42: {
            PrefixRewrite = input.ReadString();
            break;
          }
          case 48: {
            StripQuery = input.ReadBool();
            break;
          }
          case 58: {
            SchemeRedirect = input.ReadString();
            break;
          }
          case 64: {
            PortRedirect = input.ReadUInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RedirectAction message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum RedirectResponseCode {
        /// <summary>
        /// Moved Permanently HTTP Status Code - 301.
        /// </summary>
        [pbr::OriginalName("MOVED_PERMANENTLY")] MovedPermanently = 0,
        /// <summary>
        /// Found HTTP Status Code - 302.
        /// </summary>
        [pbr::OriginalName("FOUND")] Found = 1,
        /// <summary>
        /// See Other HTTP Status Code - 303.
        /// </summary>
        [pbr::OriginalName("SEE_OTHER")] SeeOther = 2,
        /// <summary>
        /// Temporary Redirect HTTP Status Code - 307.
        /// </summary>
        [pbr::OriginalName("TEMPORARY_REDIRECT")] TemporaryRedirect = 3,
        /// <summary>
        /// Permanent Redirect HTTP Status Code - 308.
        /// </summary>
        [pbr::OriginalName("PERMANENT_REDIRECT")] PermanentRedirect = 4,
      }

    }
    #endregion

  }

  public sealed partial class DirectResponseAction : pb::IMessage<DirectResponseAction> {
    private static readonly pb::MessageParser<DirectResponseAction> _parser = new pb::MessageParser<DirectResponseAction>(() => new DirectResponseAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DirectResponseAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DirectResponseAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DirectResponseAction(DirectResponseAction other) : this() {
      status_ = other.status_;
      body_ = other.body_ != null ? other.body_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DirectResponseAction Clone() {
      return new DirectResponseAction(this);
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 1;
    private uint status_;
    /// <summary>
    /// Specifies the HTTP response status to be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    /// <summary>Field number for the "body" field.</summary>
    public const int BodyFieldNumber = 2;
    private global::Envoy.Api.V2.Core.DataSource body_;
    /// <summary>
    /// Specifies the content of the response body. If this setting is omitted,
    /// no body is included in the generated response.
    ///
    /// .. note::
    ///
    ///   Headers can be specified using *response_headers_to_add* in the enclosing
    ///   :ref:`envoy_api_msg_route.Route`, :ref:`envoy_api_msg_RouteConfiguration` or
    ///   :ref:`envoy_api_msg_route.VirtualHost`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.DataSource Body {
      get { return body_; }
      set {
        body_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DirectResponseAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DirectResponseAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Status != other.Status) return false;
      if (!object.Equals(Body, other.Body)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Status != 0) hash ^= Status.GetHashCode();
      if (body_ != null) hash ^= Body.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Status != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(Status);
      }
      if (body_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Body);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Status != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Status);
      }
      if (body_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Body);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DirectResponseAction other) {
      if (other == null) {
        return;
      }
      if (other.Status != 0) {
        Status = other.Status;
      }
      if (other.body_ != null) {
        if (body_ == null) {
          Body = new global::Envoy.Api.V2.Core.DataSource();
        }
        Body.MergeFrom(other.Body);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Status = input.ReadUInt32();
            break;
          }
          case 18: {
            if (body_ == null) {
              Body = new global::Envoy.Api.V2.Core.DataSource();
            }
            input.ReadMessage(Body);
            break;
          }
        }
      }
    }

  }

  public sealed partial class Decorator : pb::IMessage<Decorator> {
    private static readonly pb::MessageParser<Decorator> _parser = new pb::MessageParser<Decorator>(() => new Decorator());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Decorator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Decorator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Decorator(Decorator other) : this() {
      operation_ = other.operation_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Decorator Clone() {
      return new Decorator(this);
    }

    /// <summary>Field number for the "operation" field.</summary>
    public const int OperationFieldNumber = 1;
    private string operation_ = "";
    /// <summary>
    /// The operation name associated with the request matched to this route. If tracing is
    /// enabled, this information will be used as the span name reported for this request.
    ///
    /// .. note::
    ///
    ///   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
    ///   by the :ref:`x-envoy-decorator-operation
    ///   &lt;config_http_filters_router_x-envoy-decorator-operation>` header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Operation {
      get { return operation_; }
      set {
        operation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Decorator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Decorator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Operation != other.Operation) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Operation.Length != 0) hash ^= Operation.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Operation.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Operation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Operation.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Operation);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Decorator other) {
      if (other == null) {
        return;
      }
      if (other.Operation.Length != 0) {
        Operation = other.Operation;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Operation = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class Tracing : pb::IMessage<Tracing> {
    private static readonly pb::MessageParser<Tracing> _parser = new pb::MessageParser<Tracing>(() => new Tracing());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Tracing> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing(Tracing other) : this() {
      clientSampling_ = other.clientSampling_ != null ? other.clientSampling_.Clone() : null;
      randomSampling_ = other.randomSampling_ != null ? other.randomSampling_.Clone() : null;
      overallSampling_ = other.overallSampling_ != null ? other.overallSampling_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing Clone() {
      return new Tracing(this);
    }

    /// <summary>Field number for the "client_sampling" field.</summary>
    public const int ClientSamplingFieldNumber = 1;
    private global::Envoy.Type.FractionalPercent clientSampling_;
    /// <summary>
    /// Target percentage of requests managed by this HTTP connection manager that will be force
    /// traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id>`
    /// header is set. This field is a direct analog for the runtime variable
    /// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
    /// &lt;config_http_conn_man_runtime>`.
    /// Default: 100%
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.FractionalPercent ClientSampling {
      get { return clientSampling_; }
      set {
        clientSampling_ = value;
      }
    }

    /// <summary>Field number for the "random_sampling" field.</summary>
    public const int RandomSamplingFieldNumber = 2;
    private global::Envoy.Type.FractionalPercent randomSampling_;
    /// <summary>
    /// Target percentage of requests managed by this HTTP connection manager that will be randomly
    /// selected for trace generation, if not requested by the client or not forced. This field is
    /// a direct analog for the runtime variable 'tracing.random_sampling' in the
    /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
    /// Default: 100%
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.FractionalPercent RandomSampling {
      get { return randomSampling_; }
      set {
        randomSampling_ = value;
      }
    }

    /// <summary>Field number for the "overall_sampling" field.</summary>
    public const int OverallSamplingFieldNumber = 3;
    private global::Envoy.Type.FractionalPercent overallSampling_;
    /// <summary>
    /// Target percentage of requests managed by this HTTP connection manager that will be traced
    /// after all other sampling checks have been applied (client-directed, force tracing, random
    /// sampling). This field functions as an upper limit on the total configured sampling rate. For
    /// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
    /// of client requests with the appropriate headers to be force traced. This field is a direct
    /// analog for the runtime variable 'tracing.global_enabled' in the
    /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
    /// Default: 100%
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.FractionalPercent OverallSampling {
      get { return overallSampling_; }
      set {
        overallSampling_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Tracing);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Tracing other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ClientSampling, other.ClientSampling)) return false;
      if (!object.Equals(RandomSampling, other.RandomSampling)) return false;
      if (!object.Equals(OverallSampling, other.OverallSampling)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (clientSampling_ != null) hash ^= ClientSampling.GetHashCode();
      if (randomSampling_ != null) hash ^= RandomSampling.GetHashCode();
      if (overallSampling_ != null) hash ^= OverallSampling.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (clientSampling_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientSampling);
      }
      if (randomSampling_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(RandomSampling);
      }
      if (overallSampling_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(OverallSampling);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (clientSampling_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientSampling);
      }
      if (randomSampling_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomSampling);
      }
      if (overallSampling_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OverallSampling);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Tracing other) {
      if (other == null) {
        return;
      }
      if (other.clientSampling_ != null) {
        if (clientSampling_ == null) {
          ClientSampling = new global::Envoy.Type.FractionalPercent();
        }
        ClientSampling.MergeFrom(other.ClientSampling);
      }
      if (other.randomSampling_ != null) {
        if (randomSampling_ == null) {
          RandomSampling = new global::Envoy.Type.FractionalPercent();
        }
        RandomSampling.MergeFrom(other.RandomSampling);
      }
      if (other.overallSampling_ != null) {
        if (overallSampling_ == null) {
          OverallSampling = new global::Envoy.Type.FractionalPercent();
        }
        OverallSampling.MergeFrom(other.OverallSampling);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (clientSampling_ == null) {
              ClientSampling = new global::Envoy.Type.FractionalPercent();
            }
            input.ReadMessage(ClientSampling);
            break;
          }
          case 18: {
            if (randomSampling_ == null) {
              RandomSampling = new global::Envoy.Type.FractionalPercent();
            }
            input.ReadMessage(RandomSampling);
            break;
          }
          case 26: {
            if (overallSampling_ == null) {
              OverallSampling = new global::Envoy.Type.FractionalPercent();
            }
            input.ReadMessage(OverallSampling);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A virtual cluster is a way of specifying a regex matching rule against
  /// certain important endpoints such that statistics are generated explicitly for
  /// the matched requests. The reason this is useful is that when doing
  /// prefix/path matching Envoy does not always know what the application
  /// considers to be an endpoint. Thus, it’s impossible for Envoy to generically
  /// emit per endpoint statistics. However, often systems have highly critical
  /// endpoints that they wish to get “perfect” statistics on. Virtual cluster
  /// statistics are perfect in the sense that they are emitted on the downstream
  /// side such that they include network level failures.
  ///
  /// Documentation for :ref:`virtual cluster statistics &lt;config_http_filters_router_stats>`.
  ///
  /// .. note::
  ///
  ///    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
  ///    every application endpoint. This is both not easily maintainable and as well the matching and
  ///    statistics output are not free.
  /// </summary>
  public sealed partial class VirtualCluster : pb::IMessage<VirtualCluster> {
    private static readonly pb::MessageParser<VirtualCluster> _parser = new pb::MessageParser<VirtualCluster>(() => new VirtualCluster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VirtualCluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualCluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualCluster(VirtualCluster other) : this() {
      pattern_ = other.pattern_;
      headers_ = other.headers_.Clone();
      name_ = other.name_;
      method_ = other.method_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VirtualCluster Clone() {
      return new VirtualCluster(this);
    }

    /// <summary>Field number for the "pattern" field.</summary>
    public const int PatternFieldNumber = 1;
    private string pattern_ = "";
    /// <summary>
    /// Specifies a regex pattern to use for matching requests. The entire path of the request
    /// must match the regex. The regex grammar used is defined `here
    /// &lt;https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
    ///
    /// Examples:
    ///
    /// * The regex */rides/\d+* matches the path */rides/0*
    /// * The regex */rides/\d+* matches the path */rides/123*
    /// * The regex */rides/\d+* does not match the path */rides/123/456*
    ///
    /// .. attention::
    ///   This field has been deprecated in favor of `headers` as it is not safe for use with
    ///   untrusted input in all cases.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Pattern {
      get { return pattern_; }
      set {
        pattern_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "headers" field.</summary>
    public const int HeadersFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.HeaderMatcher> _repeated_headers_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Api.V2.Route.HeaderMatcher.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> headers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher>();
    /// <summary>
    /// Specifies a list of header matchers to use for matching requests. Each specified header must
    /// match. The pseudo-headers `:path` and `:method` can be used to match the request path and
    /// method, respectively.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> Headers {
      get { return headers_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// Specifies the name of the virtual cluster. The virtual cluster name as well
    /// as the virtual host name are used when emitting statistics. The statistics are emitted by the
    /// router filter and are documented :ref:`here &lt;config_http_filters_router_stats>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "method" field.</summary>
    public const int MethodFieldNumber = 3;
    private global::Envoy.Api.V2.Core.RequestMethod method_ = global::Envoy.Api.V2.Core.RequestMethod.MethodUnspecified;
    /// <summary>
    /// Optionally specifies the HTTP method to match on. For example GET, PUT,
    /// etc.
    ///
    /// .. attention::
    ///   This field has been deprecated in favor of `headers`.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RequestMethod Method {
      get { return method_; }
      set {
        method_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VirtualCluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VirtualCluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Pattern != other.Pattern) return false;
      if(!headers_.Equals(other.headers_)) return false;
      if (Name != other.Name) return false;
      if (Method != other.Method) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Pattern.Length != 0) hash ^= Pattern.GetHashCode();
      hash ^= headers_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Method != global::Envoy.Api.V2.Core.RequestMethod.MethodUnspecified) hash ^= Method.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Pattern.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Pattern);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Method != global::Envoy.Api.V2.Core.RequestMethod.MethodUnspecified) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Method);
      }
      headers_.WriteTo(output, _repeated_headers_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Pattern.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Pattern);
      }
      size += headers_.CalculateSize(_repeated_headers_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Method != global::Envoy.Api.V2.Core.RequestMethod.MethodUnspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Method);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VirtualCluster other) {
      if (other == null) {
        return;
      }
      if (other.Pattern.Length != 0) {
        Pattern = other.Pattern;
      }
      headers_.Add(other.headers_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Method != global::Envoy.Api.V2.Core.RequestMethod.MethodUnspecified) {
        Method = other.Method;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Pattern = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 24: {
            Method = (global::Envoy.Api.V2.Core.RequestMethod) input.ReadEnum();
            break;
          }
          case 34: {
            headers_.AddEntriesFrom(input, _repeated_headers_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Global rate limiting :ref:`architecture overview &lt;arch_overview_rate_limit>`.
  /// </summary>
  public sealed partial class RateLimit : pb::IMessage<RateLimit> {
    private static readonly pb::MessageParser<RateLimit> _parser = new pb::MessageParser<RateLimit>(() => new RateLimit());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RateLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimit(RateLimit other) : this() {
      Stage = other.Stage;
      disableKey_ = other.disableKey_;
      actions_ = other.actions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimit Clone() {
      return new RateLimit(this);
    }

    /// <summary>Field number for the "stage" field.</summary>
    public const int StageFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_stage_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? stage_;
    /// <summary>
    /// Refers to the stage set in the filter. The rate limit configuration only
    /// applies to filters with the same stage number. The default stage number is
    /// 0.
    ///
    /// .. note::
    ///
    ///   The filter supports a range of 0 - 10 inclusively for stage numbers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? Stage {
      get { return stage_; }
      set {
        stage_ = value;
      }
    }


    /// <summary>Field number for the "disable_key" field.</summary>
    public const int DisableKeyFieldNumber = 2;
    private string disableKey_ = "";
    /// <summary>
    /// The key to be set in runtime to disable this rate limit configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DisableKey {
      get { return disableKey_; }
      set {
        disableKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "actions" field.</summary>
    public const int ActionsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.RateLimit.Types.Action> _repeated_actions_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Route.RateLimit.Types.Action.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit.Types.Action> actions_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit.Types.Action>();
    /// <summary>
    /// A list of actions that are to be applied for this rate limit configuration.
    /// Order matters as the actions are processed sequentially and the descriptor
    /// is composed by appending descriptor entries in that sequence. If an action
    /// cannot append a descriptor entry, no descriptor is generated for the
    /// configuration. See :ref:`composing actions
    /// &lt;config_http_filters_rate_limit_composing_actions>` for additional documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Route.RateLimit.Types.Action> Actions {
      get { return actions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RateLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RateLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Stage != other.Stage) return false;
      if (DisableKey != other.DisableKey) return false;
      if(!actions_.Equals(other.actions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (stage_ != null) hash ^= Stage.GetHashCode();
      if (DisableKey.Length != 0) hash ^= DisableKey.GetHashCode();
      hash ^= actions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (stage_ != null) {
        _single_stage_codec.WriteTagAndValue(output, Stage);
      }
      if (DisableKey.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DisableKey);
      }
      actions_.WriteTo(output, _repeated_actions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (stage_ != null) {
        size += _single_stage_codec.CalculateSizeWithTag(Stage);
      }
      if (DisableKey.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DisableKey);
      }
      size += actions_.CalculateSize(_repeated_actions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RateLimit other) {
      if (other == null) {
        return;
      }
      if (other.stage_ != null) {
        if (stage_ == null || other.Stage != 0) {
          Stage = other.Stage;
        }
      }
      if (other.DisableKey.Length != 0) {
        DisableKey = other.DisableKey;
      }
      actions_.Add(other.actions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_stage_codec.Read(input);
            if (stage_ == null || value != 0) {
              Stage = value;
            }
            break;
          }
          case 18: {
            DisableKey = input.ReadString();
            break;
          }
          case 26: {
            actions_.AddEntriesFrom(input, _repeated_actions_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RateLimit message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Action : pb::IMessage<Action> {
        private static readonly pb::MessageParser<Action> _parser = new pb::MessageParser<Action>(() => new Action());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Action> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Route.RateLimit.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action(Action other) : this() {
          switch (other.ActionSpecifierCase) {
            case ActionSpecifierOneofCase.SourceCluster:
              SourceCluster = other.SourceCluster.Clone();
              break;
            case ActionSpecifierOneofCase.DestinationCluster:
              DestinationCluster = other.DestinationCluster.Clone();
              break;
            case ActionSpecifierOneofCase.RequestHeaders:
              RequestHeaders = other.RequestHeaders.Clone();
              break;
            case ActionSpecifierOneofCase.RemoteAddress:
              RemoteAddress = other.RemoteAddress.Clone();
              break;
            case ActionSpecifierOneofCase.GenericKey:
              GenericKey = other.GenericKey.Clone();
              break;
            case ActionSpecifierOneofCase.HeaderValueMatch:
              HeaderValueMatch = other.HeaderValueMatch.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Action Clone() {
          return new Action(this);
        }

        /// <summary>Field number for the "source_cluster" field.</summary>
        public const int SourceClusterFieldNumber = 1;
        /// <summary>
        /// Rate limit on source cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster SourceCluster {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.SourceCluster;
          }
        }

        /// <summary>Field number for the "destination_cluster" field.</summary>
        public const int DestinationClusterFieldNumber = 2;
        /// <summary>
        /// Rate limit on destination cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster DestinationCluster {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.DestinationCluster;
          }
        }

        /// <summary>Field number for the "request_headers" field.</summary>
        public const int RequestHeadersFieldNumber = 3;
        /// <summary>
        /// Rate limit on request headers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders RequestHeaders {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.RequestHeaders;
          }
        }

        /// <summary>Field number for the "remote_address" field.</summary>
        public const int RemoteAddressFieldNumber = 4;
        /// <summary>
        /// Rate limit on remote address.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress RemoteAddress {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.RemoteAddress;
          }
        }

        /// <summary>Field number for the "generic_key" field.</summary>
        public const int GenericKeyFieldNumber = 5;
        /// <summary>
        /// Rate limit on a generic key.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey GenericKey {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.GenericKey;
          }
        }

        /// <summary>Field number for the "header_value_match" field.</summary>
        public const int HeaderValueMatchFieldNumber = 6;
        /// <summary>
        /// Rate limit on the existence of request headers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch HeaderValueMatch {
          get { return actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch ? (global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch) actionSpecifier_ : null; }
          set {
            actionSpecifier_ = value;
            actionSpecifierCase_ = value == null ? ActionSpecifierOneofCase.None : ActionSpecifierOneofCase.HeaderValueMatch;
          }
        }

        private object actionSpecifier_;
        /// <summary>Enum of possible cases for the "action_specifier" oneof.</summary>
        public enum ActionSpecifierOneofCase {
          None = 0,
          SourceCluster = 1,
          DestinationCluster = 2,
          RequestHeaders = 3,
          RemoteAddress = 4,
          GenericKey = 5,
          HeaderValueMatch = 6,
        }
        private ActionSpecifierOneofCase actionSpecifierCase_ = ActionSpecifierOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ActionSpecifierOneofCase ActionSpecifierCase {
          get { return actionSpecifierCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearActionSpecifier() {
          actionSpecifierCase_ = ActionSpecifierOneofCase.None;
          actionSpecifier_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Action);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Action other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(SourceCluster, other.SourceCluster)) return false;
          if (!object.Equals(DestinationCluster, other.DestinationCluster)) return false;
          if (!object.Equals(RequestHeaders, other.RequestHeaders)) return false;
          if (!object.Equals(RemoteAddress, other.RemoteAddress)) return false;
          if (!object.Equals(GenericKey, other.GenericKey)) return false;
          if (!object.Equals(HeaderValueMatch, other.HeaderValueMatch)) return false;
          if (ActionSpecifierCase != other.ActionSpecifierCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) hash ^= SourceCluster.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) hash ^= DestinationCluster.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) hash ^= RequestHeaders.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) hash ^= RemoteAddress.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) hash ^= GenericKey.GetHashCode();
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) hash ^= HeaderValueMatch.GetHashCode();
          hash ^= (int) actionSpecifierCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
            output.WriteRawTag(10);
            output.WriteMessage(SourceCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
            output.WriteRawTag(18);
            output.WriteMessage(DestinationCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
            output.WriteRawTag(26);
            output.WriteMessage(RequestHeaders);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
            output.WriteRawTag(34);
            output.WriteMessage(RemoteAddress);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
            output.WriteRawTag(42);
            output.WriteMessage(GenericKey);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
            output.WriteRawTag(50);
            output.WriteMessage(HeaderValueMatch);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DestinationCluster);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestHeaders);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RemoteAddress);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(GenericKey);
          }
          if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderValueMatch);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Action other) {
          if (other == null) {
            return;
          }
          switch (other.ActionSpecifierCase) {
            case ActionSpecifierOneofCase.SourceCluster:
              if (SourceCluster == null) {
                SourceCluster = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster();
              }
              SourceCluster.MergeFrom(other.SourceCluster);
              break;
            case ActionSpecifierOneofCase.DestinationCluster:
              if (DestinationCluster == null) {
                DestinationCluster = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster();
              }
              DestinationCluster.MergeFrom(other.DestinationCluster);
              break;
            case ActionSpecifierOneofCase.RequestHeaders:
              if (RequestHeaders == null) {
                RequestHeaders = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders();
              }
              RequestHeaders.MergeFrom(other.RequestHeaders);
              break;
            case ActionSpecifierOneofCase.RemoteAddress:
              if (RemoteAddress == null) {
                RemoteAddress = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress();
              }
              RemoteAddress.MergeFrom(other.RemoteAddress);
              break;
            case ActionSpecifierOneofCase.GenericKey:
              if (GenericKey == null) {
                GenericKey = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey();
              }
              GenericKey.MergeFrom(other.GenericKey);
              break;
            case ActionSpecifierOneofCase.HeaderValueMatch:
              if (HeaderValueMatch == null) {
                HeaderValueMatch = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch();
              }
              HeaderValueMatch.MergeFrom(other.HeaderValueMatch);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.SourceCluster();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.SourceCluster) {
                  subBuilder.MergeFrom(SourceCluster);
                }
                input.ReadMessage(subBuilder);
                SourceCluster = subBuilder;
                break;
              }
              case 18: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.DestinationCluster();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.DestinationCluster) {
                  subBuilder.MergeFrom(DestinationCluster);
                }
                input.ReadMessage(subBuilder);
                DestinationCluster = subBuilder;
                break;
              }
              case 26: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RequestHeaders();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.RequestHeaders) {
                  subBuilder.MergeFrom(RequestHeaders);
                }
                input.ReadMessage(subBuilder);
                RequestHeaders = subBuilder;
                break;
              }
              case 34: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.RemoteAddress();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.RemoteAddress) {
                  subBuilder.MergeFrom(RemoteAddress);
                }
                input.ReadMessage(subBuilder);
                RemoteAddress = subBuilder;
                break;
              }
              case 42: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.GenericKey();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.GenericKey) {
                  subBuilder.MergeFrom(GenericKey);
                }
                input.ReadMessage(subBuilder);
                GenericKey = subBuilder;
                break;
              }
              case 50: {
                global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch subBuilder = new global::Envoy.Api.V2.Route.RateLimit.Types.Action.Types.HeaderValueMatch();
                if (actionSpecifierCase_ == ActionSpecifierOneofCase.HeaderValueMatch) {
                  subBuilder.MergeFrom(HeaderValueMatch);
                }
                input.ReadMessage(subBuilder);
                HeaderValueMatch = subBuilder;
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Action message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("source_cluster", "&lt;local service cluster>")
          ///
          /// &lt;local service cluster> is derived from the :option:`--service-cluster` option.
          /// </summary>
          public sealed partial class SourceCluster : pb::IMessage<SourceCluster> {
            private static readonly pb::MessageParser<SourceCluster> _parser = new pb::MessageParser<SourceCluster>(() => new SourceCluster());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<SourceCluster> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public SourceCluster() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public SourceCluster(SourceCluster other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public SourceCluster Clone() {
              return new SourceCluster(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as SourceCluster);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(SourceCluster other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(SourceCluster other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("destination_cluster", "&lt;routed target cluster>")
          ///
          /// Once a request matches against a route table rule, a routed cluster is determined by one of
          /// the following :ref:`route table configuration &lt;envoy_api_msg_RouteConfiguration>`
          /// settings:
          ///
          /// * :ref:`cluster &lt;envoy_api_field_route.RouteAction.cluster>` indicates the upstream cluster
          ///   to route to.
          /// * :ref:`weighted_clusters &lt;envoy_api_field_route.RouteAction.weighted_clusters>`
          ///   chooses a cluster randomly from a set of clusters with attributed weight.
          /// * :ref:`cluster_header &lt;envoy_api_field_route.RouteAction.cluster_header>` indicates which
          ///   header in the request contains the target cluster.
          /// </summary>
          public sealed partial class DestinationCluster : pb::IMessage<DestinationCluster> {
            private static readonly pb::MessageParser<DestinationCluster> _parser = new pb::MessageParser<DestinationCluster>(() => new DestinationCluster());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<DestinationCluster> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[1]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DestinationCluster() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DestinationCluster(DestinationCluster other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DestinationCluster Clone() {
              return new DestinationCluster(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as DestinationCluster);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(DestinationCluster other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(DestinationCluster other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended when a header contains a key that matches the
          /// *header_name*:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("&lt;descriptor_key>", "&lt;header_value_queried_from_header>")
          /// </summary>
          public sealed partial class RequestHeaders : pb::IMessage<RequestHeaders> {
            private static readonly pb::MessageParser<RequestHeaders> _parser = new pb::MessageParser<RequestHeaders>(() => new RequestHeaders());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<RequestHeaders> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[2]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RequestHeaders() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RequestHeaders(RequestHeaders other) : this() {
              headerName_ = other.headerName_;
              descriptorKey_ = other.descriptorKey_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RequestHeaders Clone() {
              return new RequestHeaders(this);
            }

            /// <summary>Field number for the "header_name" field.</summary>
            public const int HeaderNameFieldNumber = 1;
            private string headerName_ = "";
            /// <summary>
            /// The header name to be queried from the request headers. The header’s
            /// value is used to populate the value of the descriptor entry for the
            /// descriptor_key.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string HeaderName {
              get { return headerName_; }
              set {
                headerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "descriptor_key" field.</summary>
            public const int DescriptorKeyFieldNumber = 2;
            private string descriptorKey_ = "";
            /// <summary>
            /// The key to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string DescriptorKey {
              get { return descriptorKey_; }
              set {
                descriptorKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as RequestHeaders);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(RequestHeaders other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (HeaderName != other.HeaderName) return false;
              if (DescriptorKey != other.DescriptorKey) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (HeaderName.Length != 0) hash ^= HeaderName.GetHashCode();
              if (DescriptorKey.Length != 0) hash ^= DescriptorKey.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (HeaderName.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(HeaderName);
              }
              if (DescriptorKey.Length != 0) {
                output.WriteRawTag(18);
                output.WriteString(DescriptorKey);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (HeaderName.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(HeaderName);
              }
              if (DescriptorKey.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorKey);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(RequestHeaders other) {
              if (other == null) {
                return;
              }
              if (other.HeaderName.Length != 0) {
                HeaderName = other.HeaderName;
              }
              if (other.DescriptorKey.Length != 0) {
                DescriptorKey = other.DescriptorKey;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    HeaderName = input.ReadString();
                    break;
                  }
                  case 18: {
                    DescriptorKey = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor and is populated using the
          /// trusted address from :ref:`x-forwarded-for &lt;config_http_conn_man_headers_x-forwarded-for>`:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("remote_address", "&lt;trusted address from x-forwarded-for>")
          /// </summary>
          public sealed partial class RemoteAddress : pb::IMessage<RemoteAddress> {
            private static readonly pb::MessageParser<RemoteAddress> _parser = new pb::MessageParser<RemoteAddress>(() => new RemoteAddress());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<RemoteAddress> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[3]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RemoteAddress() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RemoteAddress(RemoteAddress other) : this() {
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public RemoteAddress Clone() {
              return new RemoteAddress(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as RemoteAddress);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(RemoteAddress other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(RemoteAddress other) {
              if (other == null) {
                return;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("generic_key", "&lt;descriptor_value>")
          /// </summary>
          public sealed partial class GenericKey : pb::IMessage<GenericKey> {
            private static readonly pb::MessageParser<GenericKey> _parser = new pb::MessageParser<GenericKey>(() => new GenericKey());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<GenericKey> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[4]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public GenericKey() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public GenericKey(GenericKey other) : this() {
              descriptorValue_ = other.descriptorValue_;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public GenericKey Clone() {
              return new GenericKey(this);
            }

            /// <summary>Field number for the "descriptor_value" field.</summary>
            public const int DescriptorValueFieldNumber = 1;
            private string descriptorValue_ = "";
            /// <summary>
            /// The value to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string DescriptorValue {
              get { return descriptorValue_; }
              set {
                descriptorValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as GenericKey);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(GenericKey other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DescriptorValue != other.DescriptorValue) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (DescriptorValue.Length != 0) hash ^= DescriptorValue.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (DescriptorValue.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorValue);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (DescriptorValue.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorValue);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(GenericKey other) {
              if (other == null) {
                return;
              }
              if (other.DescriptorValue.Length != 0) {
                DescriptorValue = other.DescriptorValue;
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    DescriptorValue = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

          /// <summary>
          /// The following descriptor entry is appended to the descriptor:
          ///
          /// .. code-block:: cpp
          ///
          ///   ("header_match", "&lt;descriptor_value>")
          /// </summary>
          public sealed partial class HeaderValueMatch : pb::IMessage<HeaderValueMatch> {
            private static readonly pb::MessageParser<HeaderValueMatch> _parser = new pb::MessageParser<HeaderValueMatch>(() => new HeaderValueMatch());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<HeaderValueMatch> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Route.RateLimit.Types.Action.Descriptor.NestedTypes[5]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public HeaderValueMatch() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public HeaderValueMatch(HeaderValueMatch other) : this() {
              descriptorValue_ = other.descriptorValue_;
              ExpectMatch = other.ExpectMatch;
              headers_ = other.headers_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public HeaderValueMatch Clone() {
              return new HeaderValueMatch(this);
            }

            /// <summary>Field number for the "descriptor_value" field.</summary>
            public const int DescriptorValueFieldNumber = 1;
            private string descriptorValue_ = "";
            /// <summary>
            /// The value to use in the descriptor entry.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string DescriptorValue {
              get { return descriptorValue_; }
              set {
                descriptorValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "expect_match" field.</summary>
            public const int ExpectMatchFieldNumber = 2;
            private static readonly pb::FieldCodec<bool?> _single_expectMatch_codec = pb::FieldCodec.ForStructWrapper<bool>(18);
            private bool? expectMatch_;
            /// <summary>
            /// If set to true, the action will append a descriptor entry when the
            /// request matches the headers. If set to false, the action will append a
            /// descriptor entry when the request does not match the headers. The
            /// default value is true.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool? ExpectMatch {
              get { return expectMatch_; }
              set {
                expectMatch_ = value;
              }
            }


            /// <summary>Field number for the "headers" field.</summary>
            public const int HeadersFieldNumber = 3;
            private static readonly pb::FieldCodec<global::Envoy.Api.V2.Route.HeaderMatcher> _repeated_headers_codec
                = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Route.HeaderMatcher.Parser);
            private readonly pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> headers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher>();
            /// <summary>
            /// Specifies a set of headers that the rate limit action should match
            /// on. The action will check the request’s headers against all the
            /// specified headers in the config. A match will happen if all the
            /// headers in the config are present in the request with the same values
            /// (or based on presence if the value field is not in the config).
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Envoy.Api.V2.Route.HeaderMatcher> Headers {
              get { return headers_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as HeaderValueMatch);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(HeaderValueMatch other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DescriptorValue != other.DescriptorValue) return false;
              if (ExpectMatch != other.ExpectMatch) return false;
              if(!headers_.Equals(other.headers_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (DescriptorValue.Length != 0) hash ^= DescriptorValue.GetHashCode();
              if (expectMatch_ != null) hash ^= ExpectMatch.GetHashCode();
              hash ^= headers_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (DescriptorValue.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(DescriptorValue);
              }
              if (expectMatch_ != null) {
                _single_expectMatch_codec.WriteTagAndValue(output, ExpectMatch);
              }
              headers_.WriteTo(output, _repeated_headers_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (DescriptorValue.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DescriptorValue);
              }
              if (expectMatch_ != null) {
                size += _single_expectMatch_codec.CalculateSizeWithTag(ExpectMatch);
              }
              size += headers_.CalculateSize(_repeated_headers_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(HeaderValueMatch other) {
              if (other == null) {
                return;
              }
              if (other.DescriptorValue.Length != 0) {
                DescriptorValue = other.DescriptorValue;
              }
              if (other.expectMatch_ != null) {
                if (expectMatch_ == null || other.ExpectMatch != false) {
                  ExpectMatch = other.ExpectMatch;
                }
              }
              headers_.Add(other.headers_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    DescriptorValue = input.ReadString();
                    break;
                  }
                  case 18: {
                    bool? value = _single_expectMatch_codec.Read(input);
                    if (expectMatch_ == null || value != false) {
                      ExpectMatch = value;
                    }
                    break;
                  }
                  case 26: {
                    headers_.AddEntriesFrom(input, _repeated_headers_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// .. attention::
  ///
  ///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
  ///   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
  ///
  /// .. attention::
  ///
  ///   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
  ///   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
  ///
  ///   .. code-block:: json
  ///
  ///     {
  ///       "name": ":method",
  ///       "exact_match": "POST"
  ///     }
  ///
  /// .. attention::
  ///   In the absence of any header match specifier, match will default to :ref:`present_match
  ///   &lt;envoy_api_field_route.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
  ///   &lt;envoy_api_field_route.HeaderMatcher.name>` header will match, regardless of the header's
  ///   value.
  ///
  ///  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
  /// </summary>
  public sealed partial class HeaderMatcher : pb::IMessage<HeaderMatcher> {
    private static readonly pb::MessageParser<HeaderMatcher> _parser = new pb::MessageParser<HeaderMatcher>(() => new HeaderMatcher());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HeaderMatcher> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HeaderMatcher() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HeaderMatcher(HeaderMatcher other) : this() {
      name_ = other.name_;
      invertMatch_ = other.invertMatch_;
      switch (other.HeaderMatchSpecifierCase) {
        case HeaderMatchSpecifierOneofCase.ExactMatch:
          ExactMatch = other.ExactMatch;
          break;
        case HeaderMatchSpecifierOneofCase.RegexMatch:
          RegexMatch = other.RegexMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SafeRegexMatch:
          SafeRegexMatch = other.SafeRegexMatch.Clone();
          break;
        case HeaderMatchSpecifierOneofCase.RangeMatch:
          RangeMatch = other.RangeMatch.Clone();
          break;
        case HeaderMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
        case HeaderMatchSpecifierOneofCase.PrefixMatch:
          PrefixMatch = other.PrefixMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SuffixMatch:
          SuffixMatch = other.SuffixMatch;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HeaderMatcher Clone() {
      return new HeaderMatcher(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Specifies the name of the header in the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "exact_match" field.</summary>
    public const int ExactMatchFieldNumber = 4;
    /// <summary>
    /// If specified, header match will be performed based on the value of the header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExactMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.ExactMatch;
      }
    }

    /// <summary>Field number for the "regex_match" field.</summary>
    public const int RegexMatchFieldNumber = 5;
    /// <summary>
    /// If specified, this regex string is a regular expression rule which implies the entire request
    /// header value must match the regex. The rule will not match if only a subsequence of the
    /// request header value matches the regex. The regex grammar used in the value field is defined
    /// `here &lt;https://en.cppreference.com/w/cpp/regex/ecmascript>`_.
    ///
    /// Examples:
    ///
    /// * The regex *\d{3}* matches the value *123*
    /// * The regex *\d{3}* does not match the value *1234*
    /// * The regex *\d{3}* does not match the value *123.456*
    ///
    /// .. attention::
    ///   This field has been deprecated in favor of `safe_regex_match` as it is not safe for use
    ///   with untrusted input in all cases.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RegexMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RegexMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.RegexMatch;
      }
    }

    /// <summary>Field number for the "safe_regex_match" field.</summary>
    public const int SafeRegexMatchFieldNumber = 11;
    /// <summary>
    /// If specified, this regex string is a regular expression rule which implies the entire request
    /// header value must match the regex. The rule will not match if only a subsequence of the
    /// request header value matches the regex.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.RegexMatcher SafeRegexMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch ? (global::Envoy.Type.Matcher.RegexMatcher) headerMatchSpecifier_ : null; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = value == null ? HeaderMatchSpecifierOneofCase.None : HeaderMatchSpecifierOneofCase.SafeRegexMatch;
      }
    }

    /// <summary>Field number for the "range_match" field.</summary>
    public const int RangeMatchFieldNumber = 6;
    /// <summary>
    /// If specified, header match will be performed based on range.
    /// The rule will match if the request header value is within this range.
    /// The entire request header value must represent an integer in base 10 notation: consisting of
    /// an optional plus or minus sign followed by a sequence of digits. The rule will not match if
    /// the header value does not represent an integer. Match will fail for empty values, floating
    /// point numbers or if only a subsequence of the header value is an integer.
    ///
    /// Examples:
    ///
    /// * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
    ///   "-1somestring"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Int64Range RangeMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch ? (global::Envoy.Type.Int64Range) headerMatchSpecifier_ : null; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = value == null ? HeaderMatchSpecifierOneofCase.None : HeaderMatchSpecifierOneofCase.RangeMatch;
      }
    }

    /// <summary>Field number for the "present_match" field.</summary>
    public const int PresentMatchFieldNumber = 7;
    /// <summary>
    /// If specified, header match will be performed based on whether the header is in the
    /// request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PresentMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch ? (bool) headerMatchSpecifier_ : false; }
      set {
        headerMatchSpecifier_ = value;
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.PresentMatch;
      }
    }

    /// <summary>Field number for the "prefix_match" field.</summary>
    public const int PrefixMatchFieldNumber = 9;
    /// <summary>
    /// If specified, header match will be performed based on the prefix of the header value.
    /// Note: empty prefix is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PrefixMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.PrefixMatch;
      }
    }

    /// <summary>Field number for the "suffix_match" field.</summary>
    public const int SuffixMatchFieldNumber = 10;
    /// <summary>
    /// If specified, header match will be performed based on the suffix of the header value.
    /// Note: empty suffix is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SuffixMatch {
      get { return headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch ? (string) headerMatchSpecifier_ : ""; }
      set {
        headerMatchSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.SuffixMatch;
      }
    }

    /// <summary>Field number for the "invert_match" field.</summary>
    public const int InvertMatchFieldNumber = 8;
    private bool invertMatch_;
    /// <summary>
    /// If specified, the match result will be inverted before checking. Defaults to false.
    ///
    /// Examples:
    ///
    /// * The regex *\d{3}* does not match the value *1234*, so it will match when inverted.
    /// * The range [-10,0) will match the value -1, so it will not match when inverted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool InvertMatch {
      get { return invertMatch_; }
      set {
        invertMatch_ = value;
      }
    }

    private object headerMatchSpecifier_;
    /// <summary>Enum of possible cases for the "header_match_specifier" oneof.</summary>
    public enum HeaderMatchSpecifierOneofCase {
      None = 0,
      ExactMatch = 4,
      RegexMatch = 5,
      SafeRegexMatch = 11,
      RangeMatch = 6,
      PresentMatch = 7,
      PrefixMatch = 9,
      SuffixMatch = 10,
    }
    private HeaderMatchSpecifierOneofCase headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HeaderMatchSpecifierOneofCase HeaderMatchSpecifierCase {
      get { return headerMatchSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHeaderMatchSpecifier() {
      headerMatchSpecifierCase_ = HeaderMatchSpecifierOneofCase.None;
      headerMatchSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HeaderMatcher);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HeaderMatcher other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (ExactMatch != other.ExactMatch) return false;
      if (RegexMatch != other.RegexMatch) return false;
      if (!object.Equals(SafeRegexMatch, other.SafeRegexMatch)) return false;
      if (!object.Equals(RangeMatch, other.RangeMatch)) return false;
      if (PresentMatch != other.PresentMatch) return false;
      if (PrefixMatch != other.PrefixMatch) return false;
      if (SuffixMatch != other.SuffixMatch) return false;
      if (InvertMatch != other.InvertMatch) return false;
      if (HeaderMatchSpecifierCase != other.HeaderMatchSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) hash ^= ExactMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RegexMatch) hash ^= RegexMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) hash ^= SafeRegexMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) hash ^= RangeMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) hash ^= PresentMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) hash ^= PrefixMatch.GetHashCode();
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) hash ^= SuffixMatch.GetHashCode();
      if (InvertMatch != false) hash ^= InvertMatch.GetHashCode();
      hash ^= (int) headerMatchSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) {
        output.WriteRawTag(34);
        output.WriteString(ExactMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RegexMatch) {
        output.WriteRawTag(42);
        output.WriteString(RegexMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
        output.WriteRawTag(50);
        output.WriteMessage(RangeMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) {
        output.WriteRawTag(56);
        output.WriteBool(PresentMatch);
      }
      if (InvertMatch != false) {
        output.WriteRawTag(64);
        output.WriteBool(InvertMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) {
        output.WriteRawTag(74);
        output.WriteString(PrefixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) {
        output.WriteRawTag(82);
        output.WriteString(SuffixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) {
        output.WriteRawTag(90);
        output.WriteMessage(SafeRegexMatch);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.ExactMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExactMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RegexMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RegexMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SafeRegexMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RangeMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PresentMatch) {
        size += 1 + 1;
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.PrefixMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PrefixMatch);
      }
      if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SuffixMatch) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SuffixMatch);
      }
      if (InvertMatch != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HeaderMatcher other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.InvertMatch != false) {
        InvertMatch = other.InvertMatch;
      }
      switch (other.HeaderMatchSpecifierCase) {
        case HeaderMatchSpecifierOneofCase.ExactMatch:
          ExactMatch = other.ExactMatch;
          break;
        case HeaderMatchSpecifierOneofCase.RegexMatch:
          RegexMatch = other.RegexMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SafeRegexMatch:
          if (SafeRegexMatch == null) {
            SafeRegexMatch = new global::Envoy.Type.Matcher.RegexMatcher();
          }
          SafeRegexMatch.MergeFrom(other.SafeRegexMatch);
          break;
        case HeaderMatchSpecifierOneofCase.RangeMatch:
          if (RangeMatch == null) {
            RangeMatch = new global::Envoy.Type.Int64Range();
          }
          RangeMatch.MergeFrom(other.RangeMatch);
          break;
        case HeaderMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
        case HeaderMatchSpecifierOneofCase.PrefixMatch:
          PrefixMatch = other.PrefixMatch;
          break;
        case HeaderMatchSpecifierOneofCase.SuffixMatch:
          SuffixMatch = other.SuffixMatch;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            ExactMatch = input.ReadString();
            break;
          }
          case 42: {
            RegexMatch = input.ReadString();
            break;
          }
          case 50: {
            global::Envoy.Type.Int64Range subBuilder = new global::Envoy.Type.Int64Range();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.RangeMatch) {
              subBuilder.MergeFrom(RangeMatch);
            }
            input.ReadMessage(subBuilder);
            RangeMatch = subBuilder;
            break;
          }
          case 56: {
            PresentMatch = input.ReadBool();
            break;
          }
          case 64: {
            InvertMatch = input.ReadBool();
            break;
          }
          case 74: {
            PrefixMatch = input.ReadString();
            break;
          }
          case 82: {
            SuffixMatch = input.ReadString();
            break;
          }
          case 90: {
            global::Envoy.Type.Matcher.RegexMatcher subBuilder = new global::Envoy.Type.Matcher.RegexMatcher();
            if (headerMatchSpecifierCase_ == HeaderMatchSpecifierOneofCase.SafeRegexMatch) {
              subBuilder.MergeFrom(SafeRegexMatch);
            }
            input.ReadMessage(subBuilder);
            SafeRegexMatch = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Query parameter matching treats the query string of a request's :path header
  /// as an ampersand-separated list of keys and/or key=value elements.
  /// </summary>
  public sealed partial class QueryParameterMatcher : pb::IMessage<QueryParameterMatcher> {
    private static readonly pb::MessageParser<QueryParameterMatcher> _parser = new pb::MessageParser<QueryParameterMatcher>(() => new QueryParameterMatcher());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<QueryParameterMatcher> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Route.RouteReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QueryParameterMatcher() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QueryParameterMatcher(QueryParameterMatcher other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      Regex = other.Regex;
      switch (other.QueryParameterMatchSpecifierCase) {
        case QueryParameterMatchSpecifierOneofCase.StringMatch:
          StringMatch = other.StringMatch.Clone();
          break;
        case QueryParameterMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QueryParameterMatcher Clone() {
      return new QueryParameterMatcher(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Specifies the name of a key that must be present in the requested
    /// *path*'s query string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 3;
    private string value_ = "";
    /// <summary>
    /// Specifies the value of the key. If the value is absent, a request
    /// that contains the key in its query string will match, whether the
    /// key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
    ///
    /// ..attention::
    ///   This field is deprecated. Use an `exact` match inside the `string_match` field.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "regex" field.</summary>
    public const int RegexFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_regex_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? regex_;
    /// <summary>
    /// Specifies whether the query parameter value is a regular expression.
    /// Defaults to false. The entire query parameter value (i.e., the part to
    /// the right of the equals sign in "key=value") must match the regex.
    /// E.g., the regex "\d+$" will match "123" but not "a123" or "123a".
    ///
    /// ..attention::
    ///   This field is deprecated. Use a `safe_regex` match inside the `string_match` field.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? Regex {
      get { return regex_; }
      set {
        regex_ = value;
      }
    }


    /// <summary>Field number for the "string_match" field.</summary>
    public const int StringMatchFieldNumber = 5;
    /// <summary>
    /// Specifies whether a query parameter value should match against a string.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.StringMatcher StringMatch {
      get { return queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch ? (global::Envoy.Type.Matcher.StringMatcher) queryParameterMatchSpecifier_ : null; }
      set {
        queryParameterMatchSpecifier_ = value;
        queryParameterMatchSpecifierCase_ = value == null ? QueryParameterMatchSpecifierOneofCase.None : QueryParameterMatchSpecifierOneofCase.StringMatch;
      }
    }

    /// <summary>Field number for the "present_match" field.</summary>
    public const int PresentMatchFieldNumber = 6;
    /// <summary>
    /// Specifies whether a query parameter should be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PresentMatch {
      get { return queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch ? (bool) queryParameterMatchSpecifier_ : false; }
      set {
        queryParameterMatchSpecifier_ = value;
        queryParameterMatchSpecifierCase_ = QueryParameterMatchSpecifierOneofCase.PresentMatch;
      }
    }

    private object queryParameterMatchSpecifier_;
    /// <summary>Enum of possible cases for the "query_parameter_match_specifier" oneof.</summary>
    public enum QueryParameterMatchSpecifierOneofCase {
      None = 0,
      StringMatch = 5,
      PresentMatch = 6,
    }
    private QueryParameterMatchSpecifierOneofCase queryParameterMatchSpecifierCase_ = QueryParameterMatchSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public QueryParameterMatchSpecifierOneofCase QueryParameterMatchSpecifierCase {
      get { return queryParameterMatchSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearQueryParameterMatchSpecifier() {
      queryParameterMatchSpecifierCase_ = QueryParameterMatchSpecifierOneofCase.None;
      queryParameterMatchSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as QueryParameterMatcher);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(QueryParameterMatcher other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      if (Regex != other.Regex) return false;
      if (!object.Equals(StringMatch, other.StringMatch)) return false;
      if (PresentMatch != other.PresentMatch) return false;
      if (QueryParameterMatchSpecifierCase != other.QueryParameterMatchSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (regex_ != null) hash ^= Regex.GetHashCode();
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) hash ^= StringMatch.GetHashCode();
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch) hash ^= PresentMatch.GetHashCode();
      hash ^= (int) queryParameterMatchSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Value.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Value);
      }
      if (regex_ != null) {
        _single_regex_codec.WriteTagAndValue(output, Regex);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) {
        output.WriteRawTag(42);
        output.WriteMessage(StringMatch);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch) {
        output.WriteRawTag(48);
        output.WriteBool(PresentMatch);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (regex_ != null) {
        size += _single_regex_codec.CalculateSizeWithTag(Regex);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StringMatch);
      }
      if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.PresentMatch) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(QueryParameterMatcher other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      if (other.regex_ != null) {
        if (regex_ == null || other.Regex != false) {
          Regex = other.Regex;
        }
      }
      switch (other.QueryParameterMatchSpecifierCase) {
        case QueryParameterMatchSpecifierOneofCase.StringMatch:
          if (StringMatch == null) {
            StringMatch = new global::Envoy.Type.Matcher.StringMatcher();
          }
          StringMatch.MergeFrom(other.StringMatch);
          break;
        case QueryParameterMatchSpecifierOneofCase.PresentMatch:
          PresentMatch = other.PresentMatch;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Value = input.ReadString();
            break;
          }
          case 34: {
            bool? value = _single_regex_codec.Read(input);
            if (regex_ == null || value != false) {
              Regex = value;
            }
            break;
          }
          case 42: {
            global::Envoy.Type.Matcher.StringMatcher subBuilder = new global::Envoy.Type.Matcher.StringMatcher();
            if (queryParameterMatchSpecifierCase_ == QueryParameterMatchSpecifierOneofCase.StringMatch) {
              subBuilder.MergeFrom(StringMatch);
            }
            input.ReadMessage(subBuilder);
            StringMatch = subBuilder;
            break;
          }
          case 48: {
            PresentMatch = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
