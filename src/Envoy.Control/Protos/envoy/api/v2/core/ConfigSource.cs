// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/core/config_source.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2.Core {

  /// <summary>Holder for reflection information generated from envoy/api/v2/core/config_source.proto</summary>
  public static partial class ConfigSourceReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/core/config_source.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ConfigSourceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiVlbnZveS9hcGkvdjIvY29yZS9jb25maWdfc291cmNlLnByb3RvEhFlbnZv",
            "eS5hcGkudjIuY29yZRokZW52b3kvYXBpL3YyL2NvcmUvZ3JwY19zZXJ2aWNl",
            "LnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8aHmdvb2ds",
            "ZS9wcm90b2J1Zi93cmFwcGVycy5wcm90bxoXdmFsaWRhdGUvdmFsaWRhdGUu",
            "cHJvdG8i2AMKD0FwaUNvbmZpZ1NvdXJjZRJICghhcGlfdHlwZRgBIAEoDjIq",
            "LmVudm95LmFwaS52Mi5jb3JlLkFwaUNvbmZpZ1NvdXJjZS5BcGlUeXBlQgq6",
            "6cADBYIBAhABEhUKDWNsdXN0ZXJfbmFtZXMYAiADKAkSNQoNZ3JwY19zZXJ2",
            "aWNlcxgEIAMoCzIeLmVudm95LmFwaS52Mi5jb3JlLkdycGNTZXJ2aWNlEjAK",
            "DXJlZnJlc2hfZGVsYXkYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRp",
            "b24SQAoPcmVxdWVzdF90aW1lb3V0GAUgASgLMhkuZ29vZ2xlLnByb3RvYnVm",
            "LkR1cmF0aW9uQgy66cADB6oBBCoCCAASQQoTcmF0ZV9saW1pdF9zZXR0aW5n",
            "cxgGIAEoCzIkLmVudm95LmFwaS52Mi5jb3JlLlJhdGVMaW1pdFNldHRpbmdz",
            "EiYKHnNldF9ub2RlX29uX2ZpcnN0X21lc3NhZ2Vfb25seRgHIAEoCCJOCgdB",
            "cGlUeXBlEh8KF1VOU1VQUE9SVEVEX1JFU1RfTEVHQUNZEAAaAggBEggKBFJF",
            "U1QQARIICgRHUlBDEAISDgoKREVMVEFfR1JQQxADIhgKFkFnZ3JlZ2F0ZWRD",
            "b25maWdTb3VyY2UiiAEKEVJhdGVMaW1pdFNldHRpbmdzEjAKCm1heF90b2tl",
            "bnMYASABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUSQQoJZmls",
            "bF9yYXRlGAIgASgLMhwuZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlQhC6",
            "6cADCxIJIQAAAAAAAAAAIvUBCgxDb25maWdTb3VyY2USDgoEcGF0aBgBIAEo",
            "CUgAEj8KEWFwaV9jb25maWdfc291cmNlGAIgASgLMiIuZW52b3kuYXBpLnYy",
            "LmNvcmUuQXBpQ29uZmlnU291cmNlSAASOAoDYWRzGAMgASgLMikuZW52b3ku",
            "YXBpLnYyLmNvcmUuQWdncmVnYXRlZENvbmZpZ1NvdXJjZUgAEjgKFWluaXRp",
            "YWxfZmV0Y2hfdGltZW91dBgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJh",
            "dGlvbkIgChdjb25maWdfc291cmNlX3NwZWNpZmllchIFuOnAAwFCNgofaW8u",
            "ZW52b3lwcm94eS5lbnZveS5hcGkudjIuY29yZUIRQ29uZmlnU291cmNlUHJv",
            "dG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.GrpcServiceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.ApiConfigSource), global::Envoy.Api.V2.Core.ApiConfigSource.Parser, new[]{ "ApiType", "ClusterNames", "GrpcServices", "RefreshDelay", "RequestTimeout", "RateLimitSettings", "SetNodeOnFirstMessageOnly" }, null, new[]{ typeof(global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.AggregatedConfigSource), global::Envoy.Api.V2.Core.AggregatedConfigSource.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.RateLimitSettings), global::Envoy.Api.V2.Core.RateLimitSettings.Parser, new[]{ "MaxTokens", "FillRate" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.ConfigSource), global::Envoy.Api.V2.Core.ConfigSource.Parser, new[]{ "Path", "ApiConfigSource", "Ads", "InitialFetchTimeout" }, new[]{ "ConfigSourceSpecifier" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// API configuration source. This identifies the API type and cluster that Envoy
  /// will use to fetch an xDS API.
  /// </summary>
  public sealed partial class ApiConfigSource : pb::IMessage<ApiConfigSource> {
    private static readonly pb::MessageParser<ApiConfigSource> _parser = new pb::MessageParser<ApiConfigSource>(() => new ApiConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApiConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiConfigSource(ApiConfigSource other) : this() {
      apiType_ = other.apiType_;
      clusterNames_ = other.clusterNames_.Clone();
      grpcServices_ = other.grpcServices_.Clone();
      refreshDelay_ = other.refreshDelay_ != null ? other.refreshDelay_.Clone() : null;
      requestTimeout_ = other.requestTimeout_ != null ? other.requestTimeout_.Clone() : null;
      rateLimitSettings_ = other.rateLimitSettings_ != null ? other.rateLimitSettings_.Clone() : null;
      setNodeOnFirstMessageOnly_ = other.setNodeOnFirstMessageOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApiConfigSource Clone() {
      return new ApiConfigSource(this);
    }

    /// <summary>Field number for the "api_type" field.</summary>
    public const int ApiTypeFieldNumber = 1;
    private global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType apiType_ = global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType.UnsupportedRestLegacy;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType ApiType {
      get { return apiType_; }
      set {
        apiType_ = value;
      }
    }

    /// <summary>Field number for the "cluster_names" field.</summary>
    public const int ClusterNamesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_clusterNames_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> clusterNames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Cluster names should be used only with REST. If > 1
    /// cluster is defined, clusters will be cycled through if any kind of failure
    /// occurs.
    ///
    /// .. note::
    ///
    ///  The cluster with name ``cluster_name`` must be statically defined and its
    ///  type must not be ``EDS``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ClusterNames {
      get { return clusterNames_; }
    }

    /// <summary>Field number for the "grpc_services" field.</summary>
    public const int GrpcServicesFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.GrpcService> _repeated_grpcServices_codec
        = pb::FieldCodec.ForMessage(34, global::Envoy.Api.V2.Core.GrpcService.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.GrpcService> grpcServices_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.GrpcService>();
    /// <summary>
    /// Multiple gRPC services be provided for GRPC. If > 1 cluster is defined,
    /// services will be cycled through if any kind of failure occurs.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.GrpcService> GrpcServices {
      get { return grpcServices_; }
    }

    /// <summary>Field number for the "refresh_delay" field.</summary>
    public const int RefreshDelayFieldNumber = 3;
    private global::Google.Protobuf.WellKnownTypes.Duration refreshDelay_;
    /// <summary>
    /// For REST APIs, the delay between successive polls.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration RefreshDelay {
      get { return refreshDelay_; }
      set {
        refreshDelay_ = value;
      }
    }

    /// <summary>Field number for the "request_timeout" field.</summary>
    public const int RequestTimeoutFieldNumber = 5;
    private global::Google.Protobuf.WellKnownTypes.Duration requestTimeout_;
    /// <summary>
    /// For REST APIs, the request timeout. If not set, a default value of 1s will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration RequestTimeout {
      get { return requestTimeout_; }
      set {
        requestTimeout_ = value;
      }
    }

    /// <summary>Field number for the "rate_limit_settings" field.</summary>
    public const int RateLimitSettingsFieldNumber = 6;
    private global::Envoy.Api.V2.Core.RateLimitSettings rateLimitSettings_;
    /// <summary>
    /// For GRPC APIs, the rate limit settings. If present, discovery requests made by Envoy will be
    /// rate limited.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.RateLimitSettings RateLimitSettings {
      get { return rateLimitSettings_; }
      set {
        rateLimitSettings_ = value;
      }
    }

    /// <summary>Field number for the "set_node_on_first_message_only" field.</summary>
    public const int SetNodeOnFirstMessageOnlyFieldNumber = 7;
    private bool setNodeOnFirstMessageOnly_;
    /// <summary>
    /// Skip the node identifier in subsequent discovery requests for streaming gRPC config types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SetNodeOnFirstMessageOnly {
      get { return setNodeOnFirstMessageOnly_; }
      set {
        setNodeOnFirstMessageOnly_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApiConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApiConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ApiType != other.ApiType) return false;
      if(!clusterNames_.Equals(other.clusterNames_)) return false;
      if(!grpcServices_.Equals(other.grpcServices_)) return false;
      if (!object.Equals(RefreshDelay, other.RefreshDelay)) return false;
      if (!object.Equals(RequestTimeout, other.RequestTimeout)) return false;
      if (!object.Equals(RateLimitSettings, other.RateLimitSettings)) return false;
      if (SetNodeOnFirstMessageOnly != other.SetNodeOnFirstMessageOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ApiType != global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType.UnsupportedRestLegacy) hash ^= ApiType.GetHashCode();
      hash ^= clusterNames_.GetHashCode();
      hash ^= grpcServices_.GetHashCode();
      if (refreshDelay_ != null) hash ^= RefreshDelay.GetHashCode();
      if (requestTimeout_ != null) hash ^= RequestTimeout.GetHashCode();
      if (rateLimitSettings_ != null) hash ^= RateLimitSettings.GetHashCode();
      if (SetNodeOnFirstMessageOnly != false) hash ^= SetNodeOnFirstMessageOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ApiType != global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType.UnsupportedRestLegacy) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ApiType);
      }
      clusterNames_.WriteTo(output, _repeated_clusterNames_codec);
      if (refreshDelay_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RefreshDelay);
      }
      grpcServices_.WriteTo(output, _repeated_grpcServices_codec);
      if (requestTimeout_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(RequestTimeout);
      }
      if (rateLimitSettings_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RateLimitSettings);
      }
      if (SetNodeOnFirstMessageOnly != false) {
        output.WriteRawTag(56);
        output.WriteBool(SetNodeOnFirstMessageOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ApiType != global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType.UnsupportedRestLegacy) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ApiType);
      }
      size += clusterNames_.CalculateSize(_repeated_clusterNames_codec);
      size += grpcServices_.CalculateSize(_repeated_grpcServices_codec);
      if (refreshDelay_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RefreshDelay);
      }
      if (requestTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestTimeout);
      }
      if (rateLimitSettings_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RateLimitSettings);
      }
      if (SetNodeOnFirstMessageOnly != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApiConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.ApiType != global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType.UnsupportedRestLegacy) {
        ApiType = other.ApiType;
      }
      clusterNames_.Add(other.clusterNames_);
      grpcServices_.Add(other.grpcServices_);
      if (other.refreshDelay_ != null) {
        if (refreshDelay_ == null) {
          RefreshDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RefreshDelay.MergeFrom(other.RefreshDelay);
      }
      if (other.requestTimeout_ != null) {
        if (requestTimeout_ == null) {
          RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RequestTimeout.MergeFrom(other.RequestTimeout);
      }
      if (other.rateLimitSettings_ != null) {
        if (rateLimitSettings_ == null) {
          RateLimitSettings = new global::Envoy.Api.V2.Core.RateLimitSettings();
        }
        RateLimitSettings.MergeFrom(other.RateLimitSettings);
      }
      if (other.SetNodeOnFirstMessageOnly != false) {
        SetNodeOnFirstMessageOnly = other.SetNodeOnFirstMessageOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ApiType = (global::Envoy.Api.V2.Core.ApiConfigSource.Types.ApiType) input.ReadEnum();
            break;
          }
          case 18: {
            clusterNames_.AddEntriesFrom(input, _repeated_clusterNames_codec);
            break;
          }
          case 26: {
            if (refreshDelay_ == null) {
              RefreshDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RefreshDelay);
            break;
          }
          case 34: {
            grpcServices_.AddEntriesFrom(input, _repeated_grpcServices_codec);
            break;
          }
          case 42: {
            if (requestTimeout_ == null) {
              RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestTimeout);
            break;
          }
          case 50: {
            if (rateLimitSettings_ == null) {
              RateLimitSettings = new global::Envoy.Api.V2.Core.RateLimitSettings();
            }
            input.ReadMessage(RateLimitSettings);
            break;
          }
          case 56: {
            SetNodeOnFirstMessageOnly = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ApiConfigSource message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// APIs may be fetched via either REST or gRPC.
      /// </summary>
      public enum ApiType {
        /// <summary>
        /// Ideally this would be 'reserved 0' but one can't reserve the default
        /// value. Instead we throw an exception if this is ever used.
        /// </summary>
        [pbr::OriginalName("UNSUPPORTED_REST_LEGACY")] UnsupportedRestLegacy = 0,
        /// <summary>
        /// REST-JSON v2 API. The `canonical JSON encoding
        /// &lt;https://developers.google.com/protocol-buffers/docs/proto3#json>`_ for
        /// the v2 protos is used.
        /// </summary>
        [pbr::OriginalName("REST")] Rest = 1,
        /// <summary>
        /// gRPC v2 API.
        /// </summary>
        [pbr::OriginalName("GRPC")] Grpc = 2,
        /// <summary>
        /// Using the delta xDS gRPC service, i.e. DeltaDiscovery{Request,Response}
        /// rather than Discovery{Request,Response}. Rather than sending Envoy the entire state
        /// with every update, the xDS server only sends what has changed since the last update.
        ///
        /// DELTA_GRPC is not yet entirely implemented! Initially, only CDS is available.
        /// Do not use for other xDSes. TODO(fredlas) update/remove this warning when appropriate.
        /// </summary>
        [pbr::OriginalName("DELTA_GRPC")] DeltaGrpc = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// Aggregated Discovery Service (ADS) options. This is currently empty, but when
  /// set in :ref:`ConfigSource &lt;envoy_api_msg_core.ConfigSource>` can be used to
  /// specify that ADS is to be used.
  /// </summary>
  public sealed partial class AggregatedConfigSource : pb::IMessage<AggregatedConfigSource> {
    private static readonly pb::MessageParser<AggregatedConfigSource> _parser = new pb::MessageParser<AggregatedConfigSource>(() => new AggregatedConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AggregatedConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AggregatedConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AggregatedConfigSource(AggregatedConfigSource other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AggregatedConfigSource Clone() {
      return new AggregatedConfigSource(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AggregatedConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AggregatedConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AggregatedConfigSource other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Rate Limit settings to be applied for discovery requests made by Envoy.
  /// </summary>
  public sealed partial class RateLimitSettings : pb::IMessage<RateLimitSettings> {
    private static readonly pb::MessageParser<RateLimitSettings> _parser = new pb::MessageParser<RateLimitSettings>(() => new RateLimitSettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RateLimitSettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimitSettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimitSettings(RateLimitSettings other) : this() {
      MaxTokens = other.MaxTokens;
      FillRate = other.FillRate;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RateLimitSettings Clone() {
      return new RateLimitSettings(this);
    }

    /// <summary>Field number for the "max_tokens" field.</summary>
    public const int MaxTokensFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_maxTokens_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? maxTokens_;
    /// <summary>
    /// Maximum number of tokens to be used for rate limiting discovery request calls. If not set, a
    /// default value of 100 will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxTokens {
      get { return maxTokens_; }
      set {
        maxTokens_ = value;
      }
    }


    /// <summary>Field number for the "fill_rate" field.</summary>
    public const int FillRateFieldNumber = 2;
    private static readonly pb::FieldCodec<double?> _single_fillRate_codec = pb::FieldCodec.ForStructWrapper<double>(18);
    private double? fillRate_;
    /// <summary>
    /// Rate at which tokens will be filled per second. If not set, a default fill rate of 10 tokens
    /// per second will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double? FillRate {
      get { return fillRate_; }
      set {
        fillRate_ = value;
      }
    }


    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RateLimitSettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RateLimitSettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxTokens != other.MaxTokens) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.Equals(FillRate, other.FillRate)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (maxTokens_ != null) hash ^= MaxTokens.GetHashCode();
      if (fillRate_ != null) hash ^= pbc::ProtobufEqualityComparers.BitwiseNullableDoubleEqualityComparer.GetHashCode(FillRate);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (maxTokens_ != null) {
        _single_maxTokens_codec.WriteTagAndValue(output, MaxTokens);
      }
      if (fillRate_ != null) {
        _single_fillRate_codec.WriteTagAndValue(output, FillRate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (maxTokens_ != null) {
        size += _single_maxTokens_codec.CalculateSizeWithTag(MaxTokens);
      }
      if (fillRate_ != null) {
        size += _single_fillRate_codec.CalculateSizeWithTag(FillRate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RateLimitSettings other) {
      if (other == null) {
        return;
      }
      if (other.maxTokens_ != null) {
        if (maxTokens_ == null || other.MaxTokens != 0) {
          MaxTokens = other.MaxTokens;
        }
      }
      if (other.fillRate_ != null) {
        if (fillRate_ == null || other.FillRate != 0D) {
          FillRate = other.FillRate;
        }
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_maxTokens_codec.Read(input);
            if (maxTokens_ == null || value != 0) {
              MaxTokens = value;
            }
            break;
          }
          case 18: {
            double? value = _single_fillRate_codec.Read(input);
            if (fillRate_ == null || value != 0D) {
              FillRate = value;
            }
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration for :ref:`listeners &lt;config_listeners>`, :ref:`clusters
  /// &lt;config_cluster_manager>`, :ref:`routes
  /// &lt;envoy_api_msg_RouteConfiguration>`, :ref:`endpoints
  /// &lt;arch_overview_service_discovery>` etc. may either be sourced from the
  /// filesystem or from an xDS API source. Filesystem configs are watched with
  /// inotify for updates.
  /// </summary>
  public sealed partial class ConfigSource : pb::IMessage<ConfigSource> {
    private static readonly pb::MessageParser<ConfigSource> _parser = new pb::MessageParser<ConfigSource>(() => new ConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigSource(ConfigSource other) : this() {
      initialFetchTimeout_ = other.initialFetchTimeout_ != null ? other.initialFetchTimeout_.Clone() : null;
      switch (other.ConfigSourceSpecifierCase) {
        case ConfigSourceSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case ConfigSourceSpecifierOneofCase.ApiConfigSource:
          ApiConfigSource = other.ApiConfigSource.Clone();
          break;
        case ConfigSourceSpecifierOneofCase.Ads:
          Ads = other.Ads.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigSource Clone() {
      return new ConfigSource(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    /// <summary>
    /// Path on the filesystem to source and watch for configuration updates.
    ///
    /// .. note::
    ///
    ///  The path to the source must exist at config load time.
    ///
    /// .. note::
    ///
    ///   Envoy will only watch the file path for *moves.* This is because in general only moves
    ///   are atomic. The same method of swapping files as is demonstrated in the
    ///   :ref:`runtime documentation &lt;config_runtime_symbolic_link_swap>` can be used here also.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Path {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path ? (string) configSourceSpecifier_ : ""; }
      set {
        configSourceSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.Path;
      }
    }

    /// <summary>Field number for the "api_config_source" field.</summary>
    public const int ApiConfigSourceFieldNumber = 2;
    /// <summary>
    /// API configuration source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.ApiConfigSource ApiConfigSource {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource ? (global::Envoy.Api.V2.Core.ApiConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.ApiConfigSource;
      }
    }

    /// <summary>Field number for the "ads" field.</summary>
    public const int AdsFieldNumber = 3;
    /// <summary>
    /// When set, ADS will be used to fetch resources. The ADS API configuration
    /// source in the bootstrap configuration is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.AggregatedConfigSource Ads {
      get { return configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads ? (global::Envoy.Api.V2.Core.AggregatedConfigSource) configSourceSpecifier_ : null; }
      set {
        configSourceSpecifier_ = value;
        configSourceSpecifierCase_ = value == null ? ConfigSourceSpecifierOneofCase.None : ConfigSourceSpecifierOneofCase.Ads;
      }
    }

    /// <summary>Field number for the "initial_fetch_timeout" field.</summary>
    public const int InitialFetchTimeoutFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration initialFetchTimeout_;
    /// <summary>
    /// When this timeout is specified, Envoy will wait no longer than the specified time for first
    /// config response on this xDS subscription during the :ref:`initialization process
    /// &lt;arch_overview_initialization>`. After reaching the timeout, Envoy will move to the next
    /// initialization phase, even if the first config is not delivered yet. The timer is activated
    /// when the xDS API subscription starts, and is disarmed on first config update or on error. 0
    /// means no timeout - Envoy will wait indefinitely for the first xDS config (unless another
    /// timeout applies). The default is 15s.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration InitialFetchTimeout {
      get { return initialFetchTimeout_; }
      set {
        initialFetchTimeout_ = value;
      }
    }

    private object configSourceSpecifier_;
    /// <summary>Enum of possible cases for the "config_source_specifier" oneof.</summary>
    public enum ConfigSourceSpecifierOneofCase {
      None = 0,
      Path = 1,
      ApiConfigSource = 2,
      Ads = 3,
    }
    private ConfigSourceSpecifierOneofCase configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigSourceSpecifierOneofCase ConfigSourceSpecifierCase {
      get { return configSourceSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConfigSourceSpecifier() {
      configSourceSpecifierCase_ = ConfigSourceSpecifierOneofCase.None;
      configSourceSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if (!object.Equals(ApiConfigSource, other.ApiConfigSource)) return false;
      if (!object.Equals(Ads, other.Ads)) return false;
      if (!object.Equals(InitialFetchTimeout, other.InitialFetchTimeout)) return false;
      if (ConfigSourceSpecifierCase != other.ConfigSourceSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) hash ^= Path.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) hash ^= ApiConfigSource.GetHashCode();
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) hash ^= Ads.GetHashCode();
      if (initialFetchTimeout_ != null) hash ^= InitialFetchTimeout.GetHashCode();
      hash ^= (int) configSourceSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
        output.WriteRawTag(18);
        output.WriteMessage(ApiConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
        output.WriteRawTag(26);
        output.WriteMessage(Ads);
      }
      if (initialFetchTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(InitialFetchTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Path) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ApiConfigSource);
      }
      if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Ads);
      }
      if (initialFetchTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialFetchTimeout);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.initialFetchTimeout_ != null) {
        if (initialFetchTimeout_ == null) {
          InitialFetchTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        InitialFetchTimeout.MergeFrom(other.InitialFetchTimeout);
      }
      switch (other.ConfigSourceSpecifierCase) {
        case ConfigSourceSpecifierOneofCase.Path:
          Path = other.Path;
          break;
        case ConfigSourceSpecifierOneofCase.ApiConfigSource:
          if (ApiConfigSource == null) {
            ApiConfigSource = new global::Envoy.Api.V2.Core.ApiConfigSource();
          }
          ApiConfigSource.MergeFrom(other.ApiConfigSource);
          break;
        case ConfigSourceSpecifierOneofCase.Ads:
          if (Ads == null) {
            Ads = new global::Envoy.Api.V2.Core.AggregatedConfigSource();
          }
          Ads.MergeFrom(other.Ads);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            global::Envoy.Api.V2.Core.ApiConfigSource subBuilder = new global::Envoy.Api.V2.Core.ApiConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.ApiConfigSource) {
              subBuilder.MergeFrom(ApiConfigSource);
            }
            input.ReadMessage(subBuilder);
            ApiConfigSource = subBuilder;
            break;
          }
          case 26: {
            global::Envoy.Api.V2.Core.AggregatedConfigSource subBuilder = new global::Envoy.Api.V2.Core.AggregatedConfigSource();
            if (configSourceSpecifierCase_ == ConfigSourceSpecifierOneofCase.Ads) {
              subBuilder.MergeFrom(Ads);
            }
            input.ReadMessage(subBuilder);
            Ads = subBuilder;
            break;
          }
          case 34: {
            if (initialFetchTimeout_ == null) {
              InitialFetchTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(InitialFetchTimeout);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
