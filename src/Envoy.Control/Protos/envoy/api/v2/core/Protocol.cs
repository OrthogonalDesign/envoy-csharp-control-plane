// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/api/v2/core/protocol.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2.Core {

  /// <summary>Holder for reflection information generated from envoy/api/v2/core/protocol.proto</summary>
  public static partial class ProtocolReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/api/v2/core/protocol.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ProtocolReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiBlbnZveS9hcGkvdjIvY29yZS9wcm90b2NvbC5wcm90bxIRZW52b3kuYXBp",
            "LnYyLmNvcmUaHmdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90bxoeZ29v",
            "Z2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvGhd2YWxpZGF0ZS92YWxpZGF0",
            "ZS5wcm90byIUChJUY3BQcm90b2NvbE9wdGlvbnMiRgoTSHR0cFByb3RvY29s",
            "T3B0aW9ucxIvCgxpZGxlX3RpbWVvdXQYASABKAsyGS5nb29nbGUucHJvdG9i",
            "dWYuRHVyYXRpb24iiAEKFEh0dHAxUHJvdG9jb2xPcHRpb25zEjYKEmFsbG93",
            "X2Fic29sdXRlX3VybBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFs",
            "dWUSFgoOYWNjZXB0X2h0dHBfMTAYAiABKAgSIAoYZGVmYXVsdF9ob3N0X2Zv",
            "cl9odHRwXzEwGAMgASgJIswGChRIdHRwMlByb3RvY29sT3B0aW9ucxI2ChBo",
            "cGFja190YWJsZV9zaXplGAEgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQz",
            "MlZhbHVlEk0KFm1heF9jb25jdXJyZW50X3N0cmVhbXMYAiABKAsyHC5nb29n",
            "bGUucHJvdG9idWYuVUludDMyVmFsdWVCD7rpwAMKKggY/////wcoARJTChpp",
            "bml0aWFsX3N0cmVhbV93aW5kb3dfc2l6ZRgDIAEoCzIcLmdvb2dsZS5wcm90",
            "b2J1Zi5VSW50MzJWYWx1ZUIRuunAAwwqChj/////Byj//wMSVwoeaW5pdGlh",
            "bF9jb25uZWN0aW9uX3dpbmRvd19zaXplGAQgASgLMhwuZ29vZ2xlLnByb3Rv",
            "YnVmLlVJbnQzMlZhbHVlQhG66cADDCoKGP////8HKP//AxIVCg1hbGxvd19j",
            "b25uZWN0GAUgASgIEhYKDmFsbG93X21ldGFkYXRhGAYgASgIEkQKE21heF9v",
            "dXRib3VuZF9mcmFtZXMYByABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMy",
            "VmFsdWVCCbrpwAMEKgIoARJMChttYXhfb3V0Ym91bmRfY29udHJvbF9mcmFt",
            "ZXMYCCABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCCbrpwAME",
            "KgIoARJXCjFtYXhfY29uc2VjdXRpdmVfaW5ib3VuZF9mcmFtZXNfd2l0aF9l",
            "bXB0eV9wYXlsb2FkGAkgASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZh",
            "bHVlEkwKJm1heF9pbmJvdW5kX3ByaW9yaXR5X2ZyYW1lc19wZXJfc3RyZWFt",
            "GAogASgLMhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlEmUKNG1heF9p",
            "bmJvdW5kX3dpbmRvd191cGRhdGVfZnJhbWVzX3Blcl9kYXRhX2ZyYW1lX3Nl",
            "bnQYCyABKAsyHC5nb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVCCbrpwAME",
            "KgIoARIuCiZzdHJlYW1fZXJyb3Jfb25faW52YWxpZF9odHRwX21lc3NhZ2lu",
            "ZxgMIAEoCCJeChNHcnBjUHJvdG9jb2xPcHRpb25zEkcKFmh0dHAyX3Byb3Rv",
            "Y29sX29wdGlvbnMYASABKAsyJy5lbnZveS5hcGkudjIuY29yZS5IdHRwMlBy",
            "b3RvY29sT3B0aW9uc0IyCh9pby5lbnZveXByb3h5LmVudm95LmFwaS52Mi5j",
            "b3JlQg1Qcm90b2NvbFByb3RvUAFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.TcpProtocolOptions), global::Envoy.Api.V2.Core.TcpProtocolOptions.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.HttpProtocolOptions), global::Envoy.Api.V2.Core.HttpProtocolOptions.Parser, new[]{ "IdleTimeout" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Http1ProtocolOptions), global::Envoy.Api.V2.Core.Http1ProtocolOptions.Parser, new[]{ "AllowAbsoluteUrl", "AcceptHttp10", "DefaultHostForHttp10" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Http2ProtocolOptions), global::Envoy.Api.V2.Core.Http2ProtocolOptions.Parser, new[]{ "HpackTableSize", "MaxConcurrentStreams", "InitialStreamWindowSize", "InitialConnectionWindowSize", "AllowConnect", "AllowMetadata", "MaxOutboundFrames", "MaxOutboundControlFrames", "MaxConsecutiveInboundFramesWithEmptyPayload", "MaxInboundPriorityFramesPerStream", "MaxInboundWindowUpdateFramesPerDataFrameSent", "StreamErrorOnInvalidHttpMessaging" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.GrpcProtocolOptions), global::Envoy.Api.V2.Core.GrpcProtocolOptions.Parser, new[]{ "Http2ProtocolOptions" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class TcpProtocolOptions : pb::IMessage<TcpProtocolOptions> {
    private static readonly pb::MessageParser<TcpProtocolOptions> _parser = new pb::MessageParser<TcpProtocolOptions>(() => new TcpProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TcpProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TcpProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TcpProtocolOptions(TcpProtocolOptions other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TcpProtocolOptions Clone() {
      return new TcpProtocolOptions(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TcpProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TcpProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TcpProtocolOptions other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class HttpProtocolOptions : pb::IMessage<HttpProtocolOptions> {
    private static readonly pb::MessageParser<HttpProtocolOptions> _parser = new pb::MessageParser<HttpProtocolOptions>(() => new HttpProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HttpProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpProtocolOptions(HttpProtocolOptions other) : this() {
      idleTimeout_ = other.idleTimeout_ != null ? other.idleTimeout_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpProtocolOptions Clone() {
      return new HttpProtocolOptions(this);
    }

    /// <summary>Field number for the "idle_timeout" field.</summary>
    public const int IdleTimeoutFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
    /// <summary>
    /// The idle timeout for upstream connection pool connections. The idle timeout is defined as the
    /// period in which there are no active requests. If not set, there is no idle timeout. When the
    /// idle timeout is reached the connection will be closed. Note that request based timeouts mean
    /// that HTTP/2 PINGs will not keep the connection alive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
      get { return idleTimeout_; }
      set {
        idleTimeout_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HttpProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HttpProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (idleTimeout_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(IdleTimeout);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (idleTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HttpProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.idleTimeout_ != null) {
        if (idleTimeout_ == null) {
          IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        IdleTimeout.MergeFrom(other.IdleTimeout);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
        }
      }
    }

  }

  public sealed partial class Http1ProtocolOptions : pb::IMessage<Http1ProtocolOptions> {
    private static readonly pb::MessageParser<Http1ProtocolOptions> _parser = new pb::MessageParser<Http1ProtocolOptions>(() => new Http1ProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Http1ProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Http1ProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Http1ProtocolOptions(Http1ProtocolOptions other) : this() {
      AllowAbsoluteUrl = other.AllowAbsoluteUrl;
      acceptHttp10_ = other.acceptHttp10_;
      defaultHostForHttp10_ = other.defaultHostForHttp10_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Http1ProtocolOptions Clone() {
      return new Http1ProtocolOptions(this);
    }

    /// <summary>Field number for the "allow_absolute_url" field.</summary>
    public const int AllowAbsoluteUrlFieldNumber = 1;
    private static readonly pb::FieldCodec<bool?> _single_allowAbsoluteUrl_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
    private bool? allowAbsoluteUrl_;
    /// <summary>
    /// Handle HTTP requests with absolute URLs in the requests. These requests
    /// are generally sent by clients to forward/explicit proxies. This allows clients to configure
    /// envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
    /// *http_proxy* environment variable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? AllowAbsoluteUrl {
      get { return allowAbsoluteUrl_; }
      set {
        allowAbsoluteUrl_ = value;
      }
    }


    /// <summary>Field number for the "accept_http_10" field.</summary>
    public const int AcceptHttp10FieldNumber = 2;
    private bool acceptHttp10_;
    /// <summary>
    /// Handle incoming HTTP/1.0 and HTTP 0.9 requests.
    /// This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
    /// style connect logic, dechunking, and handling lack of client host iff
    /// *default_host_for_http_10* is configured.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AcceptHttp10 {
      get { return acceptHttp10_; }
      set {
        acceptHttp10_ = value;
      }
    }

    /// <summary>Field number for the "default_host_for_http_10" field.</summary>
    public const int DefaultHostForHttp10FieldNumber = 3;
    private string defaultHostForHttp10_ = "";
    /// <summary>
    /// A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
    /// Envoy does not otherwise support HTTP/1.0 without a Host header.
    /// This is a no-op if *accept_http_10* is not true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DefaultHostForHttp10 {
      get { return defaultHostForHttp10_; }
      set {
        defaultHostForHttp10_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Http1ProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Http1ProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AllowAbsoluteUrl != other.AllowAbsoluteUrl) return false;
      if (AcceptHttp10 != other.AcceptHttp10) return false;
      if (DefaultHostForHttp10 != other.DefaultHostForHttp10) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (allowAbsoluteUrl_ != null) hash ^= AllowAbsoluteUrl.GetHashCode();
      if (AcceptHttp10 != false) hash ^= AcceptHttp10.GetHashCode();
      if (DefaultHostForHttp10.Length != 0) hash ^= DefaultHostForHttp10.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (allowAbsoluteUrl_ != null) {
        _single_allowAbsoluteUrl_codec.WriteTagAndValue(output, AllowAbsoluteUrl);
      }
      if (AcceptHttp10 != false) {
        output.WriteRawTag(16);
        output.WriteBool(AcceptHttp10);
      }
      if (DefaultHostForHttp10.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DefaultHostForHttp10);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (allowAbsoluteUrl_ != null) {
        size += _single_allowAbsoluteUrl_codec.CalculateSizeWithTag(AllowAbsoluteUrl);
      }
      if (AcceptHttp10 != false) {
        size += 1 + 1;
      }
      if (DefaultHostForHttp10.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DefaultHostForHttp10);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Http1ProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.allowAbsoluteUrl_ != null) {
        if (allowAbsoluteUrl_ == null || other.AllowAbsoluteUrl != false) {
          AllowAbsoluteUrl = other.AllowAbsoluteUrl;
        }
      }
      if (other.AcceptHttp10 != false) {
        AcceptHttp10 = other.AcceptHttp10;
      }
      if (other.DefaultHostForHttp10.Length != 0) {
        DefaultHostForHttp10 = other.DefaultHostForHttp10;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            bool? value = _single_allowAbsoluteUrl_codec.Read(input);
            if (allowAbsoluteUrl_ == null || value != false) {
              AllowAbsoluteUrl = value;
            }
            break;
          }
          case 16: {
            AcceptHttp10 = input.ReadBool();
            break;
          }
          case 26: {
            DefaultHostForHttp10 = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// [#comment:next free field: 13]
  /// </summary>
  public sealed partial class Http2ProtocolOptions : pb::IMessage<Http2ProtocolOptions> {
    private static readonly pb::MessageParser<Http2ProtocolOptions> _parser = new pb::MessageParser<Http2ProtocolOptions>(() => new Http2ProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Http2ProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Http2ProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Http2ProtocolOptions(Http2ProtocolOptions other) : this() {
      HpackTableSize = other.HpackTableSize;
      MaxConcurrentStreams = other.MaxConcurrentStreams;
      InitialStreamWindowSize = other.InitialStreamWindowSize;
      InitialConnectionWindowSize = other.InitialConnectionWindowSize;
      allowConnect_ = other.allowConnect_;
      allowMetadata_ = other.allowMetadata_;
      MaxOutboundFrames = other.MaxOutboundFrames;
      MaxOutboundControlFrames = other.MaxOutboundControlFrames;
      MaxConsecutiveInboundFramesWithEmptyPayload = other.MaxConsecutiveInboundFramesWithEmptyPayload;
      MaxInboundPriorityFramesPerStream = other.MaxInboundPriorityFramesPerStream;
      MaxInboundWindowUpdateFramesPerDataFrameSent = other.MaxInboundWindowUpdateFramesPerDataFrameSent;
      streamErrorOnInvalidHttpMessaging_ = other.streamErrorOnInvalidHttpMessaging_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Http2ProtocolOptions Clone() {
      return new Http2ProtocolOptions(this);
    }

    /// <summary>Field number for the "hpack_table_size" field.</summary>
    public const int HpackTableSizeFieldNumber = 1;
    private static readonly pb::FieldCodec<uint?> _single_hpackTableSize_codec = pb::FieldCodec.ForStructWrapper<uint>(10);
    private uint? hpackTableSize_;
    /// <summary>
    /// `Maximum table size &lt;https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
    /// (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
    /// range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
    /// compression.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? HpackTableSize {
      get { return hpackTableSize_; }
      set {
        hpackTableSize_ = value;
      }
    }


    /// <summary>Field number for the "max_concurrent_streams" field.</summary>
    public const int MaxConcurrentStreamsFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_maxConcurrentStreams_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? maxConcurrentStreams_;
    /// <summary>
    /// `Maximum concurrent streams &lt;https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
    /// allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
    /// and defaults to 2147483647.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxConcurrentStreams {
      get { return maxConcurrentStreams_; }
      set {
        maxConcurrentStreams_ = value;
      }
    }


    /// <summary>Field number for the "initial_stream_window_size" field.</summary>
    public const int InitialStreamWindowSizeFieldNumber = 3;
    private static readonly pb::FieldCodec<uint?> _single_initialStreamWindowSize_codec = pb::FieldCodec.ForStructWrapper<uint>(26);
    private uint? initialStreamWindowSize_;
    /// <summary>
    /// This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
    /// HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
    /// stop the flow of data to the codec buffers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? InitialStreamWindowSize {
      get { return initialStreamWindowSize_; }
      set {
        initialStreamWindowSize_ = value;
      }
    }


    /// <summary>Field number for the "initial_connection_window_size" field.</summary>
    public const int InitialConnectionWindowSizeFieldNumber = 4;
    private static readonly pb::FieldCodec<uint?> _single_initialConnectionWindowSize_codec = pb::FieldCodec.ForStructWrapper<uint>(34);
    private uint? initialConnectionWindowSize_;
    /// <summary>
    /// Similar to *initial_stream_window_size*, but for connection-level flow-control
    /// window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? InitialConnectionWindowSize {
      get { return initialConnectionWindowSize_; }
      set {
        initialConnectionWindowSize_ = value;
      }
    }


    /// <summary>Field number for the "allow_connect" field.</summary>
    public const int AllowConnectFieldNumber = 5;
    private bool allowConnect_;
    /// <summary>
    /// Allows proxying Websocket and other upgrades over H2 connect.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowConnect {
      get { return allowConnect_; }
      set {
        allowConnect_ = value;
      }
    }

    /// <summary>Field number for the "allow_metadata" field.</summary>
    public const int AllowMetadataFieldNumber = 6;
    private bool allowMetadata_;
    /// <summary>
    /// [#not-implemented-hide:] Hiding until envoy has full metadata support.
    /// Still under implementation. DO NOT USE.
    ///
    /// Allows metadata. See [metadata
    /// docs](https://github.com/envoyproxy/envoy/blob/master/source/docs/h2_metadata.md) for more
    /// information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AllowMetadata {
      get { return allowMetadata_; }
      set {
        allowMetadata_ = value;
      }
    }

    /// <summary>Field number for the "max_outbound_frames" field.</summary>
    public const int MaxOutboundFramesFieldNumber = 7;
    private static readonly pb::FieldCodec<uint?> _single_maxOutboundFrames_codec = pb::FieldCodec.ForStructWrapper<uint>(58);
    private uint? maxOutboundFrames_;
    /// <summary>
    /// Limit the number of pending outbound downstream frames of all types (frames that are waiting to
    /// be written into the socket). Exceeding this limit triggers flood mitigation and connection is
    /// terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
    /// to flood mitigation. The default limit is 10000.
    /// [#comment:TODO: implement same limits for upstream outbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxOutboundFrames {
      get { return maxOutboundFrames_; }
      set {
        maxOutboundFrames_ = value;
      }
    }


    /// <summary>Field number for the "max_outbound_control_frames" field.</summary>
    public const int MaxOutboundControlFramesFieldNumber = 8;
    private static readonly pb::FieldCodec<uint?> _single_maxOutboundControlFrames_codec = pb::FieldCodec.ForStructWrapper<uint>(66);
    private uint? maxOutboundControlFrames_;
    /// <summary>
    /// Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
    /// preventing high memory utilization when receiving continuous stream of these frames. Exceeding
    /// this limit triggers flood mitigation and connection is terminated. The
    /// ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
    /// mitigation. The default limit is 1000.
    /// [#comment:TODO: implement same limits for upstream outbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxOutboundControlFrames {
      get { return maxOutboundControlFrames_; }
      set {
        maxOutboundControlFrames_ = value;
      }
    }


    /// <summary>Field number for the "max_consecutive_inbound_frames_with_empty_payload" field.</summary>
    public const int MaxConsecutiveInboundFramesWithEmptyPayloadFieldNumber = 9;
    private static readonly pb::FieldCodec<uint?> _single_maxConsecutiveInboundFramesWithEmptyPayload_codec = pb::FieldCodec.ForStructWrapper<uint>(74);
    private uint? maxConsecutiveInboundFramesWithEmptyPayload_;
    /// <summary>
    /// Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
    /// empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
    /// might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
    /// stat tracks the number of connections terminated due to flood mitigation.
    /// Setting this to 0 will terminate connection upon receiving first frame with an empty payload
    /// and no end stream flag. The default limit is 1.
    /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxConsecutiveInboundFramesWithEmptyPayload {
      get { return maxConsecutiveInboundFramesWithEmptyPayload_; }
      set {
        maxConsecutiveInboundFramesWithEmptyPayload_ = value;
      }
    }


    /// <summary>Field number for the "max_inbound_priority_frames_per_stream" field.</summary>
    public const int MaxInboundPriorityFramesPerStreamFieldNumber = 10;
    private static readonly pb::FieldCodec<uint?> _single_maxInboundPriorityFramesPerStream_codec = pb::FieldCodec.ForStructWrapper<uint>(82);
    private uint? maxInboundPriorityFramesPerStream_;
    /// <summary>
    /// Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
    /// of PRIORITY frames received over the lifetime of connection exceeds the value calculated
    /// using this formula::
    ///
    ///     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
    ///
    /// the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
    /// the number of connections terminated due to flood mitigation. The default limit is 100.
    /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxInboundPriorityFramesPerStream {
      get { return maxInboundPriorityFramesPerStream_; }
      set {
        maxInboundPriorityFramesPerStream_ = value;
      }
    }


    /// <summary>Field number for the "max_inbound_window_update_frames_per_data_frame_sent" field.</summary>
    public const int MaxInboundWindowUpdateFramesPerDataFrameSentFieldNumber = 11;
    private static readonly pb::FieldCodec<uint?> _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec = pb::FieldCodec.ForStructWrapper<uint>(90);
    private uint? maxInboundWindowUpdateFramesPerDataFrameSent_;
    /// <summary>
    /// Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
    /// of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
    /// using this formula::
    ///
    ///     1 + 2 * (inbound_streams +
    ///              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
    ///
    /// the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
    /// the number of connections terminated due to flood mitigation. The default limit is 10.
    /// Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
    /// but more complex implementations that try to estimate available bandwidth require at least 2.
    /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxInboundWindowUpdateFramesPerDataFrameSent {
      get { return maxInboundWindowUpdateFramesPerDataFrameSent_; }
      set {
        maxInboundWindowUpdateFramesPerDataFrameSent_ = value;
      }
    }


    /// <summary>Field number for the "stream_error_on_invalid_http_messaging" field.</summary>
    public const int StreamErrorOnInvalidHttpMessagingFieldNumber = 12;
    private bool streamErrorOnInvalidHttpMessaging_;
    /// <summary>
    /// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
    /// the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
    /// when this option is enabled, only the offending stream is terminated.
    ///
    /// See [RFC7540, sec. 8.1](https://tools.ietf.org/html/rfc7540#section-8.1) for details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StreamErrorOnInvalidHttpMessaging {
      get { return streamErrorOnInvalidHttpMessaging_; }
      set {
        streamErrorOnInvalidHttpMessaging_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Http2ProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Http2ProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (HpackTableSize != other.HpackTableSize) return false;
      if (MaxConcurrentStreams != other.MaxConcurrentStreams) return false;
      if (InitialStreamWindowSize != other.InitialStreamWindowSize) return false;
      if (InitialConnectionWindowSize != other.InitialConnectionWindowSize) return false;
      if (AllowConnect != other.AllowConnect) return false;
      if (AllowMetadata != other.AllowMetadata) return false;
      if (MaxOutboundFrames != other.MaxOutboundFrames) return false;
      if (MaxOutboundControlFrames != other.MaxOutboundControlFrames) return false;
      if (MaxConsecutiveInboundFramesWithEmptyPayload != other.MaxConsecutiveInboundFramesWithEmptyPayload) return false;
      if (MaxInboundPriorityFramesPerStream != other.MaxInboundPriorityFramesPerStream) return false;
      if (MaxInboundWindowUpdateFramesPerDataFrameSent != other.MaxInboundWindowUpdateFramesPerDataFrameSent) return false;
      if (StreamErrorOnInvalidHttpMessaging != other.StreamErrorOnInvalidHttpMessaging) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (hpackTableSize_ != null) hash ^= HpackTableSize.GetHashCode();
      if (maxConcurrentStreams_ != null) hash ^= MaxConcurrentStreams.GetHashCode();
      if (initialStreamWindowSize_ != null) hash ^= InitialStreamWindowSize.GetHashCode();
      if (initialConnectionWindowSize_ != null) hash ^= InitialConnectionWindowSize.GetHashCode();
      if (AllowConnect != false) hash ^= AllowConnect.GetHashCode();
      if (AllowMetadata != false) hash ^= AllowMetadata.GetHashCode();
      if (maxOutboundFrames_ != null) hash ^= MaxOutboundFrames.GetHashCode();
      if (maxOutboundControlFrames_ != null) hash ^= MaxOutboundControlFrames.GetHashCode();
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) hash ^= MaxConsecutiveInboundFramesWithEmptyPayload.GetHashCode();
      if (maxInboundPriorityFramesPerStream_ != null) hash ^= MaxInboundPriorityFramesPerStream.GetHashCode();
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) hash ^= MaxInboundWindowUpdateFramesPerDataFrameSent.GetHashCode();
      if (StreamErrorOnInvalidHttpMessaging != false) hash ^= StreamErrorOnInvalidHttpMessaging.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (hpackTableSize_ != null) {
        _single_hpackTableSize_codec.WriteTagAndValue(output, HpackTableSize);
      }
      if (maxConcurrentStreams_ != null) {
        _single_maxConcurrentStreams_codec.WriteTagAndValue(output, MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        _single_initialStreamWindowSize_codec.WriteTagAndValue(output, InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        _single_initialConnectionWindowSize_codec.WriteTagAndValue(output, InitialConnectionWindowSize);
      }
      if (AllowConnect != false) {
        output.WriteRawTag(40);
        output.WriteBool(AllowConnect);
      }
      if (AllowMetadata != false) {
        output.WriteRawTag(48);
        output.WriteBool(AllowMetadata);
      }
      if (maxOutboundFrames_ != null) {
        _single_maxOutboundFrames_codec.WriteTagAndValue(output, MaxOutboundFrames);
      }
      if (maxOutboundControlFrames_ != null) {
        _single_maxOutboundControlFrames_codec.WriteTagAndValue(output, MaxOutboundControlFrames);
      }
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.WriteTagAndValue(output, MaxConsecutiveInboundFramesWithEmptyPayload);
      }
      if (maxInboundPriorityFramesPerStream_ != null) {
        _single_maxInboundPriorityFramesPerStream_codec.WriteTagAndValue(output, MaxInboundPriorityFramesPerStream);
      }
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.WriteTagAndValue(output, MaxInboundWindowUpdateFramesPerDataFrameSent);
      }
      if (StreamErrorOnInvalidHttpMessaging != false) {
        output.WriteRawTag(96);
        output.WriteBool(StreamErrorOnInvalidHttpMessaging);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (hpackTableSize_ != null) {
        size += _single_hpackTableSize_codec.CalculateSizeWithTag(HpackTableSize);
      }
      if (maxConcurrentStreams_ != null) {
        size += _single_maxConcurrentStreams_codec.CalculateSizeWithTag(MaxConcurrentStreams);
      }
      if (initialStreamWindowSize_ != null) {
        size += _single_initialStreamWindowSize_codec.CalculateSizeWithTag(InitialStreamWindowSize);
      }
      if (initialConnectionWindowSize_ != null) {
        size += _single_initialConnectionWindowSize_codec.CalculateSizeWithTag(InitialConnectionWindowSize);
      }
      if (AllowConnect != false) {
        size += 1 + 1;
      }
      if (AllowMetadata != false) {
        size += 1 + 1;
      }
      if (maxOutboundFrames_ != null) {
        size += _single_maxOutboundFrames_codec.CalculateSizeWithTag(MaxOutboundFrames);
      }
      if (maxOutboundControlFrames_ != null) {
        size += _single_maxOutboundControlFrames_codec.CalculateSizeWithTag(MaxOutboundControlFrames);
      }
      if (maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        size += _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.CalculateSizeWithTag(MaxConsecutiveInboundFramesWithEmptyPayload);
      }
      if (maxInboundPriorityFramesPerStream_ != null) {
        size += _single_maxInboundPriorityFramesPerStream_codec.CalculateSizeWithTag(MaxInboundPriorityFramesPerStream);
      }
      if (maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        size += _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.CalculateSizeWithTag(MaxInboundWindowUpdateFramesPerDataFrameSent);
      }
      if (StreamErrorOnInvalidHttpMessaging != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Http2ProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.hpackTableSize_ != null) {
        if (hpackTableSize_ == null || other.HpackTableSize != 0) {
          HpackTableSize = other.HpackTableSize;
        }
      }
      if (other.maxConcurrentStreams_ != null) {
        if (maxConcurrentStreams_ == null || other.MaxConcurrentStreams != 0) {
          MaxConcurrentStreams = other.MaxConcurrentStreams;
        }
      }
      if (other.initialStreamWindowSize_ != null) {
        if (initialStreamWindowSize_ == null || other.InitialStreamWindowSize != 0) {
          InitialStreamWindowSize = other.InitialStreamWindowSize;
        }
      }
      if (other.initialConnectionWindowSize_ != null) {
        if (initialConnectionWindowSize_ == null || other.InitialConnectionWindowSize != 0) {
          InitialConnectionWindowSize = other.InitialConnectionWindowSize;
        }
      }
      if (other.AllowConnect != false) {
        AllowConnect = other.AllowConnect;
      }
      if (other.AllowMetadata != false) {
        AllowMetadata = other.AllowMetadata;
      }
      if (other.maxOutboundFrames_ != null) {
        if (maxOutboundFrames_ == null || other.MaxOutboundFrames != 0) {
          MaxOutboundFrames = other.MaxOutboundFrames;
        }
      }
      if (other.maxOutboundControlFrames_ != null) {
        if (maxOutboundControlFrames_ == null || other.MaxOutboundControlFrames != 0) {
          MaxOutboundControlFrames = other.MaxOutboundControlFrames;
        }
      }
      if (other.maxConsecutiveInboundFramesWithEmptyPayload_ != null) {
        if (maxConsecutiveInboundFramesWithEmptyPayload_ == null || other.MaxConsecutiveInboundFramesWithEmptyPayload != 0) {
          MaxConsecutiveInboundFramesWithEmptyPayload = other.MaxConsecutiveInboundFramesWithEmptyPayload;
        }
      }
      if (other.maxInboundPriorityFramesPerStream_ != null) {
        if (maxInboundPriorityFramesPerStream_ == null || other.MaxInboundPriorityFramesPerStream != 0) {
          MaxInboundPriorityFramesPerStream = other.MaxInboundPriorityFramesPerStream;
        }
      }
      if (other.maxInboundWindowUpdateFramesPerDataFrameSent_ != null) {
        if (maxInboundWindowUpdateFramesPerDataFrameSent_ == null || other.MaxInboundWindowUpdateFramesPerDataFrameSent != 0) {
          MaxInboundWindowUpdateFramesPerDataFrameSent = other.MaxInboundWindowUpdateFramesPerDataFrameSent;
        }
      }
      if (other.StreamErrorOnInvalidHttpMessaging != false) {
        StreamErrorOnInvalidHttpMessaging = other.StreamErrorOnInvalidHttpMessaging;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            uint? value = _single_hpackTableSize_codec.Read(input);
            if (hpackTableSize_ == null || value != 0) {
              HpackTableSize = value;
            }
            break;
          }
          case 18: {
            uint? value = _single_maxConcurrentStreams_codec.Read(input);
            if (maxConcurrentStreams_ == null || value != 0) {
              MaxConcurrentStreams = value;
            }
            break;
          }
          case 26: {
            uint? value = _single_initialStreamWindowSize_codec.Read(input);
            if (initialStreamWindowSize_ == null || value != 0) {
              InitialStreamWindowSize = value;
            }
            break;
          }
          case 34: {
            uint? value = _single_initialConnectionWindowSize_codec.Read(input);
            if (initialConnectionWindowSize_ == null || value != 0) {
              InitialConnectionWindowSize = value;
            }
            break;
          }
          case 40: {
            AllowConnect = input.ReadBool();
            break;
          }
          case 48: {
            AllowMetadata = input.ReadBool();
            break;
          }
          case 58: {
            uint? value = _single_maxOutboundFrames_codec.Read(input);
            if (maxOutboundFrames_ == null || value != 0) {
              MaxOutboundFrames = value;
            }
            break;
          }
          case 66: {
            uint? value = _single_maxOutboundControlFrames_codec.Read(input);
            if (maxOutboundControlFrames_ == null || value != 0) {
              MaxOutboundControlFrames = value;
            }
            break;
          }
          case 74: {
            uint? value = _single_maxConsecutiveInboundFramesWithEmptyPayload_codec.Read(input);
            if (maxConsecutiveInboundFramesWithEmptyPayload_ == null || value != 0) {
              MaxConsecutiveInboundFramesWithEmptyPayload = value;
            }
            break;
          }
          case 82: {
            uint? value = _single_maxInboundPriorityFramesPerStream_codec.Read(input);
            if (maxInboundPriorityFramesPerStream_ == null || value != 0) {
              MaxInboundPriorityFramesPerStream = value;
            }
            break;
          }
          case 90: {
            uint? value = _single_maxInboundWindowUpdateFramesPerDataFrameSent_codec.Read(input);
            if (maxInboundWindowUpdateFramesPerDataFrameSent_ == null || value != 0) {
              MaxInboundWindowUpdateFramesPerDataFrameSent = value;
            }
            break;
          }
          case 96: {
            StreamErrorOnInvalidHttpMessaging = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// [#not-implemented-hide:]
  /// </summary>
  public sealed partial class GrpcProtocolOptions : pb::IMessage<GrpcProtocolOptions> {
    private static readonly pb::MessageParser<GrpcProtocolOptions> _parser = new pb::MessageParser<GrpcProtocolOptions>(() => new GrpcProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GrpcProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GrpcProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GrpcProtocolOptions(GrpcProtocolOptions other) : this() {
      http2ProtocolOptions_ = other.http2ProtocolOptions_ != null ? other.http2ProtocolOptions_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GrpcProtocolOptions Clone() {
      return new GrpcProtocolOptions(this);
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 1;
    private global::Envoy.Api.V2.Core.Http2ProtocolOptions http2ProtocolOptions_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GrpcProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GrpcProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GrpcProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
