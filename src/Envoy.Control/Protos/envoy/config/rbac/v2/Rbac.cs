// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/rbac/v2/rbac.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Rbac.V2 {

  /// <summary>Holder for reflection information generated from envoy/config/rbac/v2/rbac.proto</summary>
  public static partial class RbacReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/rbac/v2/rbac.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RbacReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch9lbnZveS9jb25maWcvcmJhYy92Mi9yYmFjLnByb3RvEhRlbnZveS5jb25m",
            "aWcucmJhYy52MhoXdmFsaWRhdGUvdmFsaWRhdGUucHJvdG8aH2Vudm95L2Fw",
            "aS92Mi9jb3JlL2FkZHJlc3MucHJvdG8aHmVudm95L2FwaS92Mi9yb3V0ZS9y",
            "b3V0ZS5wcm90bxohZW52b3kvdHlwZS9tYXRjaGVyL21ldGFkYXRhLnByb3Rv",
            "Gh9lbnZveS90eXBlL21hdGNoZXIvc3RyaW5nLnByb3RvGiVnb29nbGUvYXBp",
            "L2V4cHIvdjFhbHBoYTEvc3ludGF4LnByb3RvIuMBCgRSQkFDEjEKBmFjdGlv",
            "bhgBIAEoDjIhLmVudm95LmNvbmZpZy5yYmFjLnYyLlJCQUMuQWN0aW9uEjoK",
            "CHBvbGljaWVzGAIgAygLMiguZW52b3kuY29uZmlnLnJiYWMudjIuUkJBQy5Q",
            "b2xpY2llc0VudHJ5Gk0KDVBvbGljaWVzRW50cnkSCwoDa2V5GAEgASgJEisK",
            "BXZhbHVlGAIgASgLMhwuZW52b3kuY29uZmlnLnJiYWMudjIuUG9saWN5OgI4",
            "ASIdCgZBY3Rpb24SCQoFQUxMT1cQABIICgRERU5ZEAEivwEKBlBvbGljeRJB",
            "CgtwZXJtaXNzaW9ucxgBIAMoCzIgLmVudm95LmNvbmZpZy5yYmFjLnYyLlBl",
            "cm1pc3Npb25CCrrpwAMFkgECCAESPwoKcHJpbmNpcGFscxgCIAMoCzIfLmVu",
            "dm95LmNvbmZpZy5yYmFjLnYyLlByaW5jaXBhbEIKuunAAwWSAQIIARIxCglj",
            "b25kaXRpb24YAyABKAsyHi5nb29nbGUuYXBpLmV4cHIudjFhbHBoYTEuRXhw",
            "ciK3BAoKUGVybWlzc2lvbhI5CglhbmRfcnVsZXMYASABKAsyJC5lbnZveS5j",
            "b25maWcucmJhYy52Mi5QZXJtaXNzaW9uLlNldEgAEjgKCG9yX3J1bGVzGAIg",
            "ASgLMiQuZW52b3kuY29uZmlnLnJiYWMudjIuUGVybWlzc2lvbi5TZXRIABIY",
            "CgNhbnkYAyABKAhCCbrpwAMEagIIAUgAEjMKBmhlYWRlchgEIAEoCzIhLmVu",
            "dm95LmFwaS52Mi5yb3V0ZS5IZWFkZXJNYXRjaGVySAASNgoOZGVzdGluYXRp",
            "b25faXAYBSABKAsyHC5lbnZveS5hcGkudjIuY29yZS5DaWRyUmFuZ2VIABIn",
            "ChBkZXN0aW5hdGlvbl9wb3J0GAYgASgNQgu66cADBioEGP//A0gAEjcKCG1l",
            "dGFkYXRhGAcgASgLMiMuZW52b3kudHlwZS5tYXRjaGVyLk1ldGFkYXRhTWF0",
            "Y2hlckgAEjQKCG5vdF9ydWxlGAggASgLMiAuZW52b3kuY29uZmlnLnJiYWMu",
            "djIuUGVybWlzc2lvbkgAEkIKFXJlcXVlc3RlZF9zZXJ2ZXJfbmFtZRgJIAEo",
            "CzIhLmVudm95LnR5cGUubWF0Y2hlci5TdHJpbmdNYXRjaGVySAAaQgoDU2V0",
            "EjsKBXJ1bGVzGAEgAygLMiAuZW52b3kuY29uZmlnLnJiYWMudjIuUGVybWlz",
            "c2lvbkIKuunAAwWSAQIIAUINCgRydWxlEgW46cADASLeBAoJUHJpbmNpcGFs",
            "EjYKB2FuZF9pZHMYASABKAsyIy5lbnZveS5jb25maWcucmJhYy52Mi5Qcmlu",
            "Y2lwYWwuU2V0SAASNQoGb3JfaWRzGAIgASgLMiMuZW52b3kuY29uZmlnLnJi",
            "YWMudjIuUHJpbmNpcGFsLlNldEgAEhgKA2FueRgDIAEoCEIJuunAAwRqAggB",
            "SAASRgoNYXV0aGVudGljYXRlZBgEIAEoCzItLmVudm95LmNvbmZpZy5yYmFj",
            "LnYyLlByaW5jaXBhbC5BdXRoZW50aWNhdGVkSAASMQoJc291cmNlX2lwGAUg",
            "ASgLMhwuZW52b3kuYXBpLnYyLmNvcmUuQ2lkclJhbmdlSAASMwoGaGVhZGVy",
            "GAYgASgLMiEuZW52b3kuYXBpLnYyLnJvdXRlLkhlYWRlck1hdGNoZXJIABI3",
            "CghtZXRhZGF0YRgHIAEoCzIjLmVudm95LnR5cGUubWF0Y2hlci5NZXRhZGF0",
            "YU1hdGNoZXJIABIxCgZub3RfaWQYCCABKAsyHy5lbnZveS5jb25maWcucmJh",
            "Yy52Mi5QcmluY2lwYWxIABo/CgNTZXQSOAoDaWRzGAEgAygLMh8uZW52b3ku",
            "Y29uZmlnLnJiYWMudjIuUHJpbmNpcGFsQgq66cADBZIBAggBGlYKDUF1dGhl",
            "bnRpY2F0ZWQSOQoOcHJpbmNpcGFsX25hbWUYAiABKAsyIS5lbnZveS50eXBl",
            "Lm1hdGNoZXIuU3RyaW5nTWF0Y2hlckoECAEQAlIEbmFtZUITCgppZGVudGlm",
            "aWVyEgW46cADAUIxCiJpby5lbnZveXByb3h5LmVudm95LmNvbmZpZy5yYmFj",
            "LnYyQglSYmFjUHJvdG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Validate.ValidateReflection.Descriptor, global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Route.RouteReflection.Descriptor, global::Envoy.Type.Matcher.MetadataReflection.Descriptor, global::Envoy.Type.Matcher.StringReflection.Descriptor, global::Google.Api.Expr.V1Alpha1.SyntaxReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.RBAC), global::Envoy.Config.Rbac.V2.RBAC.Parser, new[]{ "Action", "Policies" }, null, new[]{ typeof(global::Envoy.Config.Rbac.V2.RBAC.Types.Action) }, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Policy), global::Envoy.Config.Rbac.V2.Policy.Parser, new[]{ "Permissions", "Principals", "Condition" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Permission), global::Envoy.Config.Rbac.V2.Permission.Parser, new[]{ "AndRules", "OrRules", "Any", "Header", "DestinationIp", "DestinationPort", "Metadata", "NotRule", "RequestedServerName" }, new[]{ "Rule" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Permission.Types.Set), global::Envoy.Config.Rbac.V2.Permission.Types.Set.Parser, new[]{ "Rules" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Principal), global::Envoy.Config.Rbac.V2.Principal.Parser, new[]{ "AndIds", "OrIds", "Any", "Authenticated", "SourceIp", "Header", "Metadata", "NotId" }, new[]{ "Identifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Principal.Types.Set), global::Envoy.Config.Rbac.V2.Principal.Types.Set.Parser, new[]{ "Ids" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated), global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated.Parser, new[]{ "PrincipalName" }, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Role Based Access Control (RBAC) provides service-level and method-level access control for a
  /// service. RBAC policies are additive. The policies are examined in order. A request is allowed
  /// once a matching policy is found (suppose the `action` is ALLOW).
  ///
  /// Here is an example of RBAC configuration. It has two policies:
  ///
  /// * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
  ///   does "cluster.local/ns/default/sa/superuser".
  ///
  /// * Any user can read ("GET") the service at paths with prefix "/products", so long as the
  ///   destination port is either 80 or 443.
  ///
  ///  .. code-block:: yaml
  ///
  ///   action: ALLOW
  ///   policies:
  ///     "service-admin":
  ///       permissions:
  ///         - any: true
  ///       principals:
  ///         - authenticated:
  ///             principal_name:
  ///               exact: "cluster.local/ns/default/sa/admin"
  ///         - authenticated:
  ///             principal_name:
  ///               exact: "cluster.local/ns/default/sa/superuser"
  ///     "product-viewer":
  ///       permissions:
  ///           - and_rules:
  ///               rules:
  ///                 - header: { name: ":method", exact_match: "GET" }
  ///                 - header: { name: ":path", regex_match: "/products(/.*)?" }
  ///                 - or_rules:
  ///                     rules:
  ///                       - destination_port: 80
  ///                       - destination_port: 443
  ///       principals:
  ///         - any: true
  /// </summary>
  public sealed partial class RBAC : pb::IMessage<RBAC> {
    private static readonly pb::MessageParser<RBAC> _parser = new pb::MessageParser<RBAC>(() => new RBAC());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RBAC> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2.RbacReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RBAC() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RBAC(RBAC other) : this() {
      action_ = other.action_;
      policies_ = other.policies_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RBAC Clone() {
      return new RBAC(this);
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 1;
    private global::Envoy.Config.Rbac.V2.RBAC.Types.Action action_ = global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow;
    /// <summary>
    /// The action to take if a policy matches. The request is allowed if and only if:
    ///
    ///   * `action` is "ALLOWED" and at least one policy matches
    ///   * `action` is "DENY" and none of the policies match
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2.RBAC.Types.Action Action {
      get { return action_; }
      set {
        action_ = value;
      }
    }

    /// <summary>Field number for the "policies" field.</summary>
    public const int PoliciesFieldNumber = 2;
    private static readonly pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy>.Codec _map_policies_codec
        = new pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Envoy.Config.Rbac.V2.Policy.Parser), 18);
    private readonly pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy> policies_ = new pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy>();
    /// <summary>
    /// Maps from policy name to policy. A match occurs when at least one policy matches the request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Envoy.Config.Rbac.V2.Policy> Policies {
      get { return policies_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RBAC);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RBAC other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Action != other.Action) return false;
      if (!Policies.Equals(other.Policies)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) hash ^= Action.GetHashCode();
      hash ^= Policies.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Action);
      }
      policies_.WriteTo(output, _map_policies_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Action);
      }
      size += policies_.CalculateSize(_map_policies_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RBAC other) {
      if (other == null) {
        return;
      }
      if (other.Action != global::Envoy.Config.Rbac.V2.RBAC.Types.Action.Allow) {
        Action = other.Action;
      }
      policies_.Add(other.policies_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Action = (global::Envoy.Config.Rbac.V2.RBAC.Types.Action) input.ReadEnum();
            break;
          }
          case 18: {
            policies_.AddEntriesFrom(input, _map_policies_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RBAC message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Should we do safe-list or block-list style access control?
      /// </summary>
      public enum Action {
        /// <summary>
        /// The policies grant access to principals. The rest is denied. This is safe-list style
        /// access control. This is the default type.
        /// </summary>
        [pbr::OriginalName("ALLOW")] Allow = 0,
        /// <summary>
        /// The policies deny access to principals. The rest is allowed. This is block-list style
        /// access control.
        /// </summary>
        [pbr::OriginalName("DENY")] Deny = 1,
      }

    }
    #endregion

  }

  /// <summary>
  /// Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
  /// and only if at least one of its permissions match the action taking place AND at least one of its
  /// principals match the downstream AND the condition is true if specified.
  /// </summary>
  public sealed partial class Policy : pb::IMessage<Policy> {
    private static readonly pb::MessageParser<Policy> _parser = new pb::MessageParser<Policy>(() => new Policy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Policy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2.RbacReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy(Policy other) : this() {
      permissions_ = other.permissions_.Clone();
      principals_ = other.principals_.Clone();
      condition_ = other.condition_ != null ? other.condition_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Policy Clone() {
      return new Policy(this);
    }

    /// <summary>Field number for the "permissions" field.</summary>
    public const int PermissionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2.Permission> _repeated_permissions_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2.Permission.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission> permissions_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission>();
    /// <summary>
    /// Required. The set of permissions that define a role. Each permission is matched with OR
    /// semantics. To match all actions for this policy, a single Permission with the `any` field set
    /// to true should be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission> Permissions {
      get { return permissions_; }
    }

    /// <summary>Field number for the "principals" field.</summary>
    public const int PrincipalsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2.Principal> _repeated_principals_codec
        = pb::FieldCodec.ForMessage(18, global::Envoy.Config.Rbac.V2.Principal.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal> principals_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal>();
    /// <summary>
    /// Required. The set of principals that are assigned/denied the role based on “action”. Each
    /// principal is matched with OR semantics. To match all downstreams for this policy, a single
    /// Principal with the `any` field set to true should be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal> Principals {
      get { return principals_; }
    }

    /// <summary>Field number for the "condition" field.</summary>
    public const int ConditionFieldNumber = 3;
    private global::Google.Api.Expr.V1Alpha1.Expr condition_;
    /// <summary>
    /// An optional symbolic expression specifying an access control
    /// :ref:`condition &lt;arch_overview_condition>`. The condition is combined
    /// with the permissions and the principals as a clause with AND semantics.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Api.Expr.V1Alpha1.Expr Condition {
      get { return condition_; }
      set {
        condition_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Policy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Policy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!permissions_.Equals(other.permissions_)) return false;
      if(!principals_.Equals(other.principals_)) return false;
      if (!object.Equals(Condition, other.Condition)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= permissions_.GetHashCode();
      hash ^= principals_.GetHashCode();
      if (condition_ != null) hash ^= Condition.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      permissions_.WriteTo(output, _repeated_permissions_codec);
      principals_.WriteTo(output, _repeated_principals_codec);
      if (condition_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Condition);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += permissions_.CalculateSize(_repeated_permissions_codec);
      size += principals_.CalculateSize(_repeated_principals_codec);
      if (condition_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Condition);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Policy other) {
      if (other == null) {
        return;
      }
      permissions_.Add(other.permissions_);
      principals_.Add(other.principals_);
      if (other.condition_ != null) {
        if (condition_ == null) {
          Condition = new global::Google.Api.Expr.V1Alpha1.Expr();
        }
        Condition.MergeFrom(other.Condition);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            permissions_.AddEntriesFrom(input, _repeated_permissions_codec);
            break;
          }
          case 18: {
            principals_.AddEntriesFrom(input, _repeated_principals_codec);
            break;
          }
          case 26: {
            if (condition_ == null) {
              Condition = new global::Google.Api.Expr.V1Alpha1.Expr();
            }
            input.ReadMessage(Condition);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Permission defines an action (or actions) that a principal can take.
  /// </summary>
  public sealed partial class Permission : pb::IMessage<Permission> {
    private static readonly pb::MessageParser<Permission> _parser = new pb::MessageParser<Permission>(() => new Permission());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Permission> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2.RbacReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission(Permission other) : this() {
      switch (other.RuleCase) {
        case RuleOneofCase.AndRules:
          AndRules = other.AndRules.Clone();
          break;
        case RuleOneofCase.OrRules:
          OrRules = other.OrRules.Clone();
          break;
        case RuleOneofCase.Any:
          Any = other.Any;
          break;
        case RuleOneofCase.Header:
          Header = other.Header.Clone();
          break;
        case RuleOneofCase.DestinationIp:
          DestinationIp = other.DestinationIp.Clone();
          break;
        case RuleOneofCase.DestinationPort:
          DestinationPort = other.DestinationPort;
          break;
        case RuleOneofCase.Metadata:
          Metadata = other.Metadata.Clone();
          break;
        case RuleOneofCase.NotRule:
          NotRule = other.NotRule.Clone();
          break;
        case RuleOneofCase.RequestedServerName:
          RequestedServerName = other.RequestedServerName.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Permission Clone() {
      return new Permission(this);
    }

    /// <summary>Field number for the "and_rules" field.</summary>
    public const int AndRulesFieldNumber = 1;
    /// <summary>
    /// A set of rules that all must match in order to define the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2.Permission.Types.Set AndRules {
      get { return ruleCase_ == RuleOneofCase.AndRules ? (global::Envoy.Config.Rbac.V2.Permission.Types.Set) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.AndRules;
      }
    }

    /// <summary>Field number for the "or_rules" field.</summary>
    public const int OrRulesFieldNumber = 2;
    /// <summary>
    /// A set of rules where at least one must match in order to define the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2.Permission.Types.Set OrRules {
      get { return ruleCase_ == RuleOneofCase.OrRules ? (global::Envoy.Config.Rbac.V2.Permission.Types.Set) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.OrRules;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 3;
    /// <summary>
    /// When any is set, it matches any action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Any {
      get { return ruleCase_ == RuleOneofCase.Any ? (bool) rule_ : false; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.Any;
      }
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 4;
    /// <summary>
    /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    /// available for HTTP request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.HeaderMatcher Header {
      get { return ruleCase_ == RuleOneofCase.Header ? (global::Envoy.Api.V2.Route.HeaderMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.Header;
      }
    }

    /// <summary>Field number for the "destination_ip" field.</summary>
    public const int DestinationIpFieldNumber = 5;
    /// <summary>
    /// A CIDR block that describes the destination IP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.CidrRange DestinationIp {
      get { return ruleCase_ == RuleOneofCase.DestinationIp ? (global::Envoy.Api.V2.Core.CidrRange) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.DestinationIp;
      }
    }

    /// <summary>Field number for the "destination_port" field.</summary>
    public const int DestinationPortFieldNumber = 6;
    /// <summary>
    /// A port number that describes the destination port connecting to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DestinationPort {
      get { return ruleCase_ == RuleOneofCase.DestinationPort ? (uint) rule_ : 0; }
      set {
        rule_ = value;
        ruleCase_ = RuleOneofCase.DestinationPort;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    /// <summary>
    /// Metadata that describes additional information about the action.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.MetadataMatcher Metadata {
      get { return ruleCase_ == RuleOneofCase.Metadata ? (global::Envoy.Type.Matcher.MetadataMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.Metadata;
      }
    }

    /// <summary>Field number for the "not_rule" field.</summary>
    public const int NotRuleFieldNumber = 8;
    /// <summary>
    /// Negates matching the provided permission. For instance, if the value of `not_rule` would
    /// match, this permission would not match. Conversely, if the value of `not_rule` would not
    /// match, this permission would match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2.Permission NotRule {
      get { return ruleCase_ == RuleOneofCase.NotRule ? (global::Envoy.Config.Rbac.V2.Permission) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.NotRule;
      }
    }

    /// <summary>Field number for the "requested_server_name" field.</summary>
    public const int RequestedServerNameFieldNumber = 9;
    /// <summary>
    /// The request server from the client's connection request. This is
    /// typically TLS SNI.
    ///
    /// .. attention::
    ///
    ///   The behavior of this field may be affected by how Envoy is configured
    ///   as explained below.
    ///
    ///   * If the :ref:`TLS Inspector &lt;config_listener_filters_tls_inspector>`
    ///     filter is not added, and if a `FilterChainMatch` is not defined for
    ///     the :ref:`server name &lt;envoy_api_field_Listener.FilterChainMatch.server_names>`,
    ///     a TLS connection's requested SNI server name will be treated as if it
    ///     wasn't present.
    ///
    ///   * A :ref:`listener filter &lt;arch_overview_listener_filters>` may
    ///     overwrite a connection's requested server name within Envoy.
    ///
    /// Please refer to :ref:`this FAQ entry &lt;faq_how_to_setup_sni>` to learn to
    /// setup SNI.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.StringMatcher RequestedServerName {
      get { return ruleCase_ == RuleOneofCase.RequestedServerName ? (global::Envoy.Type.Matcher.StringMatcher) rule_ : null; }
      set {
        rule_ = value;
        ruleCase_ = value == null ? RuleOneofCase.None : RuleOneofCase.RequestedServerName;
      }
    }

    private object rule_;
    /// <summary>Enum of possible cases for the "rule" oneof.</summary>
    public enum RuleOneofCase {
      None = 0,
      AndRules = 1,
      OrRules = 2,
      Any = 3,
      Header = 4,
      DestinationIp = 5,
      DestinationPort = 6,
      Metadata = 7,
      NotRule = 8,
      RequestedServerName = 9,
    }
    private RuleOneofCase ruleCase_ = RuleOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RuleOneofCase RuleCase {
      get { return ruleCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRule() {
      ruleCase_ = RuleOneofCase.None;
      rule_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Permission);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Permission other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AndRules, other.AndRules)) return false;
      if (!object.Equals(OrRules, other.OrRules)) return false;
      if (Any != other.Any) return false;
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(DestinationIp, other.DestinationIp)) return false;
      if (DestinationPort != other.DestinationPort) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(NotRule, other.NotRule)) return false;
      if (!object.Equals(RequestedServerName, other.RequestedServerName)) return false;
      if (RuleCase != other.RuleCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ruleCase_ == RuleOneofCase.AndRules) hash ^= AndRules.GetHashCode();
      if (ruleCase_ == RuleOneofCase.OrRules) hash ^= OrRules.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Any) hash ^= Any.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Header) hash ^= Header.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationIp) hash ^= DestinationIp.GetHashCode();
      if (ruleCase_ == RuleOneofCase.DestinationPort) hash ^= DestinationPort.GetHashCode();
      if (ruleCase_ == RuleOneofCase.Metadata) hash ^= Metadata.GetHashCode();
      if (ruleCase_ == RuleOneofCase.NotRule) hash ^= NotRule.GetHashCode();
      if (ruleCase_ == RuleOneofCase.RequestedServerName) hash ^= RequestedServerName.GetHashCode();
      hash ^= (int) ruleCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ruleCase_ == RuleOneofCase.AndRules) {
        output.WriteRawTag(10);
        output.WriteMessage(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        output.WriteRawTag(18);
        output.WriteMessage(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        output.WriteRawTag(34);
        output.WriteMessage(Header);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        output.WriteRawTag(42);
        output.WriteMessage(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        output.WriteRawTag(48);
        output.WriteUInt32(DestinationPort);
      }
      if (ruleCase_ == RuleOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (ruleCase_ == RuleOneofCase.NotRule) {
        output.WriteRawTag(66);
        output.WriteMessage(NotRule);
      }
      if (ruleCase_ == RuleOneofCase.RequestedServerName) {
        output.WriteRawTag(74);
        output.WriteMessage(RequestedServerName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ruleCase_ == RuleOneofCase.AndRules) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AndRules);
      }
      if (ruleCase_ == RuleOneofCase.OrRules) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrRules);
      }
      if (ruleCase_ == RuleOneofCase.Any) {
        size += 1 + 1;
      }
      if (ruleCase_ == RuleOneofCase.Header) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (ruleCase_ == RuleOneofCase.DestinationIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DestinationIp);
      }
      if (ruleCase_ == RuleOneofCase.DestinationPort) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DestinationPort);
      }
      if (ruleCase_ == RuleOneofCase.Metadata) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (ruleCase_ == RuleOneofCase.NotRule) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotRule);
      }
      if (ruleCase_ == RuleOneofCase.RequestedServerName) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequestedServerName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Permission other) {
      if (other == null) {
        return;
      }
      switch (other.RuleCase) {
        case RuleOneofCase.AndRules:
          if (AndRules == null) {
            AndRules = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
          }
          AndRules.MergeFrom(other.AndRules);
          break;
        case RuleOneofCase.OrRules:
          if (OrRules == null) {
            OrRules = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
          }
          OrRules.MergeFrom(other.OrRules);
          break;
        case RuleOneofCase.Any:
          Any = other.Any;
          break;
        case RuleOneofCase.Header:
          if (Header == null) {
            Header = new global::Envoy.Api.V2.Route.HeaderMatcher();
          }
          Header.MergeFrom(other.Header);
          break;
        case RuleOneofCase.DestinationIp:
          if (DestinationIp == null) {
            DestinationIp = new global::Envoy.Api.V2.Core.CidrRange();
          }
          DestinationIp.MergeFrom(other.DestinationIp);
          break;
        case RuleOneofCase.DestinationPort:
          DestinationPort = other.DestinationPort;
          break;
        case RuleOneofCase.Metadata:
          if (Metadata == null) {
            Metadata = new global::Envoy.Type.Matcher.MetadataMatcher();
          }
          Metadata.MergeFrom(other.Metadata);
          break;
        case RuleOneofCase.NotRule:
          if (NotRule == null) {
            NotRule = new global::Envoy.Config.Rbac.V2.Permission();
          }
          NotRule.MergeFrom(other.NotRule);
          break;
        case RuleOneofCase.RequestedServerName:
          if (RequestedServerName == null) {
            RequestedServerName = new global::Envoy.Type.Matcher.StringMatcher();
          }
          RequestedServerName.MergeFrom(other.RequestedServerName);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V2.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.AndRules) {
              subBuilder.MergeFrom(AndRules);
            }
            input.ReadMessage(subBuilder);
            AndRules = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V2.Permission.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Permission.Types.Set();
            if (ruleCase_ == RuleOneofCase.OrRules) {
              subBuilder.MergeFrom(OrRules);
            }
            input.ReadMessage(subBuilder);
            OrRules = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Api.V2.Route.HeaderMatcher subBuilder = new global::Envoy.Api.V2.Route.HeaderMatcher();
            if (ruleCase_ == RuleOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (ruleCase_ == RuleOneofCase.DestinationIp) {
              subBuilder.MergeFrom(DestinationIp);
            }
            input.ReadMessage(subBuilder);
            DestinationIp = subBuilder;
            break;
          }
          case 48: {
            DestinationPort = input.ReadUInt32();
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.MetadataMatcher();
            if (ruleCase_ == RuleOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V2.Permission subBuilder = new global::Envoy.Config.Rbac.V2.Permission();
            if (ruleCase_ == RuleOneofCase.NotRule) {
              subBuilder.MergeFrom(NotRule);
            }
            input.ReadMessage(subBuilder);
            NotRule = subBuilder;
            break;
          }
          case 74: {
            global::Envoy.Type.Matcher.StringMatcher subBuilder = new global::Envoy.Type.Matcher.StringMatcher();
            if (ruleCase_ == RuleOneofCase.RequestedServerName) {
              subBuilder.MergeFrom(RequestedServerName);
            }
            input.ReadMessage(subBuilder);
            RequestedServerName = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Permission message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
      /// each are applied with the associated behavior.
      /// </summary>
      public sealed partial class Set : pb::IMessage<Set> {
        private static readonly pb::MessageParser<Set> _parser = new pb::MessageParser<Set>(() => new Set());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Set> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2.Permission.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set(Set other) : this() {
          rules_ = other.rules_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set Clone() {
          return new Set(this);
        }

        /// <summary>Field number for the "rules" field.</summary>
        public const int RulesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2.Permission> _repeated_rules_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2.Permission.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission> rules_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Permission> Rules {
          get { return rules_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Set);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Set other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!rules_.Equals(other.rules_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= rules_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          rules_.WriteTo(output, _repeated_rules_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += rules_.CalculateSize(_repeated_rules_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Set other) {
          if (other == null) {
            return;
          }
          rules_.Add(other.rules_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                rules_.AddEntriesFrom(input, _repeated_rules_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Principal defines an identity or a group of identities for a downstream subject.
  /// </summary>
  public sealed partial class Principal : pb::IMessage<Principal> {
    private static readonly pb::MessageParser<Principal> _parser = new pb::MessageParser<Principal>(() => new Principal());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Principal> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Rbac.V2.RbacReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Principal() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Principal(Principal other) : this() {
      switch (other.IdentifierCase) {
        case IdentifierOneofCase.AndIds:
          AndIds = other.AndIds.Clone();
          break;
        case IdentifierOneofCase.OrIds:
          OrIds = other.OrIds.Clone();
          break;
        case IdentifierOneofCase.Any:
          Any = other.Any;
          break;
        case IdentifierOneofCase.Authenticated:
          Authenticated = other.Authenticated.Clone();
          break;
        case IdentifierOneofCase.SourceIp:
          SourceIp = other.SourceIp.Clone();
          break;
        case IdentifierOneofCase.Header:
          Header = other.Header.Clone();
          break;
        case IdentifierOneofCase.Metadata:
          Metadata = other.Metadata.Clone();
          break;
        case IdentifierOneofCase.NotId:
          NotId = other.NotId.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Principal Clone() {
      return new Principal(this);
    }

    /// <summary>Field number for the "and_ids" field.</summary>
    public const int AndIdsFieldNumber = 1;
    /// <summary>
    /// A set of identifiers that all must match in order to define the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2.Principal.Types.Set AndIds {
      get { return identifierCase_ == IdentifierOneofCase.AndIds ? (global::Envoy.Config.Rbac.V2.Principal.Types.Set) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.AndIds;
      }
    }

    /// <summary>Field number for the "or_ids" field.</summary>
    public const int OrIdsFieldNumber = 2;
    /// <summary>
    /// A set of identifiers at least one must match in order to define the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2.Principal.Types.Set OrIds {
      get { return identifierCase_ == IdentifierOneofCase.OrIds ? (global::Envoy.Config.Rbac.V2.Principal.Types.Set) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.OrIds;
      }
    }

    /// <summary>Field number for the "any" field.</summary>
    public const int AnyFieldNumber = 3;
    /// <summary>
    /// When any is set, it matches any downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Any {
      get { return identifierCase_ == IdentifierOneofCase.Any ? (bool) identifier_ : false; }
      set {
        identifier_ = value;
        identifierCase_ = IdentifierOneofCase.Any;
      }
    }

    /// <summary>Field number for the "authenticated" field.</summary>
    public const int AuthenticatedFieldNumber = 4;
    /// <summary>
    /// Authenticated attributes that identify the downstream.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated Authenticated {
      get { return identifierCase_ == IdentifierOneofCase.Authenticated ? (global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Authenticated;
      }
    }

    /// <summary>Field number for the "source_ip" field.</summary>
    public const int SourceIpFieldNumber = 5;
    /// <summary>
    /// A CIDR block that describes the downstream IP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.CidrRange SourceIp {
      get { return identifierCase_ == IdentifierOneofCase.SourceIp ? (global::Envoy.Api.V2.Core.CidrRange) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.SourceIp;
      }
    }

    /// <summary>Field number for the "header" field.</summary>
    public const int HeaderFieldNumber = 6;
    /// <summary>
    /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    /// available for HTTP request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Route.HeaderMatcher Header {
      get { return identifierCase_ == IdentifierOneofCase.Header ? (global::Envoy.Api.V2.Route.HeaderMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Header;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    /// <summary>
    /// Metadata that describes additional information about the principal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.Matcher.MetadataMatcher Metadata {
      get { return identifierCase_ == IdentifierOneofCase.Metadata ? (global::Envoy.Type.Matcher.MetadataMatcher) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.Metadata;
      }
    }

    /// <summary>Field number for the "not_id" field.</summary>
    public const int NotIdFieldNumber = 8;
    /// <summary>
    /// Negates matching the provided principal. For instance, if the value of `not_id` would match,
    /// this principal would not match. Conversely, if the value of `not_id` would not match, this
    /// principal would match.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Rbac.V2.Principal NotId {
      get { return identifierCase_ == IdentifierOneofCase.NotId ? (global::Envoy.Config.Rbac.V2.Principal) identifier_ : null; }
      set {
        identifier_ = value;
        identifierCase_ = value == null ? IdentifierOneofCase.None : IdentifierOneofCase.NotId;
      }
    }

    private object identifier_;
    /// <summary>Enum of possible cases for the "identifier" oneof.</summary>
    public enum IdentifierOneofCase {
      None = 0,
      AndIds = 1,
      OrIds = 2,
      Any = 3,
      Authenticated = 4,
      SourceIp = 5,
      Header = 6,
      Metadata = 7,
      NotId = 8,
    }
    private IdentifierOneofCase identifierCase_ = IdentifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public IdentifierOneofCase IdentifierCase {
      get { return identifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIdentifier() {
      identifierCase_ = IdentifierOneofCase.None;
      identifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Principal);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Principal other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AndIds, other.AndIds)) return false;
      if (!object.Equals(OrIds, other.OrIds)) return false;
      if (Any != other.Any) return false;
      if (!object.Equals(Authenticated, other.Authenticated)) return false;
      if (!object.Equals(SourceIp, other.SourceIp)) return false;
      if (!object.Equals(Header, other.Header)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(NotId, other.NotId)) return false;
      if (IdentifierCase != other.IdentifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (identifierCase_ == IdentifierOneofCase.AndIds) hash ^= AndIds.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.OrIds) hash ^= OrIds.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Any) hash ^= Any.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Authenticated) hash ^= Authenticated.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.SourceIp) hash ^= SourceIp.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Header) hash ^= Header.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.Metadata) hash ^= Metadata.GetHashCode();
      if (identifierCase_ == IdentifierOneofCase.NotId) hash ^= NotId.GetHashCode();
      hash ^= (int) identifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        output.WriteRawTag(10);
        output.WriteMessage(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        output.WriteRawTag(18);
        output.WriteMessage(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        output.WriteRawTag(24);
        output.WriteBool(Any);
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        output.WriteRawTag(34);
        output.WriteMessage(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        output.WriteRawTag(42);
        output.WriteMessage(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        output.WriteRawTag(50);
        output.WriteMessage(Header);
      }
      if (identifierCase_ == IdentifierOneofCase.Metadata) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (identifierCase_ == IdentifierOneofCase.NotId) {
        output.WriteRawTag(66);
        output.WriteMessage(NotId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (identifierCase_ == IdentifierOneofCase.AndIds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AndIds);
      }
      if (identifierCase_ == IdentifierOneofCase.OrIds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OrIds);
      }
      if (identifierCase_ == IdentifierOneofCase.Any) {
        size += 1 + 1;
      }
      if (identifierCase_ == IdentifierOneofCase.Authenticated) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Authenticated);
      }
      if (identifierCase_ == IdentifierOneofCase.SourceIp) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceIp);
      }
      if (identifierCase_ == IdentifierOneofCase.Header) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Header);
      }
      if (identifierCase_ == IdentifierOneofCase.Metadata) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (identifierCase_ == IdentifierOneofCase.NotId) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NotId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Principal other) {
      if (other == null) {
        return;
      }
      switch (other.IdentifierCase) {
        case IdentifierOneofCase.AndIds:
          if (AndIds == null) {
            AndIds = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
          }
          AndIds.MergeFrom(other.AndIds);
          break;
        case IdentifierOneofCase.OrIds:
          if (OrIds == null) {
            OrIds = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
          }
          OrIds.MergeFrom(other.OrIds);
          break;
        case IdentifierOneofCase.Any:
          Any = other.Any;
          break;
        case IdentifierOneofCase.Authenticated:
          if (Authenticated == null) {
            Authenticated = new global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated();
          }
          Authenticated.MergeFrom(other.Authenticated);
          break;
        case IdentifierOneofCase.SourceIp:
          if (SourceIp == null) {
            SourceIp = new global::Envoy.Api.V2.Core.CidrRange();
          }
          SourceIp.MergeFrom(other.SourceIp);
          break;
        case IdentifierOneofCase.Header:
          if (Header == null) {
            Header = new global::Envoy.Api.V2.Route.HeaderMatcher();
          }
          Header.MergeFrom(other.Header);
          break;
        case IdentifierOneofCase.Metadata:
          if (Metadata == null) {
            Metadata = new global::Envoy.Type.Matcher.MetadataMatcher();
          }
          Metadata.MergeFrom(other.Metadata);
          break;
        case IdentifierOneofCase.NotId:
          if (NotId == null) {
            NotId = new global::Envoy.Config.Rbac.V2.Principal();
          }
          NotId.MergeFrom(other.NotId);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.AndIds) {
              subBuilder.MergeFrom(AndIds);
            }
            input.ReadMessage(subBuilder);
            AndIds = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Set subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Set();
            if (identifierCase_ == IdentifierOneofCase.OrIds) {
              subBuilder.MergeFrom(OrIds);
            }
            input.ReadMessage(subBuilder);
            OrIds = subBuilder;
            break;
          }
          case 24: {
            Any = input.ReadBool();
            break;
          }
          case 34: {
            global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated subBuilder = new global::Envoy.Config.Rbac.V2.Principal.Types.Authenticated();
            if (identifierCase_ == IdentifierOneofCase.Authenticated) {
              subBuilder.MergeFrom(Authenticated);
            }
            input.ReadMessage(subBuilder);
            Authenticated = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Api.V2.Core.CidrRange subBuilder = new global::Envoy.Api.V2.Core.CidrRange();
            if (identifierCase_ == IdentifierOneofCase.SourceIp) {
              subBuilder.MergeFrom(SourceIp);
            }
            input.ReadMessage(subBuilder);
            SourceIp = subBuilder;
            break;
          }
          case 50: {
            global::Envoy.Api.V2.Route.HeaderMatcher subBuilder = new global::Envoy.Api.V2.Route.HeaderMatcher();
            if (identifierCase_ == IdentifierOneofCase.Header) {
              subBuilder.MergeFrom(Header);
            }
            input.ReadMessage(subBuilder);
            Header = subBuilder;
            break;
          }
          case 58: {
            global::Envoy.Type.Matcher.MetadataMatcher subBuilder = new global::Envoy.Type.Matcher.MetadataMatcher();
            if (identifierCase_ == IdentifierOneofCase.Metadata) {
              subBuilder.MergeFrom(Metadata);
            }
            input.ReadMessage(subBuilder);
            Metadata = subBuilder;
            break;
          }
          case 66: {
            global::Envoy.Config.Rbac.V2.Principal subBuilder = new global::Envoy.Config.Rbac.V2.Principal();
            if (identifierCase_ == IdentifierOneofCase.NotId) {
              subBuilder.MergeFrom(NotId);
            }
            input.ReadMessage(subBuilder);
            NotId = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Principal message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
      /// each are applied with the associated behavior.
      /// </summary>
      public sealed partial class Set : pb::IMessage<Set> {
        private static readonly pb::MessageParser<Set> _parser = new pb::MessageParser<Set>(() => new Set());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Set> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2.Principal.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set(Set other) : this() {
          ids_ = other.ids_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Set Clone() {
          return new Set(this);
        }

        /// <summary>Field number for the "ids" field.</summary>
        public const int IdsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Rbac.V2.Principal> _repeated_ids_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Rbac.V2.Principal.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal> ids_ = new pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Config.Rbac.V2.Principal> Ids {
          get { return ids_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Set);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Set other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!ids_.Equals(other.ids_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= ids_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          ids_.WriteTo(output, _repeated_ids_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += ids_.CalculateSize(_repeated_ids_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Set other) {
          if (other == null) {
            return;
          }
          ids_.Add(other.ids_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ids_.AddEntriesFrom(input, _repeated_ids_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Authentication attributes for a downstream.
      /// </summary>
      public sealed partial class Authenticated : pb::IMessage<Authenticated> {
        private static readonly pb::MessageParser<Authenticated> _parser = new pb::MessageParser<Authenticated>(() => new Authenticated());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Authenticated> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Rbac.V2.Principal.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Authenticated() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Authenticated(Authenticated other) : this() {
          principalName_ = other.principalName_ != null ? other.principalName_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Authenticated Clone() {
          return new Authenticated(this);
        }

        /// <summary>Field number for the "principal_name" field.</summary>
        public const int PrincipalNameFieldNumber = 2;
        private global::Envoy.Type.Matcher.StringMatcher principalName_;
        /// <summary>
        /// The name of the principal. If set, The URI SAN or DNS SAN in that order is used from the
        /// certificate, otherwise the subject field is used. If unset, it applies to any user that is
        /// authenticated.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Type.Matcher.StringMatcher PrincipalName {
          get { return principalName_; }
          set {
            principalName_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Authenticated);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Authenticated other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(PrincipalName, other.PrincipalName)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (principalName_ != null) hash ^= PrincipalName.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (principalName_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(PrincipalName);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (principalName_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrincipalName);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Authenticated other) {
          if (other == null) {
            return;
          }
          if (other.principalName_ != null) {
            if (principalName_ == null) {
              PrincipalName = new global::Envoy.Type.Matcher.StringMatcher();
            }
            PrincipalName.MergeFrom(other.PrincipalName);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 18: {
                if (principalName_ == null) {
                  PrincipalName = new global::Envoy.Type.Matcher.StringMatcher();
                }
                input.ReadMessage(PrincipalName);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
