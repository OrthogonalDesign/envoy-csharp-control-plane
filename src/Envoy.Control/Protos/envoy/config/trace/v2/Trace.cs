// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/trace/v2/trace.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Trace.V2 {

  /// <summary>Holder for reflection information generated from envoy/config/trace/v2/trace.proto</summary>
  public static partial class TraceReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/trace/v2/trace.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TraceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiFlbnZveS9jb25maWcvdHJhY2UvdjIvdHJhY2UucHJvdG8SFWVudm95LmNv",
            "bmZpZy50cmFjZS52MhokZW52b3kvYXBpL3YyL2NvcmUvZ3JwY19zZXJ2aWNl",
            "LnByb3RvGixvcGVuY2Vuc3VzL3Byb3RvL3RyYWNlL3YxL3RyYWNlX2NvbmZp",
            "Zy5wcm90bxoZZ29vZ2xlL3Byb3RvYnVmL2FueS5wcm90bxocZ29vZ2xlL3By",
            "b3RvYnVmL3N0cnVjdC5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJz",
            "LnByb3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90byLGAQoHVHJhY2luZxIx",
            "CgRodHRwGAEgASgLMiMuZW52b3kuY29uZmlnLnRyYWNlLnYyLlRyYWNpbmcu",
            "SHR0cBqHAQoESHR0cBIXCgRuYW1lGAEgASgJQgm66cADBHICIAESKQoGY29u",
            "ZmlnGAIgASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdEgAEiwKDHR5cGVk",
            "X2NvbmZpZxgDIAEoCzIULmdvb2dsZS5wcm90b2J1Zi5BbnlIAEINCgtjb25m",
            "aWdfdHlwZSJdCg9MaWdodHN0ZXBDb25maWcSJAoRY29sbGVjdG9yX2NsdXN0",
            "ZXIYASABKAlCCbrpwAMEcgIgARIkChFhY2Nlc3NfdG9rZW5fZmlsZRgCIAEo",
            "CUIJuunAAwRyAiABIuoCCgxaaXBraW5Db25maWcSJAoRY29sbGVjdG9yX2Ns",
            "dXN0ZXIYASABKAlCCbrpwAMEcgIgARIlChJjb2xsZWN0b3JfZW5kcG9pbnQY",
            "AiABKAlCCbrpwAMEcgIgARIXCg90cmFjZV9pZF8xMjhiaXQYAyABKAgSNwoT",
            "c2hhcmVkX3NwYW5fY29udGV4dBgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5C",
            "b29sVmFsdWUSYAoaY29sbGVjdG9yX2VuZHBvaW50X3ZlcnNpb24YBSABKA4y",
            "PC5lbnZveS5jb25maWcudHJhY2UudjIuWmlwa2luQ29uZmlnLkNvbGxlY3Rv",
            "ckVuZHBvaW50VmVyc2lvbiJZChhDb2xsZWN0b3JFbmRwb2ludFZlcnNpb24S",
            "FAoMSFRUUF9KU09OX1YxEAAaAggBEg0KCUhUVFBfSlNPThABEg4KCkhUVFBf",
            "UFJPVE8QAhIICgRHUlBDEAMiVgoPRHluYW1pY090Q29uZmlnEhoKB2xpYnJh",
            "cnkYASABKAlCCbrpwAMEcgIgARInCgZjb25maWcYAiABKAsyFy5nb29nbGUu",
            "cHJvdG9idWYuU3RydWN0IlYKDURhdGFkb2dDb25maWcSJAoRY29sbGVjdG9y",
            "X2NsdXN0ZXIYASABKAlCCbrpwAMEcgIgARIfCgxzZXJ2aWNlX25hbWUYAiAB",
            "KAlCCbrpwAMEcgIgASLYBAoQT3BlbkNlbnN1c0NvbmZpZxI8Cgx0cmFjZV9j",
            "b25maWcYASABKAsyJi5vcGVuY2Vuc3VzLnByb3RvLnRyYWNlLnYxLlRyYWNl",
            "Q29uZmlnEh8KF3N0ZG91dF9leHBvcnRlcl9lbmFibGVkGAIgASgIEiQKHHN0",
            "YWNrZHJpdmVyX2V4cG9ydGVyX2VuYWJsZWQYAyABKAgSHgoWc3RhY2tkcml2",
            "ZXJfcHJvamVjdF9pZBgEIAEoCRIbChNzdGFja2RyaXZlcl9hZGRyZXNzGAog",
            "ASgJEh8KF3ppcGtpbl9leHBvcnRlcl9lbmFibGVkGAUgASgIEhIKCnppcGtp",
            "bl91cmwYBiABKAkSIAoYb2NhZ2VudF9leHBvcnRlcl9lbmFibGVkGAsgASgI",
            "EhcKD29jYWdlbnRfYWRkcmVzcxgMIAEoCRJUChZpbmNvbWluZ190cmFjZV9j",
            "b250ZXh0GAggAygOMjQuZW52b3kuY29uZmlnLnRyYWNlLnYyLk9wZW5DZW5z",
            "dXNDb25maWcuVHJhY2VDb250ZXh0ElQKFm91dGdvaW5nX3RyYWNlX2NvbnRl",
            "eHQYCSADKA4yNC5lbnZveS5jb25maWcudHJhY2UudjIuT3BlbkNlbnN1c0Nv",
            "bmZpZy5UcmFjZUNvbnRleHQiYAoMVHJhY2VDb250ZXh0EggKBE5PTkUQABIR",
            "Cg1UUkFDRV9DT05URVhUEAESEgoOR1JQQ19UUkFDRV9CSU4QAhIXChNDTE9V",
            "RF9UUkFDRV9DT05URVhUEAMSBgoCQjMQBEoECAcQCCJWChJUcmFjZVNlcnZp",
            "Y2VDb25maWcSQAoMZ3JwY19zZXJ2aWNlGAEgASgLMh4uZW52b3kuYXBpLnYy",
            "LmNvcmUuR3JwY1NlcnZpY2VCCrrpwAMFigECEAFCMwojaW8uZW52b3lwcm94",
            "eS5lbnZveS5jb25maWcudHJhY2UudjJCClRyYWNlUHJvdG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.GrpcServiceReflection.Descriptor, global::Opencensus.Proto.Trace.V1.TraceConfigReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.Tracing), global::Envoy.Config.Trace.V2.Tracing.Parser, new[]{ "Http" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.Tracing.Types.Http), global::Envoy.Config.Trace.V2.Tracing.Types.Http.Parser, new[]{ "Name", "Config", "TypedConfig" }, new[]{ "ConfigType" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.LightstepConfig), global::Envoy.Config.Trace.V2.LightstepConfig.Parser, new[]{ "CollectorCluster", "AccessTokenFile" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.ZipkinConfig), global::Envoy.Config.Trace.V2.ZipkinConfig.Parser, new[]{ "CollectorCluster", "CollectorEndpoint", "TraceId128Bit", "SharedSpanContext", "CollectorEndpointVersion" }, null, new[]{ typeof(global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.DynamicOtConfig), global::Envoy.Config.Trace.V2.DynamicOtConfig.Parser, new[]{ "Library", "Config" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.DatadogConfig), global::Envoy.Config.Trace.V2.DatadogConfig.Parser, new[]{ "CollectorCluster", "ServiceName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.OpenCensusConfig), global::Envoy.Config.Trace.V2.OpenCensusConfig.Parser, new[]{ "TraceConfig", "StdoutExporterEnabled", "StackdriverExporterEnabled", "StackdriverProjectId", "StackdriverAddress", "ZipkinExporterEnabled", "ZipkinUrl", "OcagentExporterEnabled", "OcagentAddress", "IncomingTraceContext", "OutgoingTraceContext" }, null, new[]{ typeof(global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.TraceServiceConfig), global::Envoy.Config.Trace.V2.TraceServiceConfig.Parser, new[]{ "GrpcService" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// The tracing configuration specifies global
  /// settings for the HTTP tracer used by Envoy. The configuration is defined by
  /// the :ref:`Bootstrap &lt;envoy_api_msg_config.bootstrap.v2.Bootstrap>` :ref:`tracing
  /// &lt;envoy_api_field_config.bootstrap.v2.Bootstrap.tracing>` field. Envoy may support other tracers
  /// in the future, but right now the HTTP tracer is the only one supported.
  /// </summary>
  public sealed partial class Tracing : pb::IMessage<Tracing> {
    private static readonly pb::MessageParser<Tracing> _parser = new pb::MessageParser<Tracing>(() => new Tracing());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Tracing> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing(Tracing other) : this() {
      http_ = other.http_ != null ? other.http_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing Clone() {
      return new Tracing(this);
    }

    /// <summary>Field number for the "http" field.</summary>
    public const int HttpFieldNumber = 1;
    private global::Envoy.Config.Trace.V2.Tracing.Types.Http http_;
    /// <summary>
    /// Provides configuration for the HTTP tracer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Trace.V2.Tracing.Types.Http Http {
      get { return http_; }
      set {
        http_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Tracing);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Tracing other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Http, other.Http)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (http_ != null) hash ^= Http.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (http_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (http_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Tracing other) {
      if (other == null) {
        return;
      }
      if (other.http_ != null) {
        if (http_ == null) {
          Http = new global::Envoy.Config.Trace.V2.Tracing.Types.Http();
        }
        Http.MergeFrom(other.Http);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (http_ == null) {
              Http = new global::Envoy.Config.Trace.V2.Tracing.Types.Http();
            }
            input.ReadMessage(Http);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Tracing message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Http : pb::IMessage<Http> {
        private static readonly pb::MessageParser<Http> _parser = new pb::MessageParser<Http>(() => new Http());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Http> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Trace.V2.Tracing.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Http() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Http(Http other) : this() {
          name_ = other.name_;
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.Config:
              Config = other.Config.Clone();
              break;
            case ConfigTypeOneofCase.TypedConfig:
              TypedConfig = other.TypedConfig.Clone();
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Http Clone() {
          return new Http(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the HTTP trace driver to instantiate. The name must match a
        /// supported HTTP trace driver. Built-in trace drivers:
        ///
        /// - *envoy.lightstep*
        /// - *envoy.zipkin*
        /// - *envoy.dynamic.ot*
        /// - *envoy.tracers.datadog*
        /// - *envoy.tracers.opencensus*
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "config" field.</summary>
        public const int ConfigFieldNumber = 2;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Struct Config {
          get { return configTypeCase_ == ConfigTypeOneofCase.Config ? (global::Google.Protobuf.WellKnownTypes.Struct) configType_ : null; }
          set {
            configType_ = value;
            configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.Config;
          }
        }

        /// <summary>Field number for the "typed_config" field.</summary>
        public const int TypedConfigFieldNumber = 3;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
          get { return configTypeCase_ == ConfigTypeOneofCase.TypedConfig ? (global::Google.Protobuf.WellKnownTypes.Any) configType_ : null; }
          set {
            configType_ = value;
            configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.TypedConfig;
          }
        }

        private object configType_;
        /// <summary>Enum of possible cases for the "config_type" oneof.</summary>
        public enum ConfigTypeOneofCase {
          None = 0,
          Config = 2,
          TypedConfig = 3,
        }
        private ConfigTypeOneofCase configTypeCase_ = ConfigTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ConfigTypeOneofCase ConfigTypeCase {
          get { return configTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void ClearConfigType() {
          configTypeCase_ = ConfigTypeOneofCase.None;
          configType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Http);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Http other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Config, other.Config)) return false;
          if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
          if (ConfigTypeCase != other.ConfigTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (configTypeCase_ == ConfigTypeOneofCase.Config) hash ^= Config.GetHashCode();
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
          hash ^= (int) configTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.Config) {
            output.WriteRawTag(18);
            output.WriteMessage(Config);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            output.WriteRawTag(26);
            output.WriteMessage(TypedConfig);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.Config) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
          }
          if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Http other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          switch (other.ConfigTypeCase) {
            case ConfigTypeOneofCase.Config:
              if (Config == null) {
                Config = new global::Google.Protobuf.WellKnownTypes.Struct();
              }
              Config.MergeFrom(other.Config);
              break;
            case ConfigTypeOneofCase.TypedConfig:
              if (TypedConfig == null) {
                TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
              }
              TypedConfig.MergeFrom(other.TypedConfig);
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                global::Google.Protobuf.WellKnownTypes.Struct subBuilder = new global::Google.Protobuf.WellKnownTypes.Struct();
                if (configTypeCase_ == ConfigTypeOneofCase.Config) {
                  subBuilder.MergeFrom(Config);
                }
                input.ReadMessage(subBuilder);
                Config = subBuilder;
                break;
              }
              case 26: {
                global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
                if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
                  subBuilder.MergeFrom(TypedConfig);
                }
                input.ReadMessage(subBuilder);
                TypedConfig = subBuilder;
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Configuration for the LightStep tracer.
  /// </summary>
  public sealed partial class LightstepConfig : pb::IMessage<LightstepConfig> {
    private static readonly pb::MessageParser<LightstepConfig> _parser = new pb::MessageParser<LightstepConfig>(() => new LightstepConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LightstepConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LightstepConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LightstepConfig(LightstepConfig other) : this() {
      collectorCluster_ = other.collectorCluster_;
      accessTokenFile_ = other.accessTokenFile_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LightstepConfig Clone() {
      return new LightstepConfig(this);
    }

    /// <summary>Field number for the "collector_cluster" field.</summary>
    public const int CollectorClusterFieldNumber = 1;
    private string collectorCluster_ = "";
    /// <summary>
    /// The cluster manager cluster that hosts the LightStep collectors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectorCluster {
      get { return collectorCluster_; }
      set {
        collectorCluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "access_token_file" field.</summary>
    public const int AccessTokenFileFieldNumber = 2;
    private string accessTokenFile_ = "";
    /// <summary>
    /// File containing the access token to the `LightStep
    /// &lt;https://lightstep.com/>`_ API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AccessTokenFile {
      get { return accessTokenFile_; }
      set {
        accessTokenFile_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LightstepConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LightstepConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CollectorCluster != other.CollectorCluster) return false;
      if (AccessTokenFile != other.AccessTokenFile) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CollectorCluster.Length != 0) hash ^= CollectorCluster.GetHashCode();
      if (AccessTokenFile.Length != 0) hash ^= AccessTokenFile.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CollectorCluster.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CollectorCluster);
      }
      if (AccessTokenFile.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AccessTokenFile);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CollectorCluster.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectorCluster);
      }
      if (AccessTokenFile.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AccessTokenFile);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LightstepConfig other) {
      if (other == null) {
        return;
      }
      if (other.CollectorCluster.Length != 0) {
        CollectorCluster = other.CollectorCluster;
      }
      if (other.AccessTokenFile.Length != 0) {
        AccessTokenFile = other.AccessTokenFile;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CollectorCluster = input.ReadString();
            break;
          }
          case 18: {
            AccessTokenFile = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration for the Zipkin tracer.
  /// </summary>
  public sealed partial class ZipkinConfig : pb::IMessage<ZipkinConfig> {
    private static readonly pb::MessageParser<ZipkinConfig> _parser = new pb::MessageParser<ZipkinConfig>(() => new ZipkinConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ZipkinConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZipkinConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZipkinConfig(ZipkinConfig other) : this() {
      collectorCluster_ = other.collectorCluster_;
      collectorEndpoint_ = other.collectorEndpoint_;
      traceId128Bit_ = other.traceId128Bit_;
      SharedSpanContext = other.SharedSpanContext;
      collectorEndpointVersion_ = other.collectorEndpointVersion_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZipkinConfig Clone() {
      return new ZipkinConfig(this);
    }

    /// <summary>Field number for the "collector_cluster" field.</summary>
    public const int CollectorClusterFieldNumber = 1;
    private string collectorCluster_ = "";
    /// <summary>
    /// The cluster manager cluster that hosts the Zipkin collectors. Note that the
    /// Zipkin cluster must be defined in the :ref:`Bootstrap static cluster
    /// resources &lt;envoy_api_field_config.bootstrap.v2.Bootstrap.StaticResources.clusters>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectorCluster {
      get { return collectorCluster_; }
      set {
        collectorCluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "collector_endpoint" field.</summary>
    public const int CollectorEndpointFieldNumber = 2;
    private string collectorEndpoint_ = "";
    /// <summary>
    /// The API endpoint of the Zipkin service where the spans will be sent. When
    /// using a standard Zipkin installation, the API endpoint is typically
    /// /api/v1/spans, which is the default value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectorEndpoint {
      get { return collectorEndpoint_; }
      set {
        collectorEndpoint_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trace_id_128bit" field.</summary>
    public const int TraceId128BitFieldNumber = 3;
    private bool traceId128Bit_;
    /// <summary>
    /// Determines whether a 128bit trace id will be used when creating a new
    /// trace instance. The default value is false, which will result in a 64 bit trace id being used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool TraceId128Bit {
      get { return traceId128Bit_; }
      set {
        traceId128Bit_ = value;
      }
    }

    /// <summary>Field number for the "shared_span_context" field.</summary>
    public const int SharedSpanContextFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_sharedSpanContext_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? sharedSpanContext_;
    /// <summary>
    /// Determines whether client and server spans will share the same span context.
    /// The default value is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? SharedSpanContext {
      get { return sharedSpanContext_; }
      set {
        sharedSpanContext_ = value;
      }
    }


    /// <summary>Field number for the "collector_endpoint_version" field.</summary>
    public const int CollectorEndpointVersionFieldNumber = 5;
    private global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion collectorEndpointVersion_ = global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion.HttpJsonV1;
    /// <summary>
    /// Determines the selected collector endpoint version. By default, the ``HTTP_JSON_V1`` will be
    /// used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion CollectorEndpointVersion {
      get { return collectorEndpointVersion_; }
      set {
        collectorEndpointVersion_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ZipkinConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ZipkinConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CollectorCluster != other.CollectorCluster) return false;
      if (CollectorEndpoint != other.CollectorEndpoint) return false;
      if (TraceId128Bit != other.TraceId128Bit) return false;
      if (SharedSpanContext != other.SharedSpanContext) return false;
      if (CollectorEndpointVersion != other.CollectorEndpointVersion) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CollectorCluster.Length != 0) hash ^= CollectorCluster.GetHashCode();
      if (CollectorEndpoint.Length != 0) hash ^= CollectorEndpoint.GetHashCode();
      if (TraceId128Bit != false) hash ^= TraceId128Bit.GetHashCode();
      if (sharedSpanContext_ != null) hash ^= SharedSpanContext.GetHashCode();
      if (CollectorEndpointVersion != global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion.HttpJsonV1) hash ^= CollectorEndpointVersion.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CollectorCluster.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CollectorCluster);
      }
      if (CollectorEndpoint.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(CollectorEndpoint);
      }
      if (TraceId128Bit != false) {
        output.WriteRawTag(24);
        output.WriteBool(TraceId128Bit);
      }
      if (sharedSpanContext_ != null) {
        _single_sharedSpanContext_codec.WriteTagAndValue(output, SharedSpanContext);
      }
      if (CollectorEndpointVersion != global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion.HttpJsonV1) {
        output.WriteRawTag(40);
        output.WriteEnum((int) CollectorEndpointVersion);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CollectorCluster.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectorCluster);
      }
      if (CollectorEndpoint.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectorEndpoint);
      }
      if (TraceId128Bit != false) {
        size += 1 + 1;
      }
      if (sharedSpanContext_ != null) {
        size += _single_sharedSpanContext_codec.CalculateSizeWithTag(SharedSpanContext);
      }
      if (CollectorEndpointVersion != global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion.HttpJsonV1) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CollectorEndpointVersion);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ZipkinConfig other) {
      if (other == null) {
        return;
      }
      if (other.CollectorCluster.Length != 0) {
        CollectorCluster = other.CollectorCluster;
      }
      if (other.CollectorEndpoint.Length != 0) {
        CollectorEndpoint = other.CollectorEndpoint;
      }
      if (other.TraceId128Bit != false) {
        TraceId128Bit = other.TraceId128Bit;
      }
      if (other.sharedSpanContext_ != null) {
        if (sharedSpanContext_ == null || other.SharedSpanContext != false) {
          SharedSpanContext = other.SharedSpanContext;
        }
      }
      if (other.CollectorEndpointVersion != global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion.HttpJsonV1) {
        CollectorEndpointVersion = other.CollectorEndpointVersion;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CollectorCluster = input.ReadString();
            break;
          }
          case 18: {
            CollectorEndpoint = input.ReadString();
            break;
          }
          case 24: {
            TraceId128Bit = input.ReadBool();
            break;
          }
          case 34: {
            bool? value = _single_sharedSpanContext_codec.Read(input);
            if (sharedSpanContext_ == null || value != false) {
              SharedSpanContext = value;
            }
            break;
          }
          case 40: {
            CollectorEndpointVersion = (global::Envoy.Config.Trace.V2.ZipkinConfig.Types.CollectorEndpointVersion) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ZipkinConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Available Zipkin collector endpoint versions.
      /// </summary>
      public enum CollectorEndpointVersion {
        /// <summary>
        /// Zipkin API v1, JSON over HTTP.
        /// [#comment: The default implementation of Zipkin client before this field is added was only v1
        /// and the way user configure this was by not explicitly specifying the version. Consequently,
        /// before this is added, the corresponding Zipkin collector expected to receive v1 payload.
        /// Hence the motivation of adding HTTP_JSON_V1 as the default is to avoid a breaking change when
        /// user upgrading Envoy with this change. Furthermore, we also immediately deprecate this field,
        /// since in Zipkin realm this v1 version is considered to be not preferable anymore.]
        /// </summary>
        [pbr::OriginalName("HTTP_JSON_V1")] HttpJsonV1 = 0,
        /// <summary>
        /// Zipkin API v2, JSON over HTTP.
        /// </summary>
        [pbr::OriginalName("HTTP_JSON")] HttpJson = 1,
        /// <summary>
        /// Zipkin API v2, protobuf over HTTP.
        /// </summary>
        [pbr::OriginalName("HTTP_PROTO")] HttpProto = 2,
        /// <summary>
        /// [#not-implemented-hide:]
        /// </summary>
        [pbr::OriginalName("GRPC")] Grpc = 3,
      }

    }
    #endregion

  }

  /// <summary>
  /// DynamicOtConfig is used to dynamically load a tracer from a shared library
  /// that implements the `OpenTracing dynamic loading API
  /// &lt;https://github.com/opentracing/opentracing-cpp>`_.
  /// </summary>
  public sealed partial class DynamicOtConfig : pb::IMessage<DynamicOtConfig> {
    private static readonly pb::MessageParser<DynamicOtConfig> _parser = new pb::MessageParser<DynamicOtConfig>(() => new DynamicOtConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DynamicOtConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicOtConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicOtConfig(DynamicOtConfig other) : this() {
      library_ = other.library_;
      config_ = other.config_ != null ? other.config_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicOtConfig Clone() {
      return new DynamicOtConfig(this);
    }

    /// <summary>Field number for the "library" field.</summary>
    public const int LibraryFieldNumber = 1;
    private string library_ = "";
    /// <summary>
    /// Dynamic library implementing the `OpenTracing API
    /// &lt;https://github.com/opentracing/opentracing-cpp>`_.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Library {
      get { return library_; }
      set {
        library_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Struct config_;
    /// <summary>
    /// The configuration to use when creating a tracer from the given dynamic
    /// library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Struct Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DynamicOtConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DynamicOtConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Library != other.Library) return false;
      if (!object.Equals(Config, other.Config)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Library.Length != 0) hash ^= Library.GetHashCode();
      if (config_ != null) hash ^= Config.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Library.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Library);
      }
      if (config_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Config);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Library.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Library);
      }
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DynamicOtConfig other) {
      if (other == null) {
        return;
      }
      if (other.Library.Length != 0) {
        Library = other.Library;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::Google.Protobuf.WellKnownTypes.Struct();
        }
        Config.MergeFrom(other.Config);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Library = input.ReadString();
            break;
          }
          case 18: {
            if (config_ == null) {
              Config = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            input.ReadMessage(Config);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration for the Datadog tracer.
  /// </summary>
  public sealed partial class DatadogConfig : pb::IMessage<DatadogConfig> {
    private static readonly pb::MessageParser<DatadogConfig> _parser = new pb::MessageParser<DatadogConfig>(() => new DatadogConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DatadogConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DatadogConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DatadogConfig(DatadogConfig other) : this() {
      collectorCluster_ = other.collectorCluster_;
      serviceName_ = other.serviceName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DatadogConfig Clone() {
      return new DatadogConfig(this);
    }

    /// <summary>Field number for the "collector_cluster" field.</summary>
    public const int CollectorClusterFieldNumber = 1;
    private string collectorCluster_ = "";
    /// <summary>
    /// The cluster to use for submitting traces to the Datadog agent.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectorCluster {
      get { return collectorCluster_; }
      set {
        collectorCluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "service_name" field.</summary>
    public const int ServiceNameFieldNumber = 2;
    private string serviceName_ = "";
    /// <summary>
    /// The name used for the service when traces are generated by envoy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ServiceName {
      get { return serviceName_; }
      set {
        serviceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DatadogConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DatadogConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CollectorCluster != other.CollectorCluster) return false;
      if (ServiceName != other.ServiceName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CollectorCluster.Length != 0) hash ^= CollectorCluster.GetHashCode();
      if (ServiceName.Length != 0) hash ^= ServiceName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CollectorCluster.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CollectorCluster);
      }
      if (ServiceName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ServiceName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CollectorCluster.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectorCluster);
      }
      if (ServiceName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DatadogConfig other) {
      if (other == null) {
        return;
      }
      if (other.CollectorCluster.Length != 0) {
        CollectorCluster = other.CollectorCluster;
      }
      if (other.ServiceName.Length != 0) {
        ServiceName = other.ServiceName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CollectorCluster = input.ReadString();
            break;
          }
          case 18: {
            ServiceName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration for the OpenCensus tracer.
  /// [#proto-status: experimental]
  /// </summary>
  public sealed partial class OpenCensusConfig : pb::IMessage<OpenCensusConfig> {
    private static readonly pb::MessageParser<OpenCensusConfig> _parser = new pb::MessageParser<OpenCensusConfig>(() => new OpenCensusConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OpenCensusConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpenCensusConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpenCensusConfig(OpenCensusConfig other) : this() {
      traceConfig_ = other.traceConfig_ != null ? other.traceConfig_.Clone() : null;
      stdoutExporterEnabled_ = other.stdoutExporterEnabled_;
      stackdriverExporterEnabled_ = other.stackdriverExporterEnabled_;
      stackdriverProjectId_ = other.stackdriverProjectId_;
      stackdriverAddress_ = other.stackdriverAddress_;
      zipkinExporterEnabled_ = other.zipkinExporterEnabled_;
      zipkinUrl_ = other.zipkinUrl_;
      ocagentExporterEnabled_ = other.ocagentExporterEnabled_;
      ocagentAddress_ = other.ocagentAddress_;
      incomingTraceContext_ = other.incomingTraceContext_.Clone();
      outgoingTraceContext_ = other.outgoingTraceContext_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OpenCensusConfig Clone() {
      return new OpenCensusConfig(this);
    }

    /// <summary>Field number for the "trace_config" field.</summary>
    public const int TraceConfigFieldNumber = 1;
    private global::Opencensus.Proto.Trace.V1.TraceConfig traceConfig_;
    /// <summary>
    /// Configures tracing, e.g. the sampler, max number of annotations, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Opencensus.Proto.Trace.V1.TraceConfig TraceConfig {
      get { return traceConfig_; }
      set {
        traceConfig_ = value;
      }
    }

    /// <summary>Field number for the "stdout_exporter_enabled" field.</summary>
    public const int StdoutExporterEnabledFieldNumber = 2;
    private bool stdoutExporterEnabled_;
    /// <summary>
    /// Enables the stdout exporter if set to true. This is intended for debugging
    /// purposes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StdoutExporterEnabled {
      get { return stdoutExporterEnabled_; }
      set {
        stdoutExporterEnabled_ = value;
      }
    }

    /// <summary>Field number for the "stackdriver_exporter_enabled" field.</summary>
    public const int StackdriverExporterEnabledFieldNumber = 3;
    private bool stackdriverExporterEnabled_;
    /// <summary>
    /// Enables the Stackdriver exporter if set to true. The project_id must also
    /// be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StackdriverExporterEnabled {
      get { return stackdriverExporterEnabled_; }
      set {
        stackdriverExporterEnabled_ = value;
      }
    }

    /// <summary>Field number for the "stackdriver_project_id" field.</summary>
    public const int StackdriverProjectIdFieldNumber = 4;
    private string stackdriverProjectId_ = "";
    /// <summary>
    /// The Cloud project_id to use for Stackdriver tracing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StackdriverProjectId {
      get { return stackdriverProjectId_; }
      set {
        stackdriverProjectId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "stackdriver_address" field.</summary>
    public const int StackdriverAddressFieldNumber = 10;
    private string stackdriverAddress_ = "";
    /// <summary>
    /// (optional) By default, the Stackdriver exporter will connect to production
    /// Stackdriver. If stackdriver_address is non-empty, it will instead connect
    /// to this address, which is in the gRPC format:
    /// https://github.com/grpc/grpc/blob/master/doc/naming.md
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StackdriverAddress {
      get { return stackdriverAddress_; }
      set {
        stackdriverAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "zipkin_exporter_enabled" field.</summary>
    public const int ZipkinExporterEnabledFieldNumber = 5;
    private bool zipkinExporterEnabled_;
    /// <summary>
    /// Enables the Zipkin exporter if set to true. The url and service name must
    /// also be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ZipkinExporterEnabled {
      get { return zipkinExporterEnabled_; }
      set {
        zipkinExporterEnabled_ = value;
      }
    }

    /// <summary>Field number for the "zipkin_url" field.</summary>
    public const int ZipkinUrlFieldNumber = 6;
    private string zipkinUrl_ = "";
    /// <summary>
    /// The URL to Zipkin, e.g. "http://127.0.0.1:9411/api/v2/spans"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ZipkinUrl {
      get { return zipkinUrl_; }
      set {
        zipkinUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ocagent_exporter_enabled" field.</summary>
    public const int OcagentExporterEnabledFieldNumber = 11;
    private bool ocagentExporterEnabled_;
    /// <summary>
    /// Enables the OpenCensus Agent exporter if set to true. The address must also
    /// be set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool OcagentExporterEnabled {
      get { return ocagentExporterEnabled_; }
      set {
        ocagentExporterEnabled_ = value;
      }
    }

    /// <summary>Field number for the "ocagent_address" field.</summary>
    public const int OcagentAddressFieldNumber = 12;
    private string ocagentAddress_ = "";
    /// <summary>
    /// The address of the OpenCensus Agent, if its exporter is enabled, in gRPC
    /// format: https://github.com/grpc/grpc/blob/master/doc/naming.md
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OcagentAddress {
      get { return ocagentAddress_; }
      set {
        ocagentAddress_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "incoming_trace_context" field.</summary>
    public const int IncomingTraceContextFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext> _repeated_incomingTraceContext_codec
        = pb::FieldCodec.ForEnum(66, x => (int) x, x => (global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext) x);
    private readonly pbc::RepeatedField<global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext> incomingTraceContext_ = new pbc::RepeatedField<global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext>();
    /// <summary>
    /// List of incoming trace context headers we will accept. First one found
    /// wins.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext> IncomingTraceContext {
      get { return incomingTraceContext_; }
    }

    /// <summary>Field number for the "outgoing_trace_context" field.</summary>
    public const int OutgoingTraceContextFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext> _repeated_outgoingTraceContext_codec
        = pb::FieldCodec.ForEnum(74, x => (int) x, x => (global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext) x);
    private readonly pbc::RepeatedField<global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext> outgoingTraceContext_ = new pbc::RepeatedField<global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext>();
    /// <summary>
    /// List of outgoing trace context headers we will produce.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Trace.V2.OpenCensusConfig.Types.TraceContext> OutgoingTraceContext {
      get { return outgoingTraceContext_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OpenCensusConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OpenCensusConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TraceConfig, other.TraceConfig)) return false;
      if (StdoutExporterEnabled != other.StdoutExporterEnabled) return false;
      if (StackdriverExporterEnabled != other.StackdriverExporterEnabled) return false;
      if (StackdriverProjectId != other.StackdriverProjectId) return false;
      if (StackdriverAddress != other.StackdriverAddress) return false;
      if (ZipkinExporterEnabled != other.ZipkinExporterEnabled) return false;
      if (ZipkinUrl != other.ZipkinUrl) return false;
      if (OcagentExporterEnabled != other.OcagentExporterEnabled) return false;
      if (OcagentAddress != other.OcagentAddress) return false;
      if(!incomingTraceContext_.Equals(other.incomingTraceContext_)) return false;
      if(!outgoingTraceContext_.Equals(other.outgoingTraceContext_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (traceConfig_ != null) hash ^= TraceConfig.GetHashCode();
      if (StdoutExporterEnabled != false) hash ^= StdoutExporterEnabled.GetHashCode();
      if (StackdriverExporterEnabled != false) hash ^= StackdriverExporterEnabled.GetHashCode();
      if (StackdriverProjectId.Length != 0) hash ^= StackdriverProjectId.GetHashCode();
      if (StackdriverAddress.Length != 0) hash ^= StackdriverAddress.GetHashCode();
      if (ZipkinExporterEnabled != false) hash ^= ZipkinExporterEnabled.GetHashCode();
      if (ZipkinUrl.Length != 0) hash ^= ZipkinUrl.GetHashCode();
      if (OcagentExporterEnabled != false) hash ^= OcagentExporterEnabled.GetHashCode();
      if (OcagentAddress.Length != 0) hash ^= OcagentAddress.GetHashCode();
      hash ^= incomingTraceContext_.GetHashCode();
      hash ^= outgoingTraceContext_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (traceConfig_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TraceConfig);
      }
      if (StdoutExporterEnabled != false) {
        output.WriteRawTag(16);
        output.WriteBool(StdoutExporterEnabled);
      }
      if (StackdriverExporterEnabled != false) {
        output.WriteRawTag(24);
        output.WriteBool(StackdriverExporterEnabled);
      }
      if (StackdriverProjectId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(StackdriverProjectId);
      }
      if (ZipkinExporterEnabled != false) {
        output.WriteRawTag(40);
        output.WriteBool(ZipkinExporterEnabled);
      }
      if (ZipkinUrl.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(ZipkinUrl);
      }
      incomingTraceContext_.WriteTo(output, _repeated_incomingTraceContext_codec);
      outgoingTraceContext_.WriteTo(output, _repeated_outgoingTraceContext_codec);
      if (StackdriverAddress.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(StackdriverAddress);
      }
      if (OcagentExporterEnabled != false) {
        output.WriteRawTag(88);
        output.WriteBool(OcagentExporterEnabled);
      }
      if (OcagentAddress.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(OcagentAddress);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (traceConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TraceConfig);
      }
      if (StdoutExporterEnabled != false) {
        size += 1 + 1;
      }
      if (StackdriverExporterEnabled != false) {
        size += 1 + 1;
      }
      if (StackdriverProjectId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StackdriverProjectId);
      }
      if (StackdriverAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StackdriverAddress);
      }
      if (ZipkinExporterEnabled != false) {
        size += 1 + 1;
      }
      if (ZipkinUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ZipkinUrl);
      }
      if (OcagentExporterEnabled != false) {
        size += 1 + 1;
      }
      if (OcagentAddress.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OcagentAddress);
      }
      size += incomingTraceContext_.CalculateSize(_repeated_incomingTraceContext_codec);
      size += outgoingTraceContext_.CalculateSize(_repeated_outgoingTraceContext_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OpenCensusConfig other) {
      if (other == null) {
        return;
      }
      if (other.traceConfig_ != null) {
        if (traceConfig_ == null) {
          TraceConfig = new global::Opencensus.Proto.Trace.V1.TraceConfig();
        }
        TraceConfig.MergeFrom(other.TraceConfig);
      }
      if (other.StdoutExporterEnabled != false) {
        StdoutExporterEnabled = other.StdoutExporterEnabled;
      }
      if (other.StackdriverExporterEnabled != false) {
        StackdriverExporterEnabled = other.StackdriverExporterEnabled;
      }
      if (other.StackdriverProjectId.Length != 0) {
        StackdriverProjectId = other.StackdriverProjectId;
      }
      if (other.StackdriverAddress.Length != 0) {
        StackdriverAddress = other.StackdriverAddress;
      }
      if (other.ZipkinExporterEnabled != false) {
        ZipkinExporterEnabled = other.ZipkinExporterEnabled;
      }
      if (other.ZipkinUrl.Length != 0) {
        ZipkinUrl = other.ZipkinUrl;
      }
      if (other.OcagentExporterEnabled != false) {
        OcagentExporterEnabled = other.OcagentExporterEnabled;
      }
      if (other.OcagentAddress.Length != 0) {
        OcagentAddress = other.OcagentAddress;
      }
      incomingTraceContext_.Add(other.incomingTraceContext_);
      outgoingTraceContext_.Add(other.outgoingTraceContext_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (traceConfig_ == null) {
              TraceConfig = new global::Opencensus.Proto.Trace.V1.TraceConfig();
            }
            input.ReadMessage(TraceConfig);
            break;
          }
          case 16: {
            StdoutExporterEnabled = input.ReadBool();
            break;
          }
          case 24: {
            StackdriverExporterEnabled = input.ReadBool();
            break;
          }
          case 34: {
            StackdriverProjectId = input.ReadString();
            break;
          }
          case 40: {
            ZipkinExporterEnabled = input.ReadBool();
            break;
          }
          case 50: {
            ZipkinUrl = input.ReadString();
            break;
          }
          case 66:
          case 64: {
            incomingTraceContext_.AddEntriesFrom(input, _repeated_incomingTraceContext_codec);
            break;
          }
          case 74:
          case 72: {
            outgoingTraceContext_.AddEntriesFrom(input, _repeated_outgoingTraceContext_codec);
            break;
          }
          case 82: {
            StackdriverAddress = input.ReadString();
            break;
          }
          case 88: {
            OcagentExporterEnabled = input.ReadBool();
            break;
          }
          case 98: {
            OcagentAddress = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the OpenCensusConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum TraceContext {
        /// <summary>
        /// No-op default, no trace context is utilized.
        /// </summary>
        [pbr::OriginalName("NONE")] None = 0,
        /// <summary>
        /// W3C Trace-Context format "traceparent:" header.
        /// </summary>
        [pbr::OriginalName("TRACE_CONTEXT")] TraceContext = 1,
        /// <summary>
        /// Binary "grpc-trace-bin:" header.
        /// </summary>
        [pbr::OriginalName("GRPC_TRACE_BIN")] GrpcTraceBin = 2,
        /// <summary>
        /// "X-Cloud-Trace-Context:" header.
        /// </summary>
        [pbr::OriginalName("CLOUD_TRACE_CONTEXT")] CloudTraceContext = 3,
        /// <summary>
        /// X-B3-* headers.
        /// </summary>
        [pbr::OriginalName("B3")] B3 = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// Configuration structure.
  /// </summary>
  public sealed partial class TraceServiceConfig : pb::IMessage<TraceServiceConfig> {
    private static readonly pb::MessageParser<TraceServiceConfig> _parser = new pb::MessageParser<TraceServiceConfig>(() => new TraceServiceConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TraceServiceConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceServiceConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceServiceConfig(TraceServiceConfig other) : this() {
      grpcService_ = other.grpcService_ != null ? other.grpcService_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceServiceConfig Clone() {
      return new TraceServiceConfig(this);
    }

    /// <summary>Field number for the "grpc_service" field.</summary>
    public const int GrpcServiceFieldNumber = 1;
    private global::Envoy.Api.V2.Core.GrpcService grpcService_;
    /// <summary>
    /// The upstream gRPC cluster that hosts the metrics service.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.GrpcService GrpcService {
      get { return grpcService_; }
      set {
        grpcService_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TraceServiceConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TraceServiceConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(GrpcService, other.GrpcService)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (grpcService_ != null) hash ^= GrpcService.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (grpcService_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(GrpcService);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (grpcService_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GrpcService);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TraceServiceConfig other) {
      if (other == null) {
        return;
      }
      if (other.grpcService_ != null) {
        if (grpcService_ == null) {
          GrpcService = new global::Envoy.Api.V2.Core.GrpcService();
        }
        GrpcService.MergeFrom(other.GrpcService);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (grpcService_ == null) {
              GrpcService = new global::Envoy.Api.V2.Core.GrpcService();
            }
            input.ReadMessage(GrpcService);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
