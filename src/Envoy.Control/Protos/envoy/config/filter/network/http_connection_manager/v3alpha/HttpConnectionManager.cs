// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/filter/network/http_connection_manager/v3alpha/http_connection_manager.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha {

  /// <summary>Holder for reflection information generated from envoy/config/filter/network/http_connection_manager/v3alpha/http_connection_manager.proto</summary>
  public static partial class HttpConnectionManagerReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/filter/network/http_connection_manager/v3alpha/http_connection_manager.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static HttpConnectionManagerReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ClllbnZveS9jb25maWcvZmlsdGVyL25ldHdvcmsvaHR0cF9jb25uZWN0aW9u",
            "X21hbmFnZXIvdjNhbHBoYS9odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci5wcm90",
            "bxI7ZW52b3kuY29uZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlv",
            "bl9tYW5hZ2VyLnYzYWxwaGEaKmVudm95L2FwaS92M2FscGhhL2NvcmUvY29u",
            "ZmlnX3NvdXJjZS5wcm90bxolZW52b3kvYXBpL3YzYWxwaGEvY29yZS9wcm90",
            "b2NvbC5wcm90bxobZW52b3kvYXBpL3YzYWxwaGEvcmRzLnByb3RvGhxlbnZv",
            "eS9hcGkvdjNhbHBoYS9zcmRzLnByb3RvGjVlbnZveS9jb25maWcvZmlsdGVy",
            "L2FjY2Vzc2xvZy92M2FscGhhL2FjY2Vzc2xvZy5wcm90bxoYZW52b3kvdHlw",
            "ZS9wZXJjZW50LnByb3RvGhlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvGh5n",
            "b29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8aHGdvb2dsZS9wcm90b2J1",
            "Zi9zdHJ1Y3QucHJvdG8aHmdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90",
            "bxoXdmFsaWRhdGUvdmFsaWRhdGUucHJvdG8i4RoKFUh0dHBDb25uZWN0aW9u",
            "TWFuYWdlchJ8Cgpjb2RlY190eXBlGAEgASgOMlwuZW52b3kuY29uZmlnLmZp",
            "bHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYzYWxwaGEu",
            "SHR0cENvbm5lY3Rpb25NYW5hZ2VyLkNvZGVjVHlwZUIKuunAAwWCAQIQARIe",
            "CgtzdGF0X3ByZWZpeBgCIAEoCUIJuunAAwRyAiABEk8KA3JkcxgDIAEoCzJA",
            "LmVudm95LmNvbmZpZy5maWx0ZXIubmV0d29yay5odHRwX2Nvbm5lY3Rpb25f",
            "bWFuYWdlci52M2FscGhhLlJkc0gAEj0KDHJvdXRlX2NvbmZpZxgEIAEoCzIl",
            "LmVudm95LmFwaS52M2FscGhhLlJvdXRlQ29uZmlndXJhdGlvbkgAEmIKDXNj",
            "b3BlZF9yb3V0ZXMYHyABKAsySS5lbnZveS5jb25maWcuZmlsdGVyLm5ldHdv",
            "cmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjNhbHBoYS5TY29wZWRSb3V0",
            "ZXNIABJdCgxodHRwX2ZpbHRlcnMYBSADKAsyRy5lbnZveS5jb25maWcuZmls",
            "dGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjNhbHBoYS5I",
            "dHRwRmlsdGVyEjIKDmFkZF91c2VyX2FnZW50GAYgASgLMhouZ29vZ2xlLnBy",
            "b3RvYnVmLkJvb2xWYWx1ZRJrCgd0cmFjaW5nGAcgASgLMlouZW52b3kuY29u",
            "ZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYz",
            "YWxwaGEuSHR0cENvbm5lY3Rpb25NYW5hZ2VyLlRyYWNpbmcSSwoVaHR0cF9w",
            "cm90b2NvbF9vcHRpb25zGAggASgLMiwuZW52b3kuYXBpLnYzYWxwaGEuY29y",
            "ZS5IdHRwMVByb3RvY29sT3B0aW9ucxJMChZodHRwMl9wcm90b2NvbF9vcHRp",
            "b25zGAkgASgLMiwuZW52b3kuYXBpLnYzYWxwaGEuY29yZS5IdHRwMlByb3Rv",
            "Y29sT3B0aW9ucxITCgtzZXJ2ZXJfbmFtZRgKIAEoCRKfAQocc2VydmVyX2hl",
            "YWRlcl90cmFuc2Zvcm1hdGlvbhgiIAEoDjJtLmVudm95LmNvbmZpZy5maWx0",
            "ZXIubmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci52M2FscGhhLkh0",
            "dHBDb25uZWN0aW9uTWFuYWdlci5TZXJ2ZXJIZWFkZXJUcmFuc2Zvcm1hdGlv",
            "bkIKuunAAwWCAQIQARJQChZtYXhfcmVxdWVzdF9oZWFkZXJzX2tiGB0gASgL",
            "MhwuZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlQhK66cADBCoCIAC66cAD",
            "BCoCGGASLwoMaWRsZV90aW1lb3V0GAsgASgLMhkuZ29vZ2xlLnByb3RvYnVm",
            "LkR1cmF0aW9uEjYKE3N0cmVhbV9pZGxlX3RpbWVvdXQYGCABKAsyGS5nb29n",
            "bGUucHJvdG9idWYuRHVyYXRpb24SMgoPcmVxdWVzdF90aW1lb3V0GBwgASgL",
            "MhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjAKDWRyYWluX3RpbWVvdXQY",
            "DCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SOAoVZGVsYXllZF9j",
            "bG9zZV90aW1lb3V0GBogASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9u",
            "EkQKCmFjY2Vzc19sb2cYDSADKAsyMC5lbnZveS5jb25maWcuZmlsdGVyLmFj",
            "Y2Vzc2xvZy52M2FscGhhLkFjY2Vzc0xvZxI2ChJ1c2VfcmVtb3RlX2FkZHJl",
            "c3MYDiABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlEhwKFHhmZl9u",
            "dW1fdHJ1c3RlZF9ob3BzGBMgASgNEokBChdpbnRlcm5hbF9hZGRyZXNzX2Nv",
            "bmZpZxgZIAEoCzJoLmVudm95LmNvbmZpZy5maWx0ZXIubmV0d29yay5odHRw",
            "X2Nvbm5lY3Rpb25fbWFuYWdlci52M2FscGhhLkh0dHBDb25uZWN0aW9uTWFu",
            "YWdlci5JbnRlcm5hbEFkZHJlc3NDb25maWcSFwoPc2tpcF94ZmZfYXBwZW5k",
            "GBUgASgIEgsKA3ZpYRgWIAEoCRI3ChNnZW5lcmF0ZV9yZXF1ZXN0X2lkGA8g",
            "ASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZRIkChxwcmVzZXJ2ZV9l",
            "eHRlcm5hbF9yZXF1ZXN0X2lkGCAgASgIEpwBChtmb3J3YXJkX2NsaWVudF9j",
            "ZXJ0X2RldGFpbHMYECABKA4yay5lbnZveS5jb25maWcuZmlsdGVyLm5ldHdv",
            "cmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjNhbHBoYS5IdHRwQ29ubmVj",
            "dGlvbk1hbmFnZXIuRm9yd2FyZENsaWVudENlcnREZXRhaWxzQgq66cADBYIB",
            "AhABEpcBCh9zZXRfY3VycmVudF9jbGllbnRfY2VydF9kZXRhaWxzGBEgASgL",
            "Mm4uZW52b3kuY29uZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlv",
            "bl9tYW5hZ2VyLnYzYWxwaGEuSHR0cENvbm5lY3Rpb25NYW5hZ2VyLlNldEN1",
            "cnJlbnRDbGllbnRDZXJ0RGV0YWlscxIaChJwcm94eV8xMDBfY29udGludWUY",
            "EiABKAgSOQoxcmVwcmVzZW50X2lwdjRfcmVtb3RlX2FkZHJlc3NfYXNfaXB2",
            "NF9tYXBwZWRfaXB2NhgUIAEoCBJ5Cg91cGdyYWRlX2NvbmZpZ3MYFyADKAsy",
            "YC5lbnZveS5jb25maWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9u",
            "X21hbmFnZXIudjNhbHBoYS5IdHRwQ29ubmVjdGlvbk1hbmFnZXIuVXBncmFk",
            "ZUNvbmZpZxIyCg5ub3JtYWxpemVfcGF0aBgeIAEoCzIaLmdvb2dsZS5wcm90",
            "b2J1Zi5Cb29sVmFsdWUSFQoNbWVyZ2Vfc2xhc2hlcxghIAEoCBqAAwoHVHJh",
            "Y2luZxKMAQoOb3BlcmF0aW9uX25hbWUYASABKA4yaC5lbnZveS5jb25maWcu",
            "ZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjNhbHBo",
            "YS5IdHRwQ29ubmVjdGlvbk1hbmFnZXIuVHJhY2luZy5PcGVyYXRpb25OYW1l",
            "Qgq66cADBYIBAhABEiAKGHJlcXVlc3RfaGVhZGVyc19mb3JfdGFncxgCIAMo",
            "CRIsCg9jbGllbnRfc2FtcGxpbmcYAyABKAsyEy5lbnZveS50eXBlLlBlcmNl",
            "bnQSLAoPcmFuZG9tX3NhbXBsaW5nGAQgASgLMhMuZW52b3kudHlwZS5QZXJj",
            "ZW50Ei0KEG92ZXJhbGxfc2FtcGxpbmcYBSABKAsyEy5lbnZveS50eXBlLlBl",
            "cmNlbnQSDwoHdmVyYm9zZRgGIAEoCCIoCg1PcGVyYXRpb25OYW1lEgsKB0lO",
            "R1JFU1MQABIKCgZFR1JFU1MQARotChVJbnRlcm5hbEFkZHJlc3NDb25maWcS",
            "FAoMdW5peF9zb2NrZXRzGAEgASgIGocBChtTZXRDdXJyZW50Q2xpZW50Q2Vy",
            "dERldGFpbHMSKwoHc3ViamVjdBgBIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5C",
            "b29sVmFsdWUSDAoEY2VydBgDIAEoCBINCgVjaGFpbhgGIAEoCBILCgNkbnMY",
            "BCABKAgSCwoDdXJpGAUgASgISgQIAhADGqwBCg1VcGdyYWRlQ29uZmlnEhQK",
            "DHVwZ3JhZGVfdHlwZRgBIAEoCRJYCgdmaWx0ZXJzGAIgAygLMkcuZW52b3ku",
            "Y29uZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2Vy",
            "LnYzYWxwaGEuSHR0cEZpbHRlchIrCgdlbmFibGVkGAMgASgLMhouZ29vZ2xl",
            "LnByb3RvYnVmLkJvb2xWYWx1ZSIrCglDb2RlY1R5cGUSCAoEQVVUTxAAEgkK",
            "BUhUVFAxEAESCQoFSFRUUDIQAiJTChpTZXJ2ZXJIZWFkZXJUcmFuc2Zvcm1h",
            "dGlvbhINCglPVkVSV1JJVEUQABIUChBBUFBFTkRfSUZfQUJTRU5UEAESEAoM",
            "UEFTU19USFJPVUdIEAIieQoYRm9yd2FyZENsaWVudENlcnREZXRhaWxzEgwK",
            "CFNBTklUSVpFEAASEAoMRk9SV0FSRF9PTkxZEAESEgoOQVBQRU5EX0ZPUldB",
            "UkQQAhIQCgxTQU5JVElaRV9TRVQQAxIXChNBTFdBWVNfRk9SV0FSRF9PTkxZ",
            "EARCGAoPcm91dGVfc3BlY2lmaWVyEgW46cADAUoECBsQHCJ0CgNSZHMSRwoN",
            "Y29uZmlnX3NvdXJjZRgBIAEoCzIkLmVudm95LmFwaS52M2FscGhhLmNvcmUu",
            "Q29uZmlnU291cmNlQgq66cADBYoBAhABEiQKEXJvdXRlX2NvbmZpZ19uYW1l",
            "GAIgASgJQgm66cADBHICIAEifQodU2NvcGVkUm91dGVDb25maWd1cmF0aW9u",
            "c0xpc3QSXAobc2NvcGVkX3JvdXRlX2NvbmZpZ3VyYXRpb25zGAEgAygLMisu",
            "ZW52b3kuYXBpLnYzYWxwaGEuU2NvcGVkUm91dGVDb25maWd1cmF0aW9uQgq6",
            "6cADBZIBAggBIq4JCgxTY29wZWRSb3V0ZXMSFwoEbmFtZRgBIAEoCUIJuunA",
            "AwRyAiABEoABChFzY29wZV9rZXlfYnVpbGRlchgCIAEoCzJZLmVudm95LmNv",
            "bmZpZy5maWx0ZXIubmV0d29yay5odHRwX2Nvbm5lY3Rpb25fbWFuYWdlci52",
            "M2FscGhhLlNjb3BlZFJvdXRlcy5TY29wZUtleUJ1aWxkZXJCCrrpwAMFigEC",
            "EAESSwoRcmRzX2NvbmZpZ19zb3VyY2UYAyABKAsyJC5lbnZveS5hcGkudjNh",
            "bHBoYS5jb3JlLkNvbmZpZ1NvdXJjZUIKuunAAwWKAQIQARKGAQogc2NvcGVk",
            "X3JvdXRlX2NvbmZpZ3VyYXRpb25zX2xpc3QYBCABKAsyWi5lbnZveS5jb25m",
            "aWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjNh",
            "bHBoYS5TY29wZWRSb3V0ZUNvbmZpZ3VyYXRpb25zTGlzdEgAElwKCnNjb3Bl",
            "ZF9yZHMYBSABKAsyRi5lbnZveS5jb25maWcuZmlsdGVyLm5ldHdvcmsuaHR0",
            "cF9jb25uZWN0aW9uX21hbmFnZXIudjNhbHBoYS5TY29wZWRSZHNIABqyBQoP",
            "U2NvcGVLZXlCdWlsZGVyEogBCglmcmFnbWVudHMYASADKAsyaS5lbnZveS5j",
            "b25maWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIu",
            "djNhbHBoYS5TY29wZWRSb3V0ZXMuU2NvcGVLZXlCdWlsZGVyLkZyYWdtZW50",
            "QnVpbGRlckIKuunAAwWSAQIIARqTBAoPRnJhZ21lbnRCdWlsZGVyEqABChZo",
            "ZWFkZXJfdmFsdWVfZXh0cmFjdG9yGAEgASgLMn4uZW52b3kuY29uZmlnLmZp",
            "bHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyLnYzYWxwaGEu",
            "U2NvcGVkUm91dGVzLlNjb3BlS2V5QnVpbGRlci5GcmFnbWVudEJ1aWxkZXIu",
            "SGVhZGVyVmFsdWVFeHRyYWN0b3JIABrNAgoUSGVhZGVyVmFsdWVFeHRyYWN0",
            "b3ISFwoEbmFtZRgBIAEoCUIJuunAAwRyAiABEhkKEWVsZW1lbnRfc2VwYXJh",
            "dG9yGAIgASgJEg8KBWluZGV4GAMgASgNSAASnAEKB2VsZW1lbnQYBCABKAsy",
            "iAEuZW52b3kuY29uZmlnLmZpbHRlci5uZXR3b3JrLmh0dHBfY29ubmVjdGlv",
            "bl9tYW5hZ2VyLnYzYWxwaGEuU2NvcGVkUm91dGVzLlNjb3BlS2V5QnVpbGRl",
            "ci5GcmFnbWVudEJ1aWxkZXIuSGVhZGVyVmFsdWVFeHRyYWN0b3IuS3ZFbGVt",
            "ZW50SAAaQQoJS3ZFbGVtZW50EhwKCXNlcGFyYXRvchgBIAEoCUIJuunAAwRy",
            "AiABEhYKA2tleRgCIAEoCUIJuunAAwRyAiABQg4KDGV4dHJhY3RfdHlwZUIN",
            "CgR0eXBlEgW46cADAUIZChBjb25maWdfc3BlY2lmaWVyEgW46cADASJfCglT",
            "Y29wZWRSZHMSUgoYc2NvcGVkX3Jkc19jb25maWdfc291cmNlGAEgASgLMiQu",
            "ZW52b3kuYXBpLnYzYWxwaGEuY29yZS5Db25maWdTb3VyY2VCCrrpwAMFigEC",
            "EAEikwEKCkh0dHBGaWx0ZXISFwoEbmFtZRgBIAEoCUIJuunAAwRyAiABEikK",
            "BmNvbmZpZxgCIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIsCgx0",
            "eXBlZF9jb25maWcYBCABKAsyFC5nb29nbGUucHJvdG9idWYuQW55SABCDQoL",
            "Y29uZmlnX3R5cGVKBAgDEARCaQpJaW8uZW52b3lwcm94eS5lbnZveS5jb25m",
            "aWcuZmlsdGVyLm5ldHdvcmsuaHR0cF9jb25uZWN0aW9uX21hbmFnZXIudjNh",
            "bHBoYUIaSHR0cENvbm5lY3Rpb25NYW5hZ2VyUHJvdG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V3Alpha.Core.ConfigSourceReflection.Descriptor, global::Envoy.Api.V3Alpha.Core.ProtocolReflection.Descriptor, global::Envoy.Api.V3Alpha.RdsReflection.Descriptor, global::Envoy.Api.V3Alpha.SrdsReflection.Descriptor, global::Envoy.Config.Filter.Accesslog.V3Alpha.AccesslogReflection.Descriptor, global::Envoy.Type.PercentReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.AnyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Parser, new[]{ "CodecType", "StatPrefix", "Rds", "RouteConfig", "ScopedRoutes", "HttpFilters", "AddUserAgent", "Tracing", "HttpProtocolOptions", "Http2ProtocolOptions", "ServerName", "ServerHeaderTransformation", "MaxRequestHeadersKb", "IdleTimeout", "StreamIdleTimeout", "RequestTimeout", "DrainTimeout", "DelayedCloseTimeout", "AccessLog", "UseRemoteAddress", "XffNumTrustedHops", "InternalAddressConfig", "SkipXffAppend", "Via", "GenerateRequestId", "PreserveExternalRequestId", "ForwardClientCertDetails", "SetCurrentClientCertDetails", "Proxy100Continue", "RepresentIpv4RemoteAddressAsIpv4MappedIpv6", "UpgradeConfigs", "NormalizePath", "MergeSlashes" }, new[]{ "RouteSpecifier" }, new[]{ typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType), typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation), typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Parser, new[]{ "OperationName", "RequestHeadersForTags", "ClientSampling", "RandomSampling", "OverallSampling", "Verbose" }, null, new[]{ typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.InternalAddressConfig), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.InternalAddressConfig.Parser, new[]{ "UnixSockets" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.SetCurrentClientCertDetails), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.SetCurrentClientCertDetails.Parser, new[]{ "Subject", "Cert", "Chain", "Dns", "Uri" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.UpgradeConfig), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.UpgradeConfig.Parser, new[]{ "UpgradeType", "Filters", "Enabled" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.Rds), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.Rds.Parser, new[]{ "ConfigSource", "RouteConfigName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRouteConfigurationsList), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRouteConfigurationsList.Parser, new[]{ "ScopedRouteConfigurations" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Parser, new[]{ "Name", "ScopeKeyBuilder", "RdsConfigSource", "ScopedRouteConfigurationsList", "ScopedRds" }, new[]{ "ConfigSpecifier" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Parser, new[]{ "Fragments" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Parser, new[]{ "HeaderValueExtractor" }, new[]{ "Type" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Parser, new[]{ "Name", "ElementSeparator", "Index", "Element" }, new[]{ "ExtractType" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement.Parser, new[]{ "Separator", "Key" }, null, null, null, null)})})})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRds), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRds.Parser, new[]{ "ScopedRdsConfigSource" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter), global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter.Parser, new[]{ "Name", "Config", "TypedConfig" }, new[]{ "ConfigType" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// [#comment:next free field: 35]
  /// </summary>
  public sealed partial class HttpConnectionManager : pb::IMessage<HttpConnectionManager> {
    private static readonly pb::MessageParser<HttpConnectionManager> _parser = new pb::MessageParser<HttpConnectionManager>(() => new HttpConnectionManager());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HttpConnectionManager> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManagerReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpConnectionManager() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpConnectionManager(HttpConnectionManager other) : this() {
      codecType_ = other.codecType_;
      statPrefix_ = other.statPrefix_;
      httpFilters_ = other.httpFilters_.Clone();
      AddUserAgent = other.AddUserAgent;
      tracing_ = other.tracing_ != null ? other.tracing_.Clone() : null;
      httpProtocolOptions_ = other.httpProtocolOptions_ != null ? other.httpProtocolOptions_.Clone() : null;
      http2ProtocolOptions_ = other.http2ProtocolOptions_ != null ? other.http2ProtocolOptions_.Clone() : null;
      serverName_ = other.serverName_;
      serverHeaderTransformation_ = other.serverHeaderTransformation_;
      MaxRequestHeadersKb = other.MaxRequestHeadersKb;
      idleTimeout_ = other.idleTimeout_ != null ? other.idleTimeout_.Clone() : null;
      streamIdleTimeout_ = other.streamIdleTimeout_ != null ? other.streamIdleTimeout_.Clone() : null;
      requestTimeout_ = other.requestTimeout_ != null ? other.requestTimeout_.Clone() : null;
      drainTimeout_ = other.drainTimeout_ != null ? other.drainTimeout_.Clone() : null;
      delayedCloseTimeout_ = other.delayedCloseTimeout_ != null ? other.delayedCloseTimeout_.Clone() : null;
      accessLog_ = other.accessLog_.Clone();
      UseRemoteAddress = other.UseRemoteAddress;
      xffNumTrustedHops_ = other.xffNumTrustedHops_;
      internalAddressConfig_ = other.internalAddressConfig_ != null ? other.internalAddressConfig_.Clone() : null;
      skipXffAppend_ = other.skipXffAppend_;
      via_ = other.via_;
      GenerateRequestId = other.GenerateRequestId;
      preserveExternalRequestId_ = other.preserveExternalRequestId_;
      forwardClientCertDetails_ = other.forwardClientCertDetails_;
      setCurrentClientCertDetails_ = other.setCurrentClientCertDetails_ != null ? other.setCurrentClientCertDetails_.Clone() : null;
      proxy100Continue_ = other.proxy100Continue_;
      representIpv4RemoteAddressAsIpv4MappedIpv6_ = other.representIpv4RemoteAddressAsIpv4MappedIpv6_;
      upgradeConfigs_ = other.upgradeConfigs_.Clone();
      NormalizePath = other.NormalizePath;
      mergeSlashes_ = other.mergeSlashes_;
      switch (other.RouteSpecifierCase) {
        case RouteSpecifierOneofCase.Rds:
          Rds = other.Rds.Clone();
          break;
        case RouteSpecifierOneofCase.RouteConfig:
          RouteConfig = other.RouteConfig.Clone();
          break;
        case RouteSpecifierOneofCase.ScopedRoutes:
          ScopedRoutes = other.ScopedRoutes.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpConnectionManager Clone() {
      return new HttpConnectionManager(this);
    }

    /// <summary>Field number for the "codec_type" field.</summary>
    public const int CodecTypeFieldNumber = 1;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType codecType_ = global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType.Auto;
    /// <summary>
    /// Supplies the type of codec that the connection manager should use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType CodecType {
      get { return codecType_; }
      set {
        codecType_ = value;
      }
    }

    /// <summary>Field number for the "stat_prefix" field.</summary>
    public const int StatPrefixFieldNumber = 2;
    private string statPrefix_ = "";
    /// <summary>
    /// The human readable prefix to use when emitting statistics for the
    /// connection manager. See the :ref:`statistics documentation &lt;config_http_conn_man_stats>` for
    /// more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StatPrefix {
      get { return statPrefix_; }
      set {
        statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "rds" field.</summary>
    public const int RdsFieldNumber = 3;
    /// <summary>
    /// The connection manager’s route table will be dynamically loaded via the RDS API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.Rds Rds {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.Rds ? (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.Rds) routeSpecifier_ : null; }
      set {
        routeSpecifier_ = value;
        routeSpecifierCase_ = value == null ? RouteSpecifierOneofCase.None : RouteSpecifierOneofCase.Rds;
      }
    }

    /// <summary>Field number for the "route_config" field.</summary>
    public const int RouteConfigFieldNumber = 4;
    /// <summary>
    /// The route table for the connection manager is static and is specified in this property.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.RouteConfiguration RouteConfig {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig ? (global::Envoy.Api.V3Alpha.RouteConfiguration) routeSpecifier_ : null; }
      set {
        routeSpecifier_ = value;
        routeSpecifierCase_ = value == null ? RouteSpecifierOneofCase.None : RouteSpecifierOneofCase.RouteConfig;
      }
    }

    /// <summary>Field number for the "scoped_routes" field.</summary>
    public const int ScopedRoutesFieldNumber = 31;
    /// <summary>
    /// A route table will be dynamically assigned to each request based on request attributes
    /// (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
    /// specified in this message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes ScopedRoutes {
      get { return routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes ? (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes) routeSpecifier_ : null; }
      set {
        routeSpecifier_ = value;
        routeSpecifierCase_ = value == null ? RouteSpecifierOneofCase.None : RouteSpecifierOneofCase.ScopedRoutes;
      }
    }

    /// <summary>Field number for the "http_filters" field.</summary>
    public const int HttpFiltersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter> _repeated_httpFilters_codec
        = pb::FieldCodec.ForMessage(42, global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter> httpFilters_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter>();
    /// <summary>
    /// A list of individual HTTP filters that make up the filter chain for
    /// requests made to the connection manager. Order matters as the filters are
    /// processed sequentially as request events happen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter> HttpFilters {
      get { return httpFilters_; }
    }

    /// <summary>Field number for the "add_user_agent" field.</summary>
    public const int AddUserAgentFieldNumber = 6;
    private static readonly pb::FieldCodec<bool?> _single_addUserAgent_codec = pb::FieldCodec.ForStructWrapper<bool>(50);
    private bool? addUserAgent_;
    /// <summary>
    /// Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
    /// and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
    /// documentation for more information. Defaults to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? AddUserAgent {
      get { return addUserAgent_; }
      set {
        addUserAgent_ = value;
      }
    }


    /// <summary>Field number for the "tracing" field.</summary>
    public const int TracingFieldNumber = 7;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing tracing_;
    /// <summary>
    /// Presence of the object defines whether the connection manager
    /// emits :ref:`tracing &lt;arch_overview_tracing>` data to the :ref:`configured tracing provider
    /// &lt;envoy_api_msg_config.trace.v3alpha.Tracing>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing Tracing {
      get { return tracing_; }
      set {
        tracing_ = value;
      }
    }

    /// <summary>Field number for the "http_protocol_options" field.</summary>
    public const int HttpProtocolOptionsFieldNumber = 8;
    private global::Envoy.Api.V3Alpha.Core.Http1ProtocolOptions httpProtocolOptions_;
    /// <summary>
    /// Additional HTTP/1 settings that are passed to the HTTP/1 codec.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.Http1ProtocolOptions HttpProtocolOptions {
      get { return httpProtocolOptions_; }
      set {
        httpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 9;
    private global::Envoy.Api.V3Alpha.Core.Http2ProtocolOptions http2ProtocolOptions_;
    /// <summary>
    /// Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "server_name" field.</summary>
    public const int ServerNameFieldNumber = 10;
    private string serverName_ = "";
    /// <summary>
    /// An optional override that the connection manager will write to the server
    /// header in responses. If not set, the default is *envoy*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ServerName {
      get { return serverName_; }
      set {
        serverName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "server_header_transformation" field.</summary>
    public const int ServerHeaderTransformationFieldNumber = 34;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation serverHeaderTransformation_ = global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite;
    /// <summary>
    /// Defines the action to be applied to the Server header on the response path.
    /// By default, Envoy will overwrite the header with the value specified in
    /// server_name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation ServerHeaderTransformation {
      get { return serverHeaderTransformation_; }
      set {
        serverHeaderTransformation_ = value;
      }
    }

    /// <summary>Field number for the "max_request_headers_kb" field.</summary>
    public const int MaxRequestHeadersKbFieldNumber = 29;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestHeadersKb_codec = pb::FieldCodec.ForStructWrapper<uint>(234);
    private uint? maxRequestHeadersKb_;
    /// <summary>
    /// The maximum request headers size for incoming connections.
    /// If unconfigured, the default max request headers allowed is 60 KiB.
    /// Requests that exceed this limit will receive a 431 response.
    /// The max configurable limit is 96 KiB, based on current implementation
    /// constraints.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxRequestHeadersKb {
      get { return maxRequestHeadersKb_; }
      set {
        maxRequestHeadersKb_ = value;
      }
    }


    /// <summary>Field number for the "idle_timeout" field.</summary>
    public const int IdleTimeoutFieldNumber = 11;
    private global::Google.Protobuf.WellKnownTypes.Duration idleTimeout_;
    /// <summary>
    /// The idle timeout for connections managed by the connection manager. The
    /// idle timeout is defined as the period in which there are no active
    /// requests. If not set, there is no idle timeout. When the idle timeout is
    /// reached the connection will be closed. If the connection is an HTTP/2
    /// connection a drain sequence will occur prior to closing the connection. See
    /// :ref:`drain_timeout
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v3alpha.HttpConnectionManager.drain_timeout>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration IdleTimeout {
      get { return idleTimeout_; }
      set {
        idleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "stream_idle_timeout" field.</summary>
    public const int StreamIdleTimeoutFieldNumber = 24;
    private global::Google.Protobuf.WellKnownTypes.Duration streamIdleTimeout_;
    /// <summary>
    /// The stream idle timeout for connections managed by the connection manager.
    /// If not specified, this defaults to 5 minutes. The default value was selected
    /// so as not to interfere with any smaller configured timeouts that may have
    /// existed in configurations prior to the introduction of this feature, while
    /// introducing robustness to TCP connections that terminate without a FIN.
    ///
    /// This idle timeout applies to new streams and is overridable by the
    /// :ref:`route-level idle_timeout
    /// &lt;envoy_api_field_route.RouteAction.idle_timeout>`. Even on a stream in
    /// which the override applies, prior to receipt of the initial request
    /// headers, the :ref:`stream_idle_timeout
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v3alpha.HttpConnectionManager.stream_idle_timeout>`
    /// applies. Each time an encode/decode event for headers or data is processed
    /// for the stream, the timer will be reset. If the timeout fires, the stream
    /// is terminated with a 408 Request Timeout error code if no upstream response
    /// header has been received, otherwise a stream reset occurs.
    ///
    /// Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
    /// to the granularity of events presented to the connection manager. For example, while receiving
    /// very large request headers, it may be the case that there is traffic regularly arriving on the
    /// wire while the connection manage is only able to observe the end-of-headers event, hence the
    /// stream may still idle timeout.
    ///
    /// A value of 0 will completely disable the connection manager stream idle
    /// timeout, although per-route idle timeout overrides will continue to apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration StreamIdleTimeout {
      get { return streamIdleTimeout_; }
      set {
        streamIdleTimeout_ = value;
      }
    }

    /// <summary>Field number for the "request_timeout" field.</summary>
    public const int RequestTimeoutFieldNumber = 28;
    private global::Google.Protobuf.WellKnownTypes.Duration requestTimeout_;
    /// <summary>
    /// A timeout for idle requests managed by the connection manager.
    /// The timer is activated when the request is initiated, and is disarmed when the last byte of the
    /// request is sent upstream (i.e. all decoding filters have processed the request), OR when the
    /// response is initiated. If not specified or set to 0, this timeout is disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration RequestTimeout {
      get { return requestTimeout_; }
      set {
        requestTimeout_ = value;
      }
    }

    /// <summary>Field number for the "drain_timeout" field.</summary>
    public const int DrainTimeoutFieldNumber = 12;
    private global::Google.Protobuf.WellKnownTypes.Duration drainTimeout_;
    /// <summary>
    /// The time that Envoy will wait between sending an HTTP/2 “shutdown
    /// notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
    /// This is used so that Envoy provides a grace period for new streams that
    /// race with the final GOAWAY frame. During this grace period, Envoy will
    /// continue to accept new streams. After the grace period, a final GOAWAY
    /// frame is sent and Envoy will start refusing new streams. Draining occurs
    /// both when a connection hits the idle timeout or during general server
    /// draining. The default grace period is 5000 milliseconds (5 seconds) if this
    /// option is not specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration DrainTimeout {
      get { return drainTimeout_; }
      set {
        drainTimeout_ = value;
      }
    }

    /// <summary>Field number for the "delayed_close_timeout" field.</summary>
    public const int DelayedCloseTimeoutFieldNumber = 26;
    private global::Google.Protobuf.WellKnownTypes.Duration delayedCloseTimeout_;
    /// <summary>
    /// The delayed close timeout is for downstream connections managed by the HTTP connection manager.
    /// It is defined as a grace period after connection close processing has been locally initiated
    /// during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
    /// from the downstream connection) prior to Envoy closing the socket associated with that
    /// connection.
    /// NOTE: This timeout is enforced even when the socket associated with the downstream connection
    /// is pending a flush of the write buffer. However, any progress made writing data to the socket
    /// will restart the timer associated with this timeout. This means that the total grace period for
    /// a socket in this state will be
    /// &lt;total_time_waiting_for_write_buffer_flushes>+&lt;delayed_close_timeout>.
    ///
    /// Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
    /// sequence mitigates a race condition that exists when downstream clients do not drain/process
    /// data in a connection's receive buffer after a remote close has been detected via a socket
    /// write(). This race leads to such clients failing to process the response code sent by Envoy,
    /// which could result in erroneous downstream processing.
    ///
    /// If the timeout triggers, Envoy will close the connection's socket.
    ///
    /// The default timeout is 1000 ms if this option is not specified.
    ///
    /// .. NOTE::
    ///    To be useful in avoiding the race condition described above, this timeout must be set
    ///    to *at least* &lt;max round trip time expected between clients and Envoy>+&lt;100ms to account for
    ///    a reasonsable "worst" case processing time for a full iteration of Envoy's event loop>.
    ///
    /// .. WARNING::
    ///    A value of 0 will completely disable delayed close processing. When disabled, the downstream
    ///    connection's socket will be closed immediately after the write flush is completed or will
    ///    never close if the write flush does not complete.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration DelayedCloseTimeout {
      get { return delayedCloseTimeout_; }
      set {
        delayedCloseTimeout_ = value;
      }
    }

    /// <summary>Field number for the "access_log" field.</summary>
    public const int AccessLogFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Accesslog.V3Alpha.AccessLog> _repeated_accessLog_codec
        = pb::FieldCodec.ForMessage(106, global::Envoy.Config.Filter.Accesslog.V3Alpha.AccessLog.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V3Alpha.AccessLog> accessLog_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V3Alpha.AccessLog>();
    /// <summary>
    /// Configuration for :ref:`HTTP access logs &lt;arch_overview_access_logs>`
    /// emitted by the connection manager.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Filter.Accesslog.V3Alpha.AccessLog> AccessLog {
      get { return accessLog_; }
    }

    /// <summary>Field number for the "use_remote_address" field.</summary>
    public const int UseRemoteAddressFieldNumber = 14;
    private static readonly pb::FieldCodec<bool?> _single_useRemoteAddress_codec = pb::FieldCodec.ForStructWrapper<bool>(114);
    private bool? useRemoteAddress_;
    /// <summary>
    /// If set to true, the connection manager will use the real remote address
    /// of the client connection when determining internal versus external origin and manipulating
    /// various headers. If set to false or absent, the connection manager will use the
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
    /// :ref:`config_http_conn_man_headers_x-forwarded-for`,
    /// :ref:`config_http_conn_man_headers_x-envoy-internal`, and
    /// :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? UseRemoteAddress {
      get { return useRemoteAddress_; }
      set {
        useRemoteAddress_ = value;
      }
    }


    /// <summary>Field number for the "xff_num_trusted_hops" field.</summary>
    public const int XffNumTrustedHopsFieldNumber = 19;
    private uint xffNumTrustedHops_;
    /// <summary>
    /// The number of additional ingress proxy hops from the right side of the
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
    /// determining the origin client's IP address. The default is zero if this option
    /// is not specified. See the documentation for
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint XffNumTrustedHops {
      get { return xffNumTrustedHops_; }
      set {
        xffNumTrustedHops_ = value;
      }
    }

    /// <summary>Field number for the "internal_address_config" field.</summary>
    public const int InternalAddressConfigFieldNumber = 25;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.InternalAddressConfig internalAddressConfig_;
    /// <summary>
    /// Configures what network addresses are considered internal for stats and header sanitation
    /// purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
    /// See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
    /// information about internal/external addresses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.InternalAddressConfig InternalAddressConfig {
      get { return internalAddressConfig_; }
      set {
        internalAddressConfig_ = value;
      }
    }

    /// <summary>Field number for the "skip_xff_append" field.</summary>
    public const int SkipXffAppendFieldNumber = 21;
    private bool skipXffAppend_;
    /// <summary>
    /// If set, Envoy will not append the remote address to the
    /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
    /// conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
    /// has mutated the request headers. While :ref:`use_remote_address
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v3alpha.HttpConnectionManager.use_remote_address>`
    /// will also suppress XFF addition, it has consequences for logging and other
    /// Envoy uses of the remote address, so *skip_xff_append* should be used
    /// when only an elision of XFF addition is intended.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SkipXffAppend {
      get { return skipXffAppend_; }
      set {
        skipXffAppend_ = value;
      }
    }

    /// <summary>Field number for the "via" field.</summary>
    public const int ViaFieldNumber = 22;
    private string via_ = "";
    /// <summary>
    /// Via header value to append to request and response headers. If this is
    /// empty, no via header will be appended.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Via {
      get { return via_; }
      set {
        via_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "generate_request_id" field.</summary>
    public const int GenerateRequestIdFieldNumber = 15;
    private static readonly pb::FieldCodec<bool?> _single_generateRequestId_codec = pb::FieldCodec.ForStructWrapper<bool>(122);
    private bool? generateRequestId_;
    /// <summary>
    /// Whether the connection manager will generate the :ref:`x-request-id
    /// &lt;config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
    /// true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
    /// is not desired it can be disabled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? GenerateRequestId {
      get { return generateRequestId_; }
      set {
        generateRequestId_ = value;
      }
    }


    /// <summary>Field number for the "preserve_external_request_id" field.</summary>
    public const int PreserveExternalRequestIdFieldNumber = 32;
    private bool preserveExternalRequestId_;
    /// <summary>
    /// Whether the connection manager will keep the :ref:`x-request-id
    /// &lt;config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
    /// (Edge request is the request from external clients to front Envoy) and not reset it, which
    /// is the current Envoy behaviour. This defaults to false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PreserveExternalRequestId {
      get { return preserveExternalRequestId_; }
      set {
        preserveExternalRequestId_ = value;
      }
    }

    /// <summary>Field number for the "forward_client_cert_details" field.</summary>
    public const int ForwardClientCertDetailsFieldNumber = 16;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails forwardClientCertDetails_ = global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize;
    /// <summary>
    /// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
    /// header.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails ForwardClientCertDetails {
      get { return forwardClientCertDetails_; }
      set {
        forwardClientCertDetails_ = value;
      }
    }

    /// <summary>Field number for the "set_current_client_cert_details" field.</summary>
    public const int SetCurrentClientCertDetailsFieldNumber = 17;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.SetCurrentClientCertDetails setCurrentClientCertDetails_;
    /// <summary>
    /// This field is valid only when :ref:`forward_client_cert_details
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v3alpha.HttpConnectionManager.forward_client_cert_details>`
    /// is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
    /// the client certificate to be forwarded. Note that in the
    /// :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
    /// *By* is always set when the client certificate presents the URI type Subject Alternative Name
    /// value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.SetCurrentClientCertDetails SetCurrentClientCertDetails {
      get { return setCurrentClientCertDetails_; }
      set {
        setCurrentClientCertDetails_ = value;
      }
    }

    /// <summary>Field number for the "proxy_100_continue" field.</summary>
    public const int Proxy100ContinueFieldNumber = 18;
    private bool proxy100Continue_;
    /// <summary>
    /// If proxy_100_continue is true, Envoy will proxy incoming "Expect:
    /// 100-continue" headers upstream, and forward "100 Continue" responses
    /// downstream. If this is false or not set, Envoy will instead strip the
    /// "Expect: 100-continue" header, and send a "100 Continue" response itself.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Proxy100Continue {
      get { return proxy100Continue_; }
      set {
        proxy100Continue_ = value;
      }
    }

    /// <summary>Field number for the "represent_ipv4_remote_address_as_ipv4_mapped_ipv6" field.</summary>
    public const int RepresentIpv4RemoteAddressAsIpv4MappedIpv6FieldNumber = 20;
    private bool representIpv4RemoteAddressAsIpv4MappedIpv6_;
    /// <summary>
    /// If
    /// :ref:`use_remote_address
    /// &lt;envoy_api_field_config.filter.network.http_connection_manager.v3alpha.HttpConnectionManager.use_remote_address>`
    /// is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
    /// an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
    /// This is useful for testing compatibility of upstream services that parse the header value. For
    /// example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
    /// &lt;https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
    /// :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
    /// :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
    /// &lt;config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
    /// control.
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RepresentIpv4RemoteAddressAsIpv4MappedIpv6 {
      get { return representIpv4RemoteAddressAsIpv4MappedIpv6_; }
      set {
        representIpv4RemoteAddressAsIpv4MappedIpv6_ = value;
      }
    }

    /// <summary>Field number for the "upgrade_configs" field.</summary>
    public const int UpgradeConfigsFieldNumber = 23;
    private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.UpgradeConfig> _repeated_upgradeConfigs_codec
        = pb::FieldCodec.ForMessage(186, global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.UpgradeConfig.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.UpgradeConfig> upgradeConfigs_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.UpgradeConfig>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.UpgradeConfig> UpgradeConfigs {
      get { return upgradeConfigs_; }
    }

    /// <summary>Field number for the "normalize_path" field.</summary>
    public const int NormalizePathFieldNumber = 30;
    private static readonly pb::FieldCodec<bool?> _single_normalizePath_codec = pb::FieldCodec.ForStructWrapper<bool>(242);
    private bool? normalizePath_;
    /// <summary>
    /// Should paths be normalized according to RFC 3986 before any processing of
    /// requests by HTTP filters or routing? This affects the upstream *:path* header
    /// as well. For paths that fail this check, Envoy will respond with 400 to
    /// paths that are malformed. This defaults to false currently but will default
    /// true in the future. When not specified, this value may be overridden by the
    /// runtime variable
    /// :ref:`http_connection_manager.normalize_path&lt;config_http_conn_man_runtime_normalize_path>`.
    /// See `Normalization and Comparison &lt;https://tools.ietf.org/html/rfc3986#section-6>`
    /// for details of normalization.
    /// Note that Envoy does not perform
    /// `case normalization &lt;https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? NormalizePath {
      get { return normalizePath_; }
      set {
        normalizePath_ = value;
      }
    }


    /// <summary>Field number for the "merge_slashes" field.</summary>
    public const int MergeSlashesFieldNumber = 33;
    private bool mergeSlashes_;
    /// <summary>
    /// Determines if adjacent slashes in the path are merged into one before any processing of
    /// requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
    /// setting this option, incoming requests with path `//dir///file` will not match against route
    /// with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
    /// `HTTP spec &lt;https://tools.ietf.org/html/rfc3986>` and is provided for convenience.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MergeSlashes {
      get { return mergeSlashes_; }
      set {
        mergeSlashes_ = value;
      }
    }

    private object routeSpecifier_;
    /// <summary>Enum of possible cases for the "route_specifier" oneof.</summary>
    public enum RouteSpecifierOneofCase {
      None = 0,
      Rds = 3,
      RouteConfig = 4,
      ScopedRoutes = 31,
    }
    private RouteSpecifierOneofCase routeSpecifierCase_ = RouteSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RouteSpecifierOneofCase RouteSpecifierCase {
      get { return routeSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRouteSpecifier() {
      routeSpecifierCase_ = RouteSpecifierOneofCase.None;
      routeSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HttpConnectionManager);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HttpConnectionManager other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CodecType != other.CodecType) return false;
      if (StatPrefix != other.StatPrefix) return false;
      if (!object.Equals(Rds, other.Rds)) return false;
      if (!object.Equals(RouteConfig, other.RouteConfig)) return false;
      if (!object.Equals(ScopedRoutes, other.ScopedRoutes)) return false;
      if(!httpFilters_.Equals(other.httpFilters_)) return false;
      if (AddUserAgent != other.AddUserAgent) return false;
      if (!object.Equals(Tracing, other.Tracing)) return false;
      if (!object.Equals(HttpProtocolOptions, other.HttpProtocolOptions)) return false;
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      if (ServerName != other.ServerName) return false;
      if (ServerHeaderTransformation != other.ServerHeaderTransformation) return false;
      if (MaxRequestHeadersKb != other.MaxRequestHeadersKb) return false;
      if (!object.Equals(IdleTimeout, other.IdleTimeout)) return false;
      if (!object.Equals(StreamIdleTimeout, other.StreamIdleTimeout)) return false;
      if (!object.Equals(RequestTimeout, other.RequestTimeout)) return false;
      if (!object.Equals(DrainTimeout, other.DrainTimeout)) return false;
      if (!object.Equals(DelayedCloseTimeout, other.DelayedCloseTimeout)) return false;
      if(!accessLog_.Equals(other.accessLog_)) return false;
      if (UseRemoteAddress != other.UseRemoteAddress) return false;
      if (XffNumTrustedHops != other.XffNumTrustedHops) return false;
      if (!object.Equals(InternalAddressConfig, other.InternalAddressConfig)) return false;
      if (SkipXffAppend != other.SkipXffAppend) return false;
      if (Via != other.Via) return false;
      if (GenerateRequestId != other.GenerateRequestId) return false;
      if (PreserveExternalRequestId != other.PreserveExternalRequestId) return false;
      if (ForwardClientCertDetails != other.ForwardClientCertDetails) return false;
      if (!object.Equals(SetCurrentClientCertDetails, other.SetCurrentClientCertDetails)) return false;
      if (Proxy100Continue != other.Proxy100Continue) return false;
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6) return false;
      if(!upgradeConfigs_.Equals(other.upgradeConfigs_)) return false;
      if (NormalizePath != other.NormalizePath) return false;
      if (MergeSlashes != other.MergeSlashes) return false;
      if (RouteSpecifierCase != other.RouteSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CodecType != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType.Auto) hash ^= CodecType.GetHashCode();
      if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) hash ^= Rds.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) hash ^= RouteConfig.GetHashCode();
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) hash ^= ScopedRoutes.GetHashCode();
      hash ^= httpFilters_.GetHashCode();
      if (addUserAgent_ != null) hash ^= AddUserAgent.GetHashCode();
      if (tracing_ != null) hash ^= Tracing.GetHashCode();
      if (httpProtocolOptions_ != null) hash ^= HttpProtocolOptions.GetHashCode();
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      if (ServerName.Length != 0) hash ^= ServerName.GetHashCode();
      if (ServerHeaderTransformation != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) hash ^= ServerHeaderTransformation.GetHashCode();
      if (maxRequestHeadersKb_ != null) hash ^= MaxRequestHeadersKb.GetHashCode();
      if (idleTimeout_ != null) hash ^= IdleTimeout.GetHashCode();
      if (streamIdleTimeout_ != null) hash ^= StreamIdleTimeout.GetHashCode();
      if (requestTimeout_ != null) hash ^= RequestTimeout.GetHashCode();
      if (drainTimeout_ != null) hash ^= DrainTimeout.GetHashCode();
      if (delayedCloseTimeout_ != null) hash ^= DelayedCloseTimeout.GetHashCode();
      hash ^= accessLog_.GetHashCode();
      if (useRemoteAddress_ != null) hash ^= UseRemoteAddress.GetHashCode();
      if (XffNumTrustedHops != 0) hash ^= XffNumTrustedHops.GetHashCode();
      if (internalAddressConfig_ != null) hash ^= InternalAddressConfig.GetHashCode();
      if (SkipXffAppend != false) hash ^= SkipXffAppend.GetHashCode();
      if (Via.Length != 0) hash ^= Via.GetHashCode();
      if (generateRequestId_ != null) hash ^= GenerateRequestId.GetHashCode();
      if (PreserveExternalRequestId != false) hash ^= PreserveExternalRequestId.GetHashCode();
      if (ForwardClientCertDetails != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) hash ^= ForwardClientCertDetails.GetHashCode();
      if (setCurrentClientCertDetails_ != null) hash ^= SetCurrentClientCertDetails.GetHashCode();
      if (Proxy100Continue != false) hash ^= Proxy100Continue.GetHashCode();
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) hash ^= RepresentIpv4RemoteAddressAsIpv4MappedIpv6.GetHashCode();
      hash ^= upgradeConfigs_.GetHashCode();
      if (normalizePath_ != null) hash ^= NormalizePath.GetHashCode();
      if (MergeSlashes != false) hash ^= MergeSlashes.GetHashCode();
      hash ^= (int) routeSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CodecType != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType.Auto) {
        output.WriteRawTag(8);
        output.WriteEnum((int) CodecType);
      }
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
        output.WriteRawTag(26);
        output.WriteMessage(Rds);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
        output.WriteRawTag(34);
        output.WriteMessage(RouteConfig);
      }
      httpFilters_.WriteTo(output, _repeated_httpFilters_codec);
      if (addUserAgent_ != null) {
        _single_addUserAgent_codec.WriteTagAndValue(output, AddUserAgent);
      }
      if (tracing_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Tracing);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (ServerName.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(ServerName);
      }
      if (idleTimeout_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(IdleTimeout);
      }
      if (drainTimeout_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(DrainTimeout);
      }
      accessLog_.WriteTo(output, _repeated_accessLog_codec);
      if (useRemoteAddress_ != null) {
        _single_useRemoteAddress_codec.WriteTagAndValue(output, UseRemoteAddress);
      }
      if (generateRequestId_ != null) {
        _single_generateRequestId_codec.WriteTagAndValue(output, GenerateRequestId);
      }
      if (ForwardClientCertDetails != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) ForwardClientCertDetails);
      }
      if (setCurrentClientCertDetails_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(SetCurrentClientCertDetails);
      }
      if (Proxy100Continue != false) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Proxy100Continue);
      }
      if (XffNumTrustedHops != 0) {
        output.WriteRawTag(152, 1);
        output.WriteUInt32(XffNumTrustedHops);
      }
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        output.WriteRawTag(160, 1);
        output.WriteBool(RepresentIpv4RemoteAddressAsIpv4MappedIpv6);
      }
      if (SkipXffAppend != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(SkipXffAppend);
      }
      if (Via.Length != 0) {
        output.WriteRawTag(178, 1);
        output.WriteString(Via);
      }
      upgradeConfigs_.WriteTo(output, _repeated_upgradeConfigs_codec);
      if (streamIdleTimeout_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(StreamIdleTimeout);
      }
      if (internalAddressConfig_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(InternalAddressConfig);
      }
      if (delayedCloseTimeout_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(DelayedCloseTimeout);
      }
      if (requestTimeout_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(RequestTimeout);
      }
      if (maxRequestHeadersKb_ != null) {
        _single_maxRequestHeadersKb_codec.WriteTagAndValue(output, MaxRequestHeadersKb);
      }
      if (normalizePath_ != null) {
        _single_normalizePath_codec.WriteTagAndValue(output, NormalizePath);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(ScopedRoutes);
      }
      if (PreserveExternalRequestId != false) {
        output.WriteRawTag(128, 2);
        output.WriteBool(PreserveExternalRequestId);
      }
      if (MergeSlashes != false) {
        output.WriteRawTag(136, 2);
        output.WriteBool(MergeSlashes);
      }
      if (ServerHeaderTransformation != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) {
        output.WriteRawTag(144, 2);
        output.WriteEnum((int) ServerHeaderTransformation);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CodecType != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CodecType);
      }
      if (StatPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rds);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RouteConfig);
      }
      if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ScopedRoutes);
      }
      size += httpFilters_.CalculateSize(_repeated_httpFilters_codec);
      if (addUserAgent_ != null) {
        size += _single_addUserAgent_codec.CalculateSizeWithTag(AddUserAgent);
      }
      if (tracing_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tracing);
      }
      if (httpProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      if (ServerName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServerName);
      }
      if (ServerHeaderTransformation != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ServerHeaderTransformation);
      }
      if (maxRequestHeadersKb_ != null) {
        size += _single_maxRequestHeadersKb_codec.CalculateSizeWithTag(MaxRequestHeadersKb);
      }
      if (idleTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IdleTimeout);
      }
      if (streamIdleTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StreamIdleTimeout);
      }
      if (requestTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RequestTimeout);
      }
      if (drainTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DrainTimeout);
      }
      if (delayedCloseTimeout_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DelayedCloseTimeout);
      }
      size += accessLog_.CalculateSize(_repeated_accessLog_codec);
      if (useRemoteAddress_ != null) {
        size += _single_useRemoteAddress_codec.CalculateSizeWithTag(UseRemoteAddress);
      }
      if (XffNumTrustedHops != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(XffNumTrustedHops);
      }
      if (internalAddressConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(InternalAddressConfig);
      }
      if (SkipXffAppend != false) {
        size += 2 + 1;
      }
      if (Via.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Via);
      }
      if (generateRequestId_ != null) {
        size += _single_generateRequestId_codec.CalculateSizeWithTag(GenerateRequestId);
      }
      if (PreserveExternalRequestId != false) {
        size += 2 + 1;
      }
      if (ForwardClientCertDetails != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ForwardClientCertDetails);
      }
      if (setCurrentClientCertDetails_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SetCurrentClientCertDetails);
      }
      if (Proxy100Continue != false) {
        size += 2 + 1;
      }
      if (RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        size += 2 + 1;
      }
      size += upgradeConfigs_.CalculateSize(_repeated_upgradeConfigs_codec);
      if (normalizePath_ != null) {
        size += _single_normalizePath_codec.CalculateSizeWithTag(NormalizePath);
      }
      if (MergeSlashes != false) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HttpConnectionManager other) {
      if (other == null) {
        return;
      }
      if (other.CodecType != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType.Auto) {
        CodecType = other.CodecType;
      }
      if (other.StatPrefix.Length != 0) {
        StatPrefix = other.StatPrefix;
      }
      httpFilters_.Add(other.httpFilters_);
      if (other.addUserAgent_ != null) {
        if (addUserAgent_ == null || other.AddUserAgent != false) {
          AddUserAgent = other.AddUserAgent;
        }
      }
      if (other.tracing_ != null) {
        if (tracing_ == null) {
          Tracing = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing();
        }
        Tracing.MergeFrom(other.Tracing);
      }
      if (other.httpProtocolOptions_ != null) {
        if (httpProtocolOptions_ == null) {
          HttpProtocolOptions = new global::Envoy.Api.V3Alpha.Core.Http1ProtocolOptions();
        }
        HttpProtocolOptions.MergeFrom(other.HttpProtocolOptions);
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          Http2ProtocolOptions = new global::Envoy.Api.V3Alpha.Core.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      if (other.ServerName.Length != 0) {
        ServerName = other.ServerName;
      }
      if (other.ServerHeaderTransformation != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation.Overwrite) {
        ServerHeaderTransformation = other.ServerHeaderTransformation;
      }
      if (other.maxRequestHeadersKb_ != null) {
        if (maxRequestHeadersKb_ == null || other.MaxRequestHeadersKb != 0) {
          MaxRequestHeadersKb = other.MaxRequestHeadersKb;
        }
      }
      if (other.idleTimeout_ != null) {
        if (idleTimeout_ == null) {
          IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        IdleTimeout.MergeFrom(other.IdleTimeout);
      }
      if (other.streamIdleTimeout_ != null) {
        if (streamIdleTimeout_ == null) {
          StreamIdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        StreamIdleTimeout.MergeFrom(other.StreamIdleTimeout);
      }
      if (other.requestTimeout_ != null) {
        if (requestTimeout_ == null) {
          RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        RequestTimeout.MergeFrom(other.RequestTimeout);
      }
      if (other.drainTimeout_ != null) {
        if (drainTimeout_ == null) {
          DrainTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DrainTimeout.MergeFrom(other.DrainTimeout);
      }
      if (other.delayedCloseTimeout_ != null) {
        if (delayedCloseTimeout_ == null) {
          DelayedCloseTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DelayedCloseTimeout.MergeFrom(other.DelayedCloseTimeout);
      }
      accessLog_.Add(other.accessLog_);
      if (other.useRemoteAddress_ != null) {
        if (useRemoteAddress_ == null || other.UseRemoteAddress != false) {
          UseRemoteAddress = other.UseRemoteAddress;
        }
      }
      if (other.XffNumTrustedHops != 0) {
        XffNumTrustedHops = other.XffNumTrustedHops;
      }
      if (other.internalAddressConfig_ != null) {
        if (internalAddressConfig_ == null) {
          InternalAddressConfig = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.InternalAddressConfig();
        }
        InternalAddressConfig.MergeFrom(other.InternalAddressConfig);
      }
      if (other.SkipXffAppend != false) {
        SkipXffAppend = other.SkipXffAppend;
      }
      if (other.Via.Length != 0) {
        Via = other.Via;
      }
      if (other.generateRequestId_ != null) {
        if (generateRequestId_ == null || other.GenerateRequestId != false) {
          GenerateRequestId = other.GenerateRequestId;
        }
      }
      if (other.PreserveExternalRequestId != false) {
        PreserveExternalRequestId = other.PreserveExternalRequestId;
      }
      if (other.ForwardClientCertDetails != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails.Sanitize) {
        ForwardClientCertDetails = other.ForwardClientCertDetails;
      }
      if (other.setCurrentClientCertDetails_ != null) {
        if (setCurrentClientCertDetails_ == null) {
          SetCurrentClientCertDetails = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.SetCurrentClientCertDetails();
        }
        SetCurrentClientCertDetails.MergeFrom(other.SetCurrentClientCertDetails);
      }
      if (other.Proxy100Continue != false) {
        Proxy100Continue = other.Proxy100Continue;
      }
      if (other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6 != false) {
        RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = other.RepresentIpv4RemoteAddressAsIpv4MappedIpv6;
      }
      upgradeConfigs_.Add(other.upgradeConfigs_);
      if (other.normalizePath_ != null) {
        if (normalizePath_ == null || other.NormalizePath != false) {
          NormalizePath = other.NormalizePath;
        }
      }
      if (other.MergeSlashes != false) {
        MergeSlashes = other.MergeSlashes;
      }
      switch (other.RouteSpecifierCase) {
        case RouteSpecifierOneofCase.Rds:
          if (Rds == null) {
            Rds = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.Rds();
          }
          Rds.MergeFrom(other.Rds);
          break;
        case RouteSpecifierOneofCase.RouteConfig:
          if (RouteConfig == null) {
            RouteConfig = new global::Envoy.Api.V3Alpha.RouteConfiguration();
          }
          RouteConfig.MergeFrom(other.RouteConfig);
          break;
        case RouteSpecifierOneofCase.ScopedRoutes:
          if (ScopedRoutes == null) {
            ScopedRoutes = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes();
          }
          ScopedRoutes.MergeFrom(other.ScopedRoutes);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CodecType = (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.CodecType) input.ReadEnum();
            break;
          }
          case 18: {
            StatPrefix = input.ReadString();
            break;
          }
          case 26: {
            global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.Rds subBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.Rds();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.Rds) {
              subBuilder.MergeFrom(Rds);
            }
            input.ReadMessage(subBuilder);
            Rds = subBuilder;
            break;
          }
          case 34: {
            global::Envoy.Api.V3Alpha.RouteConfiguration subBuilder = new global::Envoy.Api.V3Alpha.RouteConfiguration();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.RouteConfig) {
              subBuilder.MergeFrom(RouteConfig);
            }
            input.ReadMessage(subBuilder);
            RouteConfig = subBuilder;
            break;
          }
          case 42: {
            httpFilters_.AddEntriesFrom(input, _repeated_httpFilters_codec);
            break;
          }
          case 50: {
            bool? value = _single_addUserAgent_codec.Read(input);
            if (addUserAgent_ == null || value != false) {
              AddUserAgent = value;
            }
            break;
          }
          case 58: {
            if (tracing_ == null) {
              Tracing = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing();
            }
            input.ReadMessage(Tracing);
            break;
          }
          case 66: {
            if (httpProtocolOptions_ == null) {
              HttpProtocolOptions = new global::Envoy.Api.V3Alpha.Core.Http1ProtocolOptions();
            }
            input.ReadMessage(HttpProtocolOptions);
            break;
          }
          case 74: {
            if (http2ProtocolOptions_ == null) {
              Http2ProtocolOptions = new global::Envoy.Api.V3Alpha.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(Http2ProtocolOptions);
            break;
          }
          case 82: {
            ServerName = input.ReadString();
            break;
          }
          case 90: {
            if (idleTimeout_ == null) {
              IdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(IdleTimeout);
            break;
          }
          case 98: {
            if (drainTimeout_ == null) {
              DrainTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DrainTimeout);
            break;
          }
          case 106: {
            accessLog_.AddEntriesFrom(input, _repeated_accessLog_codec);
            break;
          }
          case 114: {
            bool? value = _single_useRemoteAddress_codec.Read(input);
            if (useRemoteAddress_ == null || value != false) {
              UseRemoteAddress = value;
            }
            break;
          }
          case 122: {
            bool? value = _single_generateRequestId_codec.Read(input);
            if (generateRequestId_ == null || value != false) {
              GenerateRequestId = value;
            }
            break;
          }
          case 128: {
            ForwardClientCertDetails = (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ForwardClientCertDetails) input.ReadEnum();
            break;
          }
          case 138: {
            if (setCurrentClientCertDetails_ == null) {
              SetCurrentClientCertDetails = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.SetCurrentClientCertDetails();
            }
            input.ReadMessage(SetCurrentClientCertDetails);
            break;
          }
          case 144: {
            Proxy100Continue = input.ReadBool();
            break;
          }
          case 152: {
            XffNumTrustedHops = input.ReadUInt32();
            break;
          }
          case 160: {
            RepresentIpv4RemoteAddressAsIpv4MappedIpv6 = input.ReadBool();
            break;
          }
          case 168: {
            SkipXffAppend = input.ReadBool();
            break;
          }
          case 178: {
            Via = input.ReadString();
            break;
          }
          case 186: {
            upgradeConfigs_.AddEntriesFrom(input, _repeated_upgradeConfigs_codec);
            break;
          }
          case 194: {
            if (streamIdleTimeout_ == null) {
              StreamIdleTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(StreamIdleTimeout);
            break;
          }
          case 202: {
            if (internalAddressConfig_ == null) {
              InternalAddressConfig = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.InternalAddressConfig();
            }
            input.ReadMessage(InternalAddressConfig);
            break;
          }
          case 210: {
            if (delayedCloseTimeout_ == null) {
              DelayedCloseTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(DelayedCloseTimeout);
            break;
          }
          case 226: {
            if (requestTimeout_ == null) {
              RequestTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(RequestTimeout);
            break;
          }
          case 234: {
            uint? value = _single_maxRequestHeadersKb_codec.Read(input);
            if (maxRequestHeadersKb_ == null || value != 0) {
              MaxRequestHeadersKb = value;
            }
            break;
          }
          case 242: {
            bool? value = _single_normalizePath_codec.Read(input);
            if (normalizePath_ == null || value != false) {
              NormalizePath = value;
            }
            break;
          }
          case 250: {
            global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes subBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes();
            if (routeSpecifierCase_ == RouteSpecifierOneofCase.ScopedRoutes) {
              subBuilder.MergeFrom(ScopedRoutes);
            }
            input.ReadMessage(subBuilder);
            ScopedRoutes = subBuilder;
            break;
          }
          case 256: {
            PreserveExternalRequestId = input.ReadBool();
            break;
          }
          case 264: {
            MergeSlashes = input.ReadBool();
            break;
          }
          case 272: {
            ServerHeaderTransformation = (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.ServerHeaderTransformation) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the HttpConnectionManager message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum CodecType {
        /// <summary>
        /// For every new connection, the connection manager will determine which
        /// codec to use. This mode supports both ALPN for TLS listeners as well as
        /// protocol inference for plaintext listeners. If ALPN data is available, it
        /// is preferred, otherwise protocol inference is used. In almost all cases,
        /// this is the right option to choose for this setting.
        /// </summary>
        [pbr::OriginalName("AUTO")] Auto = 0,
        /// <summary>
        /// The connection manager will assume that the client is speaking HTTP/1.1.
        /// </summary>
        [pbr::OriginalName("HTTP1")] Http1 = 1,
        /// <summary>
        /// The connection manager will assume that the client is speaking HTTP/2
        /// (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
        /// Prior knowledge is allowed).
        /// </summary>
        [pbr::OriginalName("HTTP2")] Http2 = 2,
      }

      public enum ServerHeaderTransformation {
        /// <summary>
        /// Overwrite any Server header with the contents of server_name.
        /// </summary>
        [pbr::OriginalName("OVERWRITE")] Overwrite = 0,
        /// <summary>
        /// If no Server header is present, append Server server_name
        /// If a Server header is present, pass it through.
        /// </summary>
        [pbr::OriginalName("APPEND_IF_ABSENT")] AppendIfAbsent = 1,
        /// <summary>
        /// Pass through the value of the server header, and do not append a header
        /// if none is present.
        /// </summary>
        [pbr::OriginalName("PASS_THROUGH")] PassThrough = 2,
      }

      /// <summary>
      /// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
      /// header.
      /// </summary>
      public enum ForwardClientCertDetails {
        /// <summary>
        /// Do not send the XFCC header to the next hop. This is the default value.
        /// </summary>
        [pbr::OriginalName("SANITIZE")] Sanitize = 0,
        /// <summary>
        /// When the client connection is mTLS (Mutual TLS), forward the XFCC header
        /// in the request.
        /// </summary>
        [pbr::OriginalName("FORWARD_ONLY")] ForwardOnly = 1,
        /// <summary>
        /// When the client connection is mTLS, append the client certificate
        /// information to the request’s XFCC header and forward it.
        /// </summary>
        [pbr::OriginalName("APPEND_FORWARD")] AppendForward = 2,
        /// <summary>
        /// When the client connection is mTLS, reset the XFCC header with the client
        /// certificate information and send it to the next hop.
        /// </summary>
        [pbr::OriginalName("SANITIZE_SET")] SanitizeSet = 3,
        /// <summary>
        /// Always forward the XFCC header in the request, regardless of whether the
        /// client connection is mTLS.
        /// </summary>
        [pbr::OriginalName("ALWAYS_FORWARD_ONLY")] AlwaysForwardOnly = 4,
      }

      public sealed partial class Tracing : pb::IMessage<Tracing> {
        private static readonly pb::MessageParser<Tracing> _parser = new pb::MessageParser<Tracing>(() => new Tracing());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Tracing> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tracing() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tracing(Tracing other) : this() {
          operationName_ = other.operationName_;
          requestHeadersForTags_ = other.requestHeadersForTags_.Clone();
          clientSampling_ = other.clientSampling_ != null ? other.clientSampling_.Clone() : null;
          randomSampling_ = other.randomSampling_ != null ? other.randomSampling_.Clone() : null;
          overallSampling_ = other.overallSampling_ != null ? other.overallSampling_.Clone() : null;
          verbose_ = other.verbose_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Tracing Clone() {
          return new Tracing(this);
        }

        /// <summary>Field number for the "operation_name" field.</summary>
        public const int OperationNameFieldNumber = 1;
        private global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName operationName_ = global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName.Ingress;
        /// <summary>
        /// The span name will be derived from this field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName OperationName {
          get { return operationName_; }
          set {
            operationName_ = value;
          }
        }

        /// <summary>Field number for the "request_headers_for_tags" field.</summary>
        public const int RequestHeadersForTagsFieldNumber = 2;
        private static readonly pb::FieldCodec<string> _repeated_requestHeadersForTags_codec
            = pb::FieldCodec.ForString(18);
        private readonly pbc::RepeatedField<string> requestHeadersForTags_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// A list of header names used to create tags for the active span. The header name is used to
        /// populate the tag name, and the header value is used to populate the tag value. The tag is
        /// created if the specified header name is present in the request's headers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> RequestHeadersForTags {
          get { return requestHeadersForTags_; }
        }

        /// <summary>Field number for the "client_sampling" field.</summary>
        public const int ClientSamplingFieldNumber = 3;
        private global::Envoy.Type.Percent clientSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be force
        /// traced if the :ref:`x-client-trace-id &lt;config_http_conn_man_headers_x-client-trace-id>`
        /// header is set. This field is a direct analog for the runtime variable
        /// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
        /// &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Type.Percent ClientSampling {
          get { return clientSampling_; }
          set {
            clientSampling_ = value;
          }
        }

        /// <summary>Field number for the "random_sampling" field.</summary>
        public const int RandomSamplingFieldNumber = 4;
        private global::Envoy.Type.Percent randomSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be randomly
        /// selected for trace generation, if not requested by the client or not forced. This field is
        /// a direct analog for the runtime variable 'tracing.random_sampling' in the
        /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Type.Percent RandomSampling {
          get { return randomSampling_; }
          set {
            randomSampling_ = value;
          }
        }

        /// <summary>Field number for the "overall_sampling" field.</summary>
        public const int OverallSamplingFieldNumber = 5;
        private global::Envoy.Type.Percent overallSampling_;
        /// <summary>
        /// Target percentage of requests managed by this HTTP connection manager that will be traced
        /// after all other sampling checks have been applied (client-directed, force tracing, random
        /// sampling). This field functions as an upper limit on the total configured sampling rate. For
        /// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
        /// of client requests with the appropriate headers to be force traced. This field is a direct
        /// analog for the runtime variable 'tracing.global_enabled' in the
        /// :ref:`HTTP Connection Manager &lt;config_http_conn_man_runtime>`.
        /// Default: 100%
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Type.Percent OverallSampling {
          get { return overallSampling_; }
          set {
            overallSampling_ = value;
          }
        }

        /// <summary>Field number for the "verbose" field.</summary>
        public const int VerboseFieldNumber = 6;
        private bool verbose_;
        /// <summary>
        /// Whether to annotate spans with additional data. If true, spans will include logs for stream
        /// events.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Verbose {
          get { return verbose_; }
          set {
            verbose_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Tracing);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Tracing other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (OperationName != other.OperationName) return false;
          if(!requestHeadersForTags_.Equals(other.requestHeadersForTags_)) return false;
          if (!object.Equals(ClientSampling, other.ClientSampling)) return false;
          if (!object.Equals(RandomSampling, other.RandomSampling)) return false;
          if (!object.Equals(OverallSampling, other.OverallSampling)) return false;
          if (Verbose != other.Verbose) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (OperationName != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName.Ingress) hash ^= OperationName.GetHashCode();
          hash ^= requestHeadersForTags_.GetHashCode();
          if (clientSampling_ != null) hash ^= ClientSampling.GetHashCode();
          if (randomSampling_ != null) hash ^= RandomSampling.GetHashCode();
          if (overallSampling_ != null) hash ^= OverallSampling.GetHashCode();
          if (Verbose != false) hash ^= Verbose.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (OperationName != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName.Ingress) {
            output.WriteRawTag(8);
            output.WriteEnum((int) OperationName);
          }
          requestHeadersForTags_.WriteTo(output, _repeated_requestHeadersForTags_codec);
          if (clientSampling_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(ClientSampling);
          }
          if (randomSampling_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(RandomSampling);
          }
          if (overallSampling_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(OverallSampling);
          }
          if (Verbose != false) {
            output.WriteRawTag(48);
            output.WriteBool(Verbose);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (OperationName != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName.Ingress) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OperationName);
          }
          size += requestHeadersForTags_.CalculateSize(_repeated_requestHeadersForTags_codec);
          if (clientSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientSampling);
          }
          if (randomSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomSampling);
          }
          if (overallSampling_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OverallSampling);
          }
          if (Verbose != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Tracing other) {
          if (other == null) {
            return;
          }
          if (other.OperationName != global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName.Ingress) {
            OperationName = other.OperationName;
          }
          requestHeadersForTags_.Add(other.requestHeadersForTags_);
          if (other.clientSampling_ != null) {
            if (clientSampling_ == null) {
              ClientSampling = new global::Envoy.Type.Percent();
            }
            ClientSampling.MergeFrom(other.ClientSampling);
          }
          if (other.randomSampling_ != null) {
            if (randomSampling_ == null) {
              RandomSampling = new global::Envoy.Type.Percent();
            }
            RandomSampling.MergeFrom(other.RandomSampling);
          }
          if (other.overallSampling_ != null) {
            if (overallSampling_ == null) {
              OverallSampling = new global::Envoy.Type.Percent();
            }
            OverallSampling.MergeFrom(other.OverallSampling);
          }
          if (other.Verbose != false) {
            Verbose = other.Verbose;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                OperationName = (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Types.Tracing.Types.OperationName) input.ReadEnum();
                break;
              }
              case 18: {
                requestHeadersForTags_.AddEntriesFrom(input, _repeated_requestHeadersForTags_codec);
                break;
              }
              case 26: {
                if (clientSampling_ == null) {
                  ClientSampling = new global::Envoy.Type.Percent();
                }
                input.ReadMessage(ClientSampling);
                break;
              }
              case 34: {
                if (randomSampling_ == null) {
                  RandomSampling = new global::Envoy.Type.Percent();
                }
                input.ReadMessage(RandomSampling);
                break;
              }
              case 42: {
                if (overallSampling_ == null) {
                  OverallSampling = new global::Envoy.Type.Percent();
                }
                input.ReadMessage(OverallSampling);
                break;
              }
              case 48: {
                Verbose = input.ReadBool();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Tracing message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// [#comment:TODO(kyessenov): Align this field with listener traffic direction field.]
          /// </summary>
          public enum OperationName {
            /// <summary>
            /// The HTTP listener is used for ingress/incoming requests.
            /// </summary>
            [pbr::OriginalName("INGRESS")] Ingress = 0,
            /// <summary>
            /// The HTTP listener is used for egress/outgoing requests.
            /// </summary>
            [pbr::OriginalName("EGRESS")] Egress = 1,
          }

        }
        #endregion

      }

      public sealed partial class InternalAddressConfig : pb::IMessage<InternalAddressConfig> {
        private static readonly pb::MessageParser<InternalAddressConfig> _parser = new pb::MessageParser<InternalAddressConfig>(() => new InternalAddressConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<InternalAddressConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public InternalAddressConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public InternalAddressConfig(InternalAddressConfig other) : this() {
          unixSockets_ = other.unixSockets_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public InternalAddressConfig Clone() {
          return new InternalAddressConfig(this);
        }

        /// <summary>Field number for the "unix_sockets" field.</summary>
        public const int UnixSocketsFieldNumber = 1;
        private bool unixSockets_;
        /// <summary>
        /// Whether unix socket addresses should be considered internal.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool UnixSockets {
          get { return unixSockets_; }
          set {
            unixSockets_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as InternalAddressConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(InternalAddressConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UnixSockets != other.UnixSockets) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (UnixSockets != false) hash ^= UnixSockets.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (UnixSockets != false) {
            output.WriteRawTag(8);
            output.WriteBool(UnixSockets);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (UnixSockets != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(InternalAddressConfig other) {
          if (other == null) {
            return;
          }
          if (other.UnixSockets != false) {
            UnixSockets = other.UnixSockets;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                UnixSockets = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// [#comment:next free field: 7]
      /// </summary>
      public sealed partial class SetCurrentClientCertDetails : pb::IMessage<SetCurrentClientCertDetails> {
        private static readonly pb::MessageParser<SetCurrentClientCertDetails> _parser = new pb::MessageParser<SetCurrentClientCertDetails>(() => new SetCurrentClientCertDetails());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SetCurrentClientCertDetails> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCurrentClientCertDetails() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCurrentClientCertDetails(SetCurrentClientCertDetails other) : this() {
          Subject = other.Subject;
          cert_ = other.cert_;
          chain_ = other.chain_;
          dns_ = other.dns_;
          uri_ = other.uri_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SetCurrentClientCertDetails Clone() {
          return new SetCurrentClientCertDetails(this);
        }

        /// <summary>Field number for the "subject" field.</summary>
        public const int SubjectFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_subject_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? subject_;
        /// <summary>
        /// Whether to forward the subject of the client cert. Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? Subject {
          get { return subject_; }
          set {
            subject_ = value;
          }
        }


        /// <summary>Field number for the "cert" field.</summary>
        public const int CertFieldNumber = 3;
        private bool cert_;
        /// <summary>
        /// Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
        /// XFCC header comma separated from other values with the value Cert="PEM".
        /// Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Cert {
          get { return cert_; }
          set {
            cert_ = value;
          }
        }

        /// <summary>Field number for the "chain" field.</summary>
        public const int ChainFieldNumber = 6;
        private bool chain_;
        /// <summary>
        /// Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
        /// format. This will appear in the XFCC header comma separated from other values with the value
        /// Chain="PEM".
        /// Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Chain {
          get { return chain_; }
          set {
            chain_ = value;
          }
        }

        /// <summary>Field number for the "dns" field.</summary>
        public const int DnsFieldNumber = 4;
        private bool dns_;
        /// <summary>
        /// Whether to forward the DNS type Subject Alternative Names of the client cert.
        /// Defaults to false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Dns {
          get { return dns_; }
          set {
            dns_ = value;
          }
        }

        /// <summary>Field number for the "uri" field.</summary>
        public const int UriFieldNumber = 5;
        private bool uri_;
        /// <summary>
        /// Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
        /// false.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Uri {
          get { return uri_; }
          set {
            uri_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SetCurrentClientCertDetails);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SetCurrentClientCertDetails other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Subject != other.Subject) return false;
          if (Cert != other.Cert) return false;
          if (Chain != other.Chain) return false;
          if (Dns != other.Dns) return false;
          if (Uri != other.Uri) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (subject_ != null) hash ^= Subject.GetHashCode();
          if (Cert != false) hash ^= Cert.GetHashCode();
          if (Chain != false) hash ^= Chain.GetHashCode();
          if (Dns != false) hash ^= Dns.GetHashCode();
          if (Uri != false) hash ^= Uri.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (subject_ != null) {
            _single_subject_codec.WriteTagAndValue(output, Subject);
          }
          if (Cert != false) {
            output.WriteRawTag(24);
            output.WriteBool(Cert);
          }
          if (Dns != false) {
            output.WriteRawTag(32);
            output.WriteBool(Dns);
          }
          if (Uri != false) {
            output.WriteRawTag(40);
            output.WriteBool(Uri);
          }
          if (Chain != false) {
            output.WriteRawTag(48);
            output.WriteBool(Chain);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (subject_ != null) {
            size += _single_subject_codec.CalculateSizeWithTag(Subject);
          }
          if (Cert != false) {
            size += 1 + 1;
          }
          if (Chain != false) {
            size += 1 + 1;
          }
          if (Dns != false) {
            size += 1 + 1;
          }
          if (Uri != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SetCurrentClientCertDetails other) {
          if (other == null) {
            return;
          }
          if (other.subject_ != null) {
            if (subject_ == null || other.Subject != false) {
              Subject = other.Subject;
            }
          }
          if (other.Cert != false) {
            Cert = other.Cert;
          }
          if (other.Chain != false) {
            Chain = other.Chain;
          }
          if (other.Dns != false) {
            Dns = other.Dns;
          }
          if (other.Uri != false) {
            Uri = other.Uri;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                bool? value = _single_subject_codec.Read(input);
                if (subject_ == null || value != false) {
                  Subject = value;
                }
                break;
              }
              case 24: {
                Cert = input.ReadBool();
                break;
              }
              case 32: {
                Dns = input.ReadBool();
                break;
              }
              case 40: {
                Uri = input.ReadBool();
                break;
              }
              case 48: {
                Chain = input.ReadBool();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// The configuration for HTTP upgrades.
      /// For each upgrade type desired, an UpgradeConfig must be added.
      ///
      /// .. warning::
      ///
      ///    The current implementation of upgrade headers does not handle
      ///    multi-valued upgrade headers. Support for multi-valued headers may be
      ///    added in the future if needed.
      ///
      /// .. warning::
      ///    The current implementation of upgrade headers does not work with HTTP/2
      ///    upstreams.
      /// </summary>
      public sealed partial class UpgradeConfig : pb::IMessage<UpgradeConfig> {
        private static readonly pb::MessageParser<UpgradeConfig> _parser = new pb::MessageParser<UpgradeConfig>(() => new UpgradeConfig());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<UpgradeConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManager.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public UpgradeConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public UpgradeConfig(UpgradeConfig other) : this() {
          upgradeType_ = other.upgradeType_;
          filters_ = other.filters_.Clone();
          Enabled = other.Enabled;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public UpgradeConfig Clone() {
          return new UpgradeConfig(this);
        }

        /// <summary>Field number for the "upgrade_type" field.</summary>
        public const int UpgradeTypeFieldNumber = 1;
        private string upgradeType_ = "";
        /// <summary>
        /// The case-insensitive name of this upgrade, e.g. "websocket".
        /// For each upgrade type present in upgrade_configs, requests with
        /// Upgrade: [upgrade_type]
        /// will be proxied upstream.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string UpgradeType {
          get { return upgradeType_; }
          set {
            upgradeType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "filters" field.</summary>
        public const int FiltersFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter> _repeated_filters_codec
            = pb::FieldCodec.ForMessage(18, global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter> filters_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter>();
        /// <summary>
        /// If present, this represents the filter chain which will be created for
        /// this type of upgrade. If no filters are present, the filter chain for
        /// HTTP connections will be used for this upgrade type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpFilter> Filters {
          get { return filters_; }
        }

        /// <summary>Field number for the "enabled" field.</summary>
        public const int EnabledFieldNumber = 3;
        private static readonly pb::FieldCodec<bool?> _single_enabled_codec = pb::FieldCodec.ForStructWrapper<bool>(26);
        private bool? enabled_;
        /// <summary>
        /// Determines if upgrades are enabled or disabled by default. Defaults to true.
        /// This can be overridden on a per-route basis with :ref:`cluster
        /// &lt;envoy_api_field_route.RouteAction.upgrade_configs>` as documented in the
        /// :ref:`upgrade documentation &lt;arch_overview_websocket>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? Enabled {
          get { return enabled_; }
          set {
            enabled_ = value;
          }
        }


        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as UpgradeConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(UpgradeConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (UpgradeType != other.UpgradeType) return false;
          if(!filters_.Equals(other.filters_)) return false;
          if (Enabled != other.Enabled) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (UpgradeType.Length != 0) hash ^= UpgradeType.GetHashCode();
          hash ^= filters_.GetHashCode();
          if (enabled_ != null) hash ^= Enabled.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (UpgradeType.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(UpgradeType);
          }
          filters_.WriteTo(output, _repeated_filters_codec);
          if (enabled_ != null) {
            _single_enabled_codec.WriteTagAndValue(output, Enabled);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (UpgradeType.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(UpgradeType);
          }
          size += filters_.CalculateSize(_repeated_filters_codec);
          if (enabled_ != null) {
            size += _single_enabled_codec.CalculateSizeWithTag(Enabled);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(UpgradeConfig other) {
          if (other == null) {
            return;
          }
          if (other.UpgradeType.Length != 0) {
            UpgradeType = other.UpgradeType;
          }
          filters_.Add(other.filters_);
          if (other.enabled_ != null) {
            if (enabled_ == null || other.Enabled != false) {
              Enabled = other.Enabled;
            }
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                UpgradeType = input.ReadString();
                break;
              }
              case 18: {
                filters_.AddEntriesFrom(input, _repeated_filters_codec);
                break;
              }
              case 26: {
                bool? value = _single_enabled_codec.Read(input);
                if (enabled_ == null || value != false) {
                  Enabled = value;
                }
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class Rds : pb::IMessage<Rds> {
    private static readonly pb::MessageParser<Rds> _parser = new pb::MessageParser<Rds>(() => new Rds());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Rds> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManagerReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Rds() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Rds(Rds other) : this() {
      configSource_ = other.configSource_ != null ? other.configSource_.Clone() : null;
      routeConfigName_ = other.routeConfigName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Rds Clone() {
      return new Rds(this);
    }

    /// <summary>Field number for the "config_source" field.</summary>
    public const int ConfigSourceFieldNumber = 1;
    private global::Envoy.Api.V3Alpha.Core.ConfigSource configSource_;
    /// <summary>
    /// Configuration source specifier for RDS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.ConfigSource ConfigSource {
      get { return configSource_; }
      set {
        configSource_ = value;
      }
    }

    /// <summary>Field number for the "route_config_name" field.</summary>
    public const int RouteConfigNameFieldNumber = 2;
    private string routeConfigName_ = "";
    /// <summary>
    /// The name of the route configuration. This name will be passed to the RDS
    /// API. This allows an Envoy configuration with multiple HTTP listeners (and
    /// associated HTTP connection manager filters) to use different route
    /// configurations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string RouteConfigName {
      get { return routeConfigName_; }
      set {
        routeConfigName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Rds);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Rds other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConfigSource, other.ConfigSource)) return false;
      if (RouteConfigName != other.RouteConfigName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (configSource_ != null) hash ^= ConfigSource.GetHashCode();
      if (RouteConfigName.Length != 0) hash ^= RouteConfigName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (configSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConfigSource);
      }
      if (RouteConfigName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(RouteConfigName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (configSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigSource);
      }
      if (RouteConfigName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RouteConfigName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Rds other) {
      if (other == null) {
        return;
      }
      if (other.configSource_ != null) {
        if (configSource_ == null) {
          ConfigSource = new global::Envoy.Api.V3Alpha.Core.ConfigSource();
        }
        ConfigSource.MergeFrom(other.ConfigSource);
      }
      if (other.RouteConfigName.Length != 0) {
        RouteConfigName = other.RouteConfigName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (configSource_ == null) {
              ConfigSource = new global::Envoy.Api.V3Alpha.Core.ConfigSource();
            }
            input.ReadMessage(ConfigSource);
            break;
          }
          case 18: {
            RouteConfigName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// This message is used to work around the limitations with 'oneof' and repeated fields.
  /// </summary>
  public sealed partial class ScopedRouteConfigurationsList : pb::IMessage<ScopedRouteConfigurationsList> {
    private static readonly pb::MessageParser<ScopedRouteConfigurationsList> _parser = new pb::MessageParser<ScopedRouteConfigurationsList>(() => new ScopedRouteConfigurationsList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScopedRouteConfigurationsList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManagerReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRouteConfigurationsList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRouteConfigurationsList(ScopedRouteConfigurationsList other) : this() {
      scopedRouteConfigurations_ = other.scopedRouteConfigurations_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRouteConfigurationsList Clone() {
      return new ScopedRouteConfigurationsList(this);
    }

    /// <summary>Field number for the "scoped_route_configurations" field.</summary>
    public const int ScopedRouteConfigurationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Envoy.Api.V3Alpha.ScopedRouteConfiguration> _repeated_scopedRouteConfigurations_codec
        = pb::FieldCodec.ForMessage(10, global::Envoy.Api.V3Alpha.ScopedRouteConfiguration.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V3Alpha.ScopedRouteConfiguration> scopedRouteConfigurations_ = new pbc::RepeatedField<global::Envoy.Api.V3Alpha.ScopedRouteConfiguration>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V3Alpha.ScopedRouteConfiguration> ScopedRouteConfigurations {
      get { return scopedRouteConfigurations_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScopedRouteConfigurationsList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScopedRouteConfigurationsList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!scopedRouteConfigurations_.Equals(other.scopedRouteConfigurations_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= scopedRouteConfigurations_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      scopedRouteConfigurations_.WriteTo(output, _repeated_scopedRouteConfigurations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += scopedRouteConfigurations_.CalculateSize(_repeated_scopedRouteConfigurations_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScopedRouteConfigurationsList other) {
      if (other == null) {
        return;
      }
      scopedRouteConfigurations_.Add(other.scopedRouteConfigurations_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            scopedRouteConfigurations_.AddEntriesFrom(input, _repeated_scopedRouteConfigurations_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ScopedRoutes : pb::IMessage<ScopedRoutes> {
    private static readonly pb::MessageParser<ScopedRoutes> _parser = new pb::MessageParser<ScopedRoutes>(() => new ScopedRoutes());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScopedRoutes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManagerReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRoutes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRoutes(ScopedRoutes other) : this() {
      name_ = other.name_;
      scopeKeyBuilder_ = other.scopeKeyBuilder_ != null ? other.scopeKeyBuilder_.Clone() : null;
      rdsConfigSource_ = other.rdsConfigSource_ != null ? other.rdsConfigSource_.Clone() : null;
      switch (other.ConfigSpecifierCase) {
        case ConfigSpecifierOneofCase.ScopedRouteConfigurationsList:
          ScopedRouteConfigurationsList = other.ScopedRouteConfigurationsList.Clone();
          break;
        case ConfigSpecifierOneofCase.ScopedRds:
          ScopedRds = other.ScopedRds.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRoutes Clone() {
      return new ScopedRoutes(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name assigned to the scoped routing configuration.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "scope_key_builder" field.</summary>
    public const int ScopeKeyBuilderFieldNumber = 2;
    private global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder scopeKeyBuilder_;
    /// <summary>
    /// The algorithm to use for constructing a scope key for each request.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder ScopeKeyBuilder {
      get { return scopeKeyBuilder_; }
      set {
        scopeKeyBuilder_ = value;
      }
    }

    /// <summary>Field number for the "rds_config_source" field.</summary>
    public const int RdsConfigSourceFieldNumber = 3;
    private global::Envoy.Api.V3Alpha.Core.ConfigSource rdsConfigSource_;
    /// <summary>
    /// Configuration source specifier for RDS.
    /// This config source is used to subscribe to RouteConfiguration resources specified in
    /// ScopedRouteConfiguration messages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.ConfigSource RdsConfigSource {
      get { return rdsConfigSource_; }
      set {
        rdsConfigSource_ = value;
      }
    }

    /// <summary>Field number for the "scoped_route_configurations_list" field.</summary>
    public const int ScopedRouteConfigurationsListFieldNumber = 4;
    /// <summary>
    /// The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
    /// matching a key constructed from the request's attributes according to the algorithm specified
    /// by the
    /// :ref:`ScopeKeyBuilder&lt;envoy_api_msg_config.filter.network.http_connection_manager.v3alpha.ScopedRoutes.ScopeKeyBuilder>`
    /// in this message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRouteConfigurationsList ScopedRouteConfigurationsList {
      get { return configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList ? (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRouteConfigurationsList) configSpecifier_ : null; }
      set {
        configSpecifier_ = value;
        configSpecifierCase_ = value == null ? ConfigSpecifierOneofCase.None : ConfigSpecifierOneofCase.ScopedRouteConfigurationsList;
      }
    }

    /// <summary>Field number for the "scoped_rds" field.</summary>
    public const int ScopedRdsFieldNumber = 5;
    /// <summary>
    /// The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
    /// API. A scope is assigned to a request by matching a key constructed from the request's
    /// attributes according to the algorithm specified by the
    /// :ref:`ScopeKeyBuilder&lt;envoy_api_msg_config.filter.network.http_connection_manager.v3alpha.ScopedRoutes.ScopeKeyBuilder>`
    /// in this message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRds ScopedRds {
      get { return configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds ? (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRds) configSpecifier_ : null; }
      set {
        configSpecifier_ = value;
        configSpecifierCase_ = value == null ? ConfigSpecifierOneofCase.None : ConfigSpecifierOneofCase.ScopedRds;
      }
    }

    private object configSpecifier_;
    /// <summary>Enum of possible cases for the "config_specifier" oneof.</summary>
    public enum ConfigSpecifierOneofCase {
      None = 0,
      ScopedRouteConfigurationsList = 4,
      ScopedRds = 5,
    }
    private ConfigSpecifierOneofCase configSpecifierCase_ = ConfigSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigSpecifierOneofCase ConfigSpecifierCase {
      get { return configSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConfigSpecifier() {
      configSpecifierCase_ = ConfigSpecifierOneofCase.None;
      configSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScopedRoutes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScopedRoutes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(ScopeKeyBuilder, other.ScopeKeyBuilder)) return false;
      if (!object.Equals(RdsConfigSource, other.RdsConfigSource)) return false;
      if (!object.Equals(ScopedRouteConfigurationsList, other.ScopedRouteConfigurationsList)) return false;
      if (!object.Equals(ScopedRds, other.ScopedRds)) return false;
      if (ConfigSpecifierCase != other.ConfigSpecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (scopeKeyBuilder_ != null) hash ^= ScopeKeyBuilder.GetHashCode();
      if (rdsConfigSource_ != null) hash ^= RdsConfigSource.GetHashCode();
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) hash ^= ScopedRouteConfigurationsList.GetHashCode();
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) hash ^= ScopedRds.GetHashCode();
      hash ^= (int) configSpecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (scopeKeyBuilder_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ScopeKeyBuilder);
      }
      if (rdsConfigSource_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(RdsConfigSource);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) {
        output.WriteRawTag(34);
        output.WriteMessage(ScopedRouteConfigurationsList);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) {
        output.WriteRawTag(42);
        output.WriteMessage(ScopedRds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (scopeKeyBuilder_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopeKeyBuilder);
      }
      if (rdsConfigSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RdsConfigSource);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopedRouteConfigurationsList);
      }
      if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopedRds);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScopedRoutes other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.scopeKeyBuilder_ != null) {
        if (scopeKeyBuilder_ == null) {
          ScopeKeyBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder();
        }
        ScopeKeyBuilder.MergeFrom(other.ScopeKeyBuilder);
      }
      if (other.rdsConfigSource_ != null) {
        if (rdsConfigSource_ == null) {
          RdsConfigSource = new global::Envoy.Api.V3Alpha.Core.ConfigSource();
        }
        RdsConfigSource.MergeFrom(other.RdsConfigSource);
      }
      switch (other.ConfigSpecifierCase) {
        case ConfigSpecifierOneofCase.ScopedRouteConfigurationsList:
          if (ScopedRouteConfigurationsList == null) {
            ScopedRouteConfigurationsList = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRouteConfigurationsList();
          }
          ScopedRouteConfigurationsList.MergeFrom(other.ScopedRouteConfigurationsList);
          break;
        case ConfigSpecifierOneofCase.ScopedRds:
          if (ScopedRds == null) {
            ScopedRds = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRds();
          }
          ScopedRds.MergeFrom(other.ScopedRds);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (scopeKeyBuilder_ == null) {
              ScopeKeyBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder();
            }
            input.ReadMessage(ScopeKeyBuilder);
            break;
          }
          case 26: {
            if (rdsConfigSource_ == null) {
              RdsConfigSource = new global::Envoy.Api.V3Alpha.Core.ConfigSource();
            }
            input.ReadMessage(RdsConfigSource);
            break;
          }
          case 34: {
            global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRouteConfigurationsList subBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRouteConfigurationsList();
            if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRouteConfigurationsList) {
              subBuilder.MergeFrom(ScopedRouteConfigurationsList);
            }
            input.ReadMessage(subBuilder);
            ScopedRouteConfigurationsList = subBuilder;
            break;
          }
          case 42: {
            global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRds subBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRds();
            if (configSpecifierCase_ == ConfigSpecifierOneofCase.ScopedRds) {
              subBuilder.MergeFrom(ScopedRds);
            }
            input.ReadMessage(subBuilder);
            ScopedRds = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ScopedRoutes message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
      /// keys are matched against a set of :ref:`Key&lt;envoy_api_msg_ScopedRouteConfiguration.Key>`
      /// objects assembled from :ref:`ScopedRouteConfiguration&lt;envoy_api_msg_ScopedRouteConfiguration>`
      /// messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
      /// :ref:`scoped_route_configurations_list&lt;envoy_api_field_config.filter.network.http_connection_manager.v3alpha.ScopedRoutes.scoped_route_configurations_list>`.
      ///
      /// Upon receiving a request's headers, the Router will build a key using the algorithm specified
      /// by this message. This key will be used to look up the routing table (i.e., the
      /// :ref:`RouteConfiguration&lt;envoy_api_msg_RouteConfiguration>`) to use for the request.
      /// </summary>
      public sealed partial class ScopeKeyBuilder : pb::IMessage<ScopeKeyBuilder> {
        private static readonly pb::MessageParser<ScopeKeyBuilder> _parser = new pb::MessageParser<ScopeKeyBuilder>(() => new ScopeKeyBuilder());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ScopeKeyBuilder> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ScopeKeyBuilder() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ScopeKeyBuilder(ScopeKeyBuilder other) : this() {
          fragments_ = other.fragments_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ScopeKeyBuilder Clone() {
          return new ScopeKeyBuilder(this);
        }

        /// <summary>Field number for the "fragments" field.</summary>
        public const int FragmentsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder> _repeated_fragments_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder> fragments_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder>();
        /// <summary>
        /// The final scope key consists of the ordered union of these fragments.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder> Fragments {
          get { return fragments_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ScopeKeyBuilder);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ScopeKeyBuilder other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!fragments_.Equals(other.fragments_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= fragments_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          fragments_.WriteTo(output, _repeated_fragments_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += fragments_.CalculateSize(_repeated_fragments_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ScopeKeyBuilder other) {
          if (other == null) {
            return;
          }
          fragments_.Add(other.fragments_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                fragments_.AddEntriesFrom(input, _repeated_fragments_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the ScopeKeyBuilder message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Specifies the mechanism for constructing key fragments which are composed into scope keys.
          /// </summary>
          public sealed partial class FragmentBuilder : pb::IMessage<FragmentBuilder> {
            private static readonly pb::MessageParser<FragmentBuilder> _parser = new pb::MessageParser<FragmentBuilder>(() => new FragmentBuilder());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<FragmentBuilder> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public FragmentBuilder() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public FragmentBuilder(FragmentBuilder other) : this() {
              switch (other.TypeCase) {
                case TypeOneofCase.HeaderValueExtractor:
                  HeaderValueExtractor = other.HeaderValueExtractor.Clone();
                  break;
              }

              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public FragmentBuilder Clone() {
              return new FragmentBuilder(this);
            }

            /// <summary>Field number for the "header_value_extractor" field.</summary>
            public const int HeaderValueExtractorFieldNumber = 1;
            /// <summary>
            /// Specifies how a header field's value should be extracted.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor HeaderValueExtractor {
              get { return typeCase_ == TypeOneofCase.HeaderValueExtractor ? (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor) type_ : null; }
              set {
                type_ = value;
                typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.HeaderValueExtractor;
              }
            }

            private object type_;
            /// <summary>Enum of possible cases for the "type" oneof.</summary>
            public enum TypeOneofCase {
              None = 0,
              HeaderValueExtractor = 1,
            }
            private TypeOneofCase typeCase_ = TypeOneofCase.None;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public TypeOneofCase TypeCase {
              get { return typeCase_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void ClearType() {
              typeCase_ = TypeOneofCase.None;
              type_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as FragmentBuilder);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(FragmentBuilder other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(HeaderValueExtractor, other.HeaderValueExtractor)) return false;
              if (TypeCase != other.TypeCase) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (typeCase_ == TypeOneofCase.HeaderValueExtractor) hash ^= HeaderValueExtractor.GetHashCode();
              hash ^= (int) typeCase_;
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (typeCase_ == TypeOneofCase.HeaderValueExtractor) {
                output.WriteRawTag(10);
                output.WriteMessage(HeaderValueExtractor);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (typeCase_ == TypeOneofCase.HeaderValueExtractor) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderValueExtractor);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(FragmentBuilder other) {
              if (other == null) {
                return;
              }
              switch (other.TypeCase) {
                case TypeOneofCase.HeaderValueExtractor:
                  if (HeaderValueExtractor == null) {
                    HeaderValueExtractor = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor();
                  }
                  HeaderValueExtractor.MergeFrom(other.HeaderValueExtractor);
                  break;
              }

              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor subBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor();
                    if (typeCase_ == TypeOneofCase.HeaderValueExtractor) {
                      subBuilder.MergeFrom(HeaderValueExtractor);
                    }
                    input.ReadMessage(subBuilder);
                    HeaderValueExtractor = subBuilder;
                    break;
                  }
                }
              }
            }

            #region Nested types
            /// <summary>Container for nested types declared in the FragmentBuilder message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static partial class Types {
              /// <summary>
              /// Specifies how the value of a header should be extracted.
              /// The following example maps the structure of a header to the fields in this message.
              ///
              /// .. code::
              ///
              ///              &lt;0> &lt;1>   &lt;-- index
              ///    X-Header: a=b;c=d
              ///    |         || |
              ///    |         || \----> &lt;element_separator>
              ///    |         ||
              ///    |         |\----> &lt;element.separator>
              ///    |         |
              ///    |         \----> &lt;element.key>
              ///    |
              ///    \----> &lt;name>
              ///
              ///    Each 'a=b' key-value pair constitutes an 'element' of the header field.
              /// </summary>
              public sealed partial class HeaderValueExtractor : pb::IMessage<HeaderValueExtractor> {
                private static readonly pb::MessageParser<HeaderValueExtractor> _parser = new pb::MessageParser<HeaderValueExtractor>(() => new HeaderValueExtractor());
                private pb::UnknownFieldSet _unknownFields;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pb::MessageParser<HeaderValueExtractor> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pbr::MessageDescriptor Descriptor {
                  get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Descriptor.NestedTypes[0]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                pbr::MessageDescriptor pb::IMessage.Descriptor {
                  get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public HeaderValueExtractor() {
                  OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public HeaderValueExtractor(HeaderValueExtractor other) : this() {
                  name_ = other.name_;
                  elementSeparator_ = other.elementSeparator_;
                  switch (other.ExtractTypeCase) {
                    case ExtractTypeOneofCase.Index:
                      Index = other.Index;
                      break;
                    case ExtractTypeOneofCase.Element:
                      Element = other.Element.Clone();
                      break;
                  }

                  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public HeaderValueExtractor Clone() {
                  return new HeaderValueExtractor(this);
                }

                /// <summary>Field number for the "name" field.</summary>
                public const int NameFieldNumber = 1;
                private string name_ = "";
                /// <summary>
                /// The name of the header field to extract the value from.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public string Name {
                  get { return name_; }
                  set {
                    name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                  }
                }

                /// <summary>Field number for the "element_separator" field.</summary>
                public const int ElementSeparatorFieldNumber = 2;
                private string elementSeparator_ = "";
                /// <summary>
                /// The element separator (e.g., ';' separates 'a;b;c;d').
                /// Default: empty string. This causes the entirety of the header field to be extracted.
                /// If this field is set to an empty string and 'index' is used in the oneof below, 'index'
                /// must be set to 0.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public string ElementSeparator {
                  get { return elementSeparator_; }
                  set {
                    elementSeparator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                  }
                }

                /// <summary>Field number for the "index" field.</summary>
                public const int IndexFieldNumber = 3;
                /// <summary>
                /// Specifies the zero based index of the element to extract.
                /// Note Envoy concatenates multiple values of the same header key into a comma separated
                /// string, the splitting always happens after the concatenation.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public uint Index {
                  get { return extractTypeCase_ == ExtractTypeOneofCase.Index ? (uint) extractType_ : 0; }
                  set {
                    extractType_ = value;
                    extractTypeCase_ = ExtractTypeOneofCase.Index;
                  }
                }

                /// <summary>Field number for the "element" field.</summary>
                public const int ElementFieldNumber = 4;
                /// <summary>
                /// Specifies the key value pair to extract the value from.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement Element {
                  get { return extractTypeCase_ == ExtractTypeOneofCase.Element ? (global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement) extractType_ : null; }
                  set {
                    extractType_ = value;
                    extractTypeCase_ = value == null ? ExtractTypeOneofCase.None : ExtractTypeOneofCase.Element;
                  }
                }

                private object extractType_;
                /// <summary>Enum of possible cases for the "extract_type" oneof.</summary>
                public enum ExtractTypeOneofCase {
                  None = 0,
                  Index = 3,
                  Element = 4,
                }
                private ExtractTypeOneofCase extractTypeCase_ = ExtractTypeOneofCase.None;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public ExtractTypeOneofCase ExtractTypeCase {
                  get { return extractTypeCase_; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void ClearExtractType() {
                  extractTypeCase_ = ExtractTypeOneofCase.None;
                  extractType_ = null;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override bool Equals(object other) {
                  return Equals(other as HeaderValueExtractor);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public bool Equals(HeaderValueExtractor other) {
                  if (ReferenceEquals(other, null)) {
                    return false;
                  }
                  if (ReferenceEquals(other, this)) {
                    return true;
                  }
                  if (Name != other.Name) return false;
                  if (ElementSeparator != other.ElementSeparator) return false;
                  if (Index != other.Index) return false;
                  if (!object.Equals(Element, other.Element)) return false;
                  if (ExtractTypeCase != other.ExtractTypeCase) return false;
                  return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override int GetHashCode() {
                  int hash = 1;
                  if (Name.Length != 0) hash ^= Name.GetHashCode();
                  if (ElementSeparator.Length != 0) hash ^= ElementSeparator.GetHashCode();
                  if (extractTypeCase_ == ExtractTypeOneofCase.Index) hash ^= Index.GetHashCode();
                  if (extractTypeCase_ == ExtractTypeOneofCase.Element) hash ^= Element.GetHashCode();
                  hash ^= (int) extractTypeCase_;
                  if (_unknownFields != null) {
                    hash ^= _unknownFields.GetHashCode();
                  }
                  return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override string ToString() {
                  return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void WriteTo(pb::CodedOutputStream output) {
                  if (Name.Length != 0) {
                    output.WriteRawTag(10);
                    output.WriteString(Name);
                  }
                  if (ElementSeparator.Length != 0) {
                    output.WriteRawTag(18);
                    output.WriteString(ElementSeparator);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Index) {
                    output.WriteRawTag(24);
                    output.WriteUInt32(Index);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Element) {
                    output.WriteRawTag(34);
                    output.WriteMessage(Element);
                  }
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(output);
                  }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public int CalculateSize() {
                  int size = 0;
                  if (Name.Length != 0) {
                    size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
                  }
                  if (ElementSeparator.Length != 0) {
                    size += 1 + pb::CodedOutputStream.ComputeStringSize(ElementSeparator);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Index) {
                    size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Index);
                  }
                  if (extractTypeCase_ == ExtractTypeOneofCase.Element) {
                    size += 1 + pb::CodedOutputStream.ComputeMessageSize(Element);
                  }
                  if (_unknownFields != null) {
                    size += _unknownFields.CalculateSize();
                  }
                  return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(HeaderValueExtractor other) {
                  if (other == null) {
                    return;
                  }
                  if (other.Name.Length != 0) {
                    Name = other.Name;
                  }
                  if (other.ElementSeparator.Length != 0) {
                    ElementSeparator = other.ElementSeparator;
                  }
                  switch (other.ExtractTypeCase) {
                    case ExtractTypeOneofCase.Index:
                      Index = other.Index;
                      break;
                    case ExtractTypeOneofCase.Element:
                      if (Element == null) {
                        Element = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement();
                      }
                      Element.MergeFrom(other.Element);
                      break;
                  }

                  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(pb::CodedInputStream input) {
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                      case 10: {
                        Name = input.ReadString();
                        break;
                      }
                      case 18: {
                        ElementSeparator = input.ReadString();
                        break;
                      }
                      case 24: {
                        Index = input.ReadUInt32();
                        break;
                      }
                      case 34: {
                        global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement subBuilder = new global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Types.KvElement();
                        if (extractTypeCase_ == ExtractTypeOneofCase.Element) {
                          subBuilder.MergeFrom(Element);
                        }
                        input.ReadMessage(subBuilder);
                        Element = subBuilder;
                        break;
                      }
                    }
                  }
                }

                #region Nested types
                /// <summary>Container for nested types declared in the HeaderValueExtractor message type.</summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static partial class Types {
                  /// <summary>
                  /// Specifies a header field's key value pair to match on.
                  /// </summary>
                  public sealed partial class KvElement : pb::IMessage<KvElement> {
                    private static readonly pb::MessageParser<KvElement> _parser = new pb::MessageParser<KvElement>(() => new KvElement());
                    private pb::UnknownFieldSet _unknownFields;
                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public static pb::MessageParser<KvElement> Parser { get { return _parser; } }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public static pbr::MessageDescriptor Descriptor {
                      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.ScopedRoutes.Types.ScopeKeyBuilder.Types.FragmentBuilder.Types.HeaderValueExtractor.Descriptor.NestedTypes[0]; }
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    pbr::MessageDescriptor pb::IMessage.Descriptor {
                      get { return Descriptor; }
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public KvElement() {
                      OnConstruction();
                    }

                    partial void OnConstruction();

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public KvElement(KvElement other) : this() {
                      separator_ = other.separator_;
                      key_ = other.key_;
                      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public KvElement Clone() {
                      return new KvElement(this);
                    }

                    /// <summary>Field number for the "separator" field.</summary>
                    public const int SeparatorFieldNumber = 1;
                    private string separator_ = "";
                    /// <summary>
                    /// The separator between key and value (e.g., '=' separates 'k=v;...').
                    /// If an element is an empty string, the element is ignored.
                    /// If an element contains no separator, the whole element is parsed as key and the
                    /// fragment value is an empty string.
                    /// If there are multiple values for a matched key, the first value is returned.
                    /// </summary>
                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public string Separator {
                      get { return separator_; }
                      set {
                        separator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                      }
                    }

                    /// <summary>Field number for the "key" field.</summary>
                    public const int KeyFieldNumber = 2;
                    private string key_ = "";
                    /// <summary>
                    /// The key to match on.
                    /// </summary>
                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public string Key {
                      get { return key_; }
                      set {
                        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                      }
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public override bool Equals(object other) {
                      return Equals(other as KvElement);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public bool Equals(KvElement other) {
                      if (ReferenceEquals(other, null)) {
                        return false;
                      }
                      if (ReferenceEquals(other, this)) {
                        return true;
                      }
                      if (Separator != other.Separator) return false;
                      if (Key != other.Key) return false;
                      return Equals(_unknownFields, other._unknownFields);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public override int GetHashCode() {
                      int hash = 1;
                      if (Separator.Length != 0) hash ^= Separator.GetHashCode();
                      if (Key.Length != 0) hash ^= Key.GetHashCode();
                      if (_unknownFields != null) {
                        hash ^= _unknownFields.GetHashCode();
                      }
                      return hash;
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public override string ToString() {
                      return pb::JsonFormatter.ToDiagnosticString(this);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public void WriteTo(pb::CodedOutputStream output) {
                      if (Separator.Length != 0) {
                        output.WriteRawTag(10);
                        output.WriteString(Separator);
                      }
                      if (Key.Length != 0) {
                        output.WriteRawTag(18);
                        output.WriteString(Key);
                      }
                      if (_unknownFields != null) {
                        _unknownFields.WriteTo(output);
                      }
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public int CalculateSize() {
                      int size = 0;
                      if (Separator.Length != 0) {
                        size += 1 + pb::CodedOutputStream.ComputeStringSize(Separator);
                      }
                      if (Key.Length != 0) {
                        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
                      }
                      if (_unknownFields != null) {
                        size += _unknownFields.CalculateSize();
                      }
                      return size;
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public void MergeFrom(KvElement other) {
                      if (other == null) {
                        return;
                      }
                      if (other.Separator.Length != 0) {
                        Separator = other.Separator;
                      }
                      if (other.Key.Length != 0) {
                        Key = other.Key;
                      }
                      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                    }

                    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                    public void MergeFrom(pb::CodedInputStream input) {
                      uint tag;
                      while ((tag = input.ReadTag()) != 0) {
                        switch(tag) {
                          default:
                            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                            break;
                          case 10: {
                            Separator = input.ReadString();
                            break;
                          }
                          case 18: {
                            Key = input.ReadString();
                            break;
                          }
                        }
                      }
                    }

                  }

                }
                #endregion

              }

            }
            #endregion

          }

        }
        #endregion

      }

    }
    #endregion

  }

  public sealed partial class ScopedRds : pb::IMessage<ScopedRds> {
    private static readonly pb::MessageParser<ScopedRds> _parser = new pb::MessageParser<ScopedRds>(() => new ScopedRds());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScopedRds> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManagerReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRds() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRds(ScopedRds other) : this() {
      scopedRdsConfigSource_ = other.scopedRdsConfigSource_ != null ? other.scopedRdsConfigSource_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedRds Clone() {
      return new ScopedRds(this);
    }

    /// <summary>Field number for the "scoped_rds_config_source" field.</summary>
    public const int ScopedRdsConfigSourceFieldNumber = 1;
    private global::Envoy.Api.V3Alpha.Core.ConfigSource scopedRdsConfigSource_;
    /// <summary>
    /// Configuration source specifier for scoped RDS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.ConfigSource ScopedRdsConfigSource {
      get { return scopedRdsConfigSource_; }
      set {
        scopedRdsConfigSource_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScopedRds);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScopedRds other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ScopedRdsConfigSource, other.ScopedRdsConfigSource)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (scopedRdsConfigSource_ != null) hash ^= ScopedRdsConfigSource.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (scopedRdsConfigSource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScopedRdsConfigSource);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (scopedRdsConfigSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopedRdsConfigSource);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScopedRds other) {
      if (other == null) {
        return;
      }
      if (other.scopedRdsConfigSource_ != null) {
        if (scopedRdsConfigSource_ == null) {
          ScopedRdsConfigSource = new global::Envoy.Api.V3Alpha.Core.ConfigSource();
        }
        ScopedRdsConfigSource.MergeFrom(other.ScopedRdsConfigSource);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (scopedRdsConfigSource_ == null) {
              ScopedRdsConfigSource = new global::Envoy.Api.V3Alpha.Core.ConfigSource();
            }
            input.ReadMessage(ScopedRdsConfigSource);
            break;
          }
        }
      }
    }

  }

  public sealed partial class HttpFilter : pb::IMessage<HttpFilter> {
    private static readonly pb::MessageParser<HttpFilter> _parser = new pb::MessageParser<HttpFilter>(() => new HttpFilter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HttpFilter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.HttpConnectionManager.V3Alpha.HttpConnectionManagerReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpFilter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpFilter(HttpFilter other) : this() {
      name_ = other.name_;
      switch (other.ConfigTypeCase) {
        case ConfigTypeOneofCase.Config:
          Config = other.Config.Clone();
          break;
        case ConfigTypeOneofCase.TypedConfig:
          TypedConfig = other.TypedConfig.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HttpFilter Clone() {
      return new HttpFilter(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the filter to instantiate. The name must match a
    /// :ref:`supported filter &lt;config_http_filters>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Struct Config {
      get { return configTypeCase_ == ConfigTypeOneofCase.Config ? (global::Google.Protobuf.WellKnownTypes.Struct) configType_ : null; }
      set {
        configType_ = value;
        configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.Config;
      }
    }

    /// <summary>Field number for the "typed_config" field.</summary>
    public const int TypedConfigFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Any TypedConfig {
      get { return configTypeCase_ == ConfigTypeOneofCase.TypedConfig ? (global::Google.Protobuf.WellKnownTypes.Any) configType_ : null; }
      set {
        configType_ = value;
        configTypeCase_ = value == null ? ConfigTypeOneofCase.None : ConfigTypeOneofCase.TypedConfig;
      }
    }

    private object configType_;
    /// <summary>Enum of possible cases for the "config_type" oneof.</summary>
    public enum ConfigTypeOneofCase {
      None = 0,
      Config = 2,
      TypedConfig = 4,
    }
    private ConfigTypeOneofCase configTypeCase_ = ConfigTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConfigTypeOneofCase ConfigTypeCase {
      get { return configTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearConfigType() {
      configTypeCase_ = ConfigTypeOneofCase.None;
      configType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HttpFilter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HttpFilter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Config, other.Config)) return false;
      if (!object.Equals(TypedConfig, other.TypedConfig)) return false;
      if (ConfigTypeCase != other.ConfigTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (configTypeCase_ == ConfigTypeOneofCase.Config) hash ^= Config.GetHashCode();
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) hash ^= TypedConfig.GetHashCode();
      hash ^= (int) configTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.Config) {
        output.WriteRawTag(18);
        output.WriteMessage(Config);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
        output.WriteRawTag(34);
        output.WriteMessage(TypedConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.Config) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TypedConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HttpFilter other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      switch (other.ConfigTypeCase) {
        case ConfigTypeOneofCase.Config:
          if (Config == null) {
            Config = new global::Google.Protobuf.WellKnownTypes.Struct();
          }
          Config.MergeFrom(other.Config);
          break;
        case ConfigTypeOneofCase.TypedConfig:
          if (TypedConfig == null) {
            TypedConfig = new global::Google.Protobuf.WellKnownTypes.Any();
          }
          TypedConfig.MergeFrom(other.TypedConfig);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            global::Google.Protobuf.WellKnownTypes.Struct subBuilder = new global::Google.Protobuf.WellKnownTypes.Struct();
            if (configTypeCase_ == ConfigTypeOneofCase.Config) {
              subBuilder.MergeFrom(Config);
            }
            input.ReadMessage(subBuilder);
            Config = subBuilder;
            break;
          }
          case 34: {
            global::Google.Protobuf.WellKnownTypes.Any subBuilder = new global::Google.Protobuf.WellKnownTypes.Any();
            if (configTypeCase_ == ConfigTypeOneofCase.TypedConfig) {
              subBuilder.MergeFrom(TypedConfig);
            }
            input.ReadMessage(subBuilder);
            TypedConfig = subBuilder;
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
