// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/filter/network/redis_proxy/v3alpha/redis_proxy.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Filter.Network.RedisProxy.V3Alpha {

  /// <summary>Holder for reflection information generated from envoy/config/filter/network/redis_proxy/v3alpha/redis_proxy.proto</summary>
  public static partial class RedisProxyReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/filter/network/redis_proxy/v3alpha/redis_proxy.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RedisProxyReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CkFlbnZveS9jb25maWcvZmlsdGVyL25ldHdvcmsvcmVkaXNfcHJveHkvdjNh",
            "bHBoYS9yZWRpc19wcm94eS5wcm90bxIvZW52b3kuY29uZmlnLmZpbHRlci5u",
            "ZXR3b3JrLnJlZGlzX3Byb3h5LnYzYWxwaGEaIWVudm95L2FwaS92M2FscGhh",
            "L2NvcmUvYmFzZS5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnBy",
            "b3RvGh5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8aF3ZhbGlkYXRl",
            "L3ZhbGlkYXRlLnByb3RvIvILCgpSZWRpc1Byb3h5Eh4KC3N0YXRfcHJlZml4",
            "GAEgASgJQgm66cADBHICIAESEwoHY2x1c3RlchgCIAEoCUICGAESagoIc2V0",
            "dGluZ3MYAyABKAsyTC5lbnZveS5jb25maWcuZmlsdGVyLm5ldHdvcmsucmVk",
            "aXNfcHJveHkudjNhbHBoYS5SZWRpc1Byb3h5LkNvbm5Qb29sU2V0dGluZ3NC",
            "CrrpwAMFigECEAESGQoRbGF0ZW5jeV9pbl9taWNyb3MYBCABKAgSXwoNcHJl",
            "Zml4X3JvdXRlcxgFIAEoCzJILmVudm95LmNvbmZpZy5maWx0ZXIubmV0d29y",
            "ay5yZWRpc19wcm94eS52M2FscGhhLlJlZGlzUHJveHkuUHJlZml4Um91dGVz",
            "EkQKGGRvd25zdHJlYW1fYXV0aF9wYXNzd29yZBgGIAEoCzIiLmVudm95LmFw",
            "aS52M2FscGhhLmNvcmUuRGF0YVNvdXJjZRr9AwoQQ29ublBvb2xTZXR0aW5n",
            "cxI5CgpvcF90aW1lb3V0GAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0",
            "aW9uQgq66cADBaoBAggBEhoKEmVuYWJsZV9oYXNodGFnZ2luZxgCIAEoCBIa",
            "ChJlbmFibGVfcmVkaXJlY3Rpb24YAyABKAgSJAocbWF4X2J1ZmZlcl9zaXpl",
            "X2JlZm9yZV9mbHVzaBgEIAEoDRI3ChRidWZmZXJfZmx1c2hfdGltZW91dBgF",
            "IAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbhJGCiBtYXhfdXBzdHJl",
            "YW1fdW5rbm93bl9jb25uZWN0aW9ucxgGIAEoCzIcLmdvb2dsZS5wcm90b2J1",
            "Zi5VSW50MzJWYWx1ZRJ4CgtyZWFkX3BvbGljeRgHIAEoDjJXLmVudm95LmNv",
            "bmZpZy5maWx0ZXIubmV0d29yay5yZWRpc19wcm94eS52M2FscGhhLlJlZGlz",
            "UHJveHkuQ29ublBvb2xTZXR0aW5ncy5SZWFkUG9saWN5Qgq66cADBYIBAhAB",
            "IlUKClJlYWRQb2xpY3kSCgoGTUFTVEVSEAASEQoNUFJFRkVSX01BU1RFUhAB",
            "EgsKB1JFUExJQ0EQAhISCg5QUkVGRVJfUkVQTElDQRADEgcKA0FOWRAEGoAF",
            "CgxQcmVmaXhSb3V0ZXMSXgoGcm91dGVzGAEgAygLMk4uZW52b3kuY29uZmln",
            "LmZpbHRlci5uZXR3b3JrLnJlZGlzX3Byb3h5LnYzYWxwaGEuUmVkaXNQcm94",
            "eS5QcmVmaXhSb3V0ZXMuUm91dGUSGAoQY2FzZV9pbnNlbnNpdGl2ZRgCIAEo",
            "CBIdChFjYXRjaF9hbGxfY2x1c3RlchgDIAEoCUICGAESZwoPY2F0Y2hfYWxs",
            "X3JvdXRlGAQgASgLMk4uZW52b3kuY29uZmlnLmZpbHRlci5uZXR3b3JrLnJl",
            "ZGlzX3Byb3h5LnYzYWxwaGEuUmVkaXNQcm94eS5QcmVmaXhSb3V0ZXMuUm91",
            "dGUa7QIKBVJvdXRlEg4KBnByZWZpeBgBIAEoCRIVCg1yZW1vdmVfcHJlZml4",
            "GAIgASgIEhoKB2NsdXN0ZXIYAyABKAlCCbrpwAMEcgIgARKBAQoVcmVxdWVz",
            "dF9taXJyb3JfcG9saWN5GAQgAygLMmIuZW52b3kuY29uZmlnLmZpbHRlci5u",
            "ZXR3b3JrLnJlZGlzX3Byb3h5LnYzYWxwaGEuUmVkaXNQcm94eS5QcmVmaXhS",
            "b3V0ZXMuUm91dGUuUmVxdWVzdE1pcnJvclBvbGljeRqcAQoTUmVxdWVzdE1p",
            "cnJvclBvbGljeRIaCgdjbHVzdGVyGAEgASgJQgm66cADBHICIAESSgoQcnVu",
            "dGltZV9mcmFjdGlvbhgCIAEoCzIwLmVudm95LmFwaS52M2FscGhhLmNvcmUu",
            "UnVudGltZUZyYWN0aW9uYWxQZXJjZW50Eh0KFWV4Y2x1ZGVfcmVhZF9jb21t",
            "YW5kcxgDIAEoCCJRChRSZWRpc1Byb3RvY29sT3B0aW9ucxI5Cg1hdXRoX3Bh",
            "c3N3b3JkGAEgASgLMiIuZW52b3kuYXBpLnYzYWxwaGEuY29yZS5EYXRhU291",
            "cmNlQlIKPWlvLmVudm95cHJveHkuZW52b3kuY29uZmlnLmZpbHRlci5uZXR3",
            "b3JrLnJlZGlzX3Byb3h5LnYzYWxwaGFCD1JlZGlzUHJveHlQcm90b1ABYgZw",
            "cm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V3Alpha.Core.BaseReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy), global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Parser, new[]{ "StatPrefix", "Cluster", "Settings", "LatencyInMicros", "PrefixRoutes", "DownstreamAuthPassword" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings), global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Parser, new[]{ "OpTimeout", "EnableHashtagging", "EnableRedirection", "MaxBufferSizeBeforeFlush", "BufferFlushTimeout", "MaxUpstreamUnknownConnections", "ReadPolicy" }, null, new[]{ typeof(global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes), global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Parser, new[]{ "Routes", "CaseInsensitive", "CatchAllCluster", "CatchAllRoute" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route), global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Parser, new[]{ "Prefix", "RemovePrefix", "Cluster", "RequestMirrorPolicy" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Types.RequestMirrorPolicy), global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Types.RequestMirrorPolicy.Parser, new[]{ "Cluster", "RuntimeFraction", "ExcludeReadCommands" }, null, null, null, null)})})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProtocolOptions), global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProtocolOptions.Parser, new[]{ "AuthPassword" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class RedisProxy : pb::IMessage<RedisProxy> {
    private static readonly pb::MessageParser<RedisProxy> _parser = new pb::MessageParser<RedisProxy>(() => new RedisProxy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RedisProxy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxyReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedisProxy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedisProxy(RedisProxy other) : this() {
      statPrefix_ = other.statPrefix_;
      cluster_ = other.cluster_;
      settings_ = other.settings_ != null ? other.settings_.Clone() : null;
      latencyInMicros_ = other.latencyInMicros_;
      prefixRoutes_ = other.prefixRoutes_ != null ? other.prefixRoutes_.Clone() : null;
      downstreamAuthPassword_ = other.downstreamAuthPassword_ != null ? other.downstreamAuthPassword_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedisProxy Clone() {
      return new RedisProxy(this);
    }

    /// <summary>Field number for the "stat_prefix" field.</summary>
    public const int StatPrefixFieldNumber = 1;
    private string statPrefix_ = "";
    /// <summary>
    /// The prefix to use when emitting :ref:`statistics &lt;config_network_filters_redis_proxy_stats>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StatPrefix {
      get { return statPrefix_; }
      set {
        statPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cluster" field.</summary>
    public const int ClusterFieldNumber = 2;
    private string cluster_ = "";
    /// <summary>
    /// Name of cluster from cluster manager. See the :ref:`configuration section
    /// &lt;arch_overview_redis_configuration>` of the architecture overview for recommendations on
    /// configuring the backing cluster.
    ///
    /// .. attention::
    ///
    ///   This field is deprecated. Use a :ref:`catch_all
    ///   route&lt;envoy_api_field_config.filter.network.redis_proxy.v3alpha.RedisProxy.PrefixRoutes.catch_all_route>`
    ///   instead.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Cluster {
      get { return cluster_; }
      set {
        cluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "settings" field.</summary>
    public const int SettingsFieldNumber = 3;
    private global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings settings_;
    /// <summary>
    /// Network settings for the connection pool to the upstream clusters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings Settings {
      get { return settings_; }
      set {
        settings_ = value;
      }
    }

    /// <summary>Field number for the "latency_in_micros" field.</summary>
    public const int LatencyInMicrosFieldNumber = 4;
    private bool latencyInMicros_;
    /// <summary>
    /// Indicates that latency stat should be computed in microseconds. By default it is computed in
    /// milliseconds.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool LatencyInMicros {
      get { return latencyInMicros_; }
      set {
        latencyInMicros_ = value;
      }
    }

    /// <summary>Field number for the "prefix_routes" field.</summary>
    public const int PrefixRoutesFieldNumber = 5;
    private global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes prefixRoutes_;
    /// <summary>
    /// List of **unique** prefixes used to separate keys from different workloads to different
    /// clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
    /// cluster can be used to forward commands when there is no match. Time complexity of the
    /// lookups are in O(min(longest key prefix, key length)).
    ///
    /// Example:
    ///
    /// .. code-block:: yaml
    ///
    ///    prefix_routes:
    ///      routes:
    ///        - prefix: "ab"
    ///          cluster: "cluster_a"
    ///        - prefix: "abc"
    ///          cluster: "cluster_b"
    ///
    /// When using the above routes, the following prefixes would be sent to:
    ///
    /// * 'get abc:users' would retrive the key 'abc:users' from cluster_b.
    /// * 'get ab:users' would retrive the key 'ab:users' from cluster_a.
    /// * 'get z:users' would return a NoUpstreamHost error. A :ref:`catch-all
    ///   route&lt;envoy_api_field_config.filter.network.redis_proxy.v3alpha.RedisProxy.PrefixRoutes.catch_all_route>`
    ///   would have retrieved the key from that cluster instead.
    ///
    /// See the :ref:`configuration section
    /// &lt;arch_overview_redis_configuration>` of the architecture overview for recommendations on
    /// configuring the backing clusters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes PrefixRoutes {
      get { return prefixRoutes_; }
      set {
        prefixRoutes_ = value;
      }
    }

    /// <summary>Field number for the "downstream_auth_password" field.</summary>
    public const int DownstreamAuthPasswordFieldNumber = 6;
    private global::Envoy.Api.V3Alpha.Core.DataSource downstreamAuthPassword_;
    /// <summary>
    /// Authenticate Redis client connections locally by forcing downstream clients to issue a 'Redis
    /// AUTH command &lt;https://redis.io/commands/auth>`_ with this password before enabling any other
    /// command. If an AUTH command's password matches this password, an "OK" response will be returned
    /// to the client. If the AUTH command password does not match this password, then an "ERR invalid
    /// password" error will be returned. If any other command is received before AUTH when this
    /// password is set, then a "NOAUTH Authentication required." error response will be sent to the
    /// client. If an AUTH command is received when the password is not set, then an "ERR Client sent
    /// AUTH, but no password is set" error will be returned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.DataSource DownstreamAuthPassword {
      get { return downstreamAuthPassword_; }
      set {
        downstreamAuthPassword_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RedisProxy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RedisProxy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StatPrefix != other.StatPrefix) return false;
      if (Cluster != other.Cluster) return false;
      if (!object.Equals(Settings, other.Settings)) return false;
      if (LatencyInMicros != other.LatencyInMicros) return false;
      if (!object.Equals(PrefixRoutes, other.PrefixRoutes)) return false;
      if (!object.Equals(DownstreamAuthPassword, other.DownstreamAuthPassword)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (StatPrefix.Length != 0) hash ^= StatPrefix.GetHashCode();
      if (Cluster.Length != 0) hash ^= Cluster.GetHashCode();
      if (settings_ != null) hash ^= Settings.GetHashCode();
      if (LatencyInMicros != false) hash ^= LatencyInMicros.GetHashCode();
      if (prefixRoutes_ != null) hash ^= PrefixRoutes.GetHashCode();
      if (downstreamAuthPassword_ != null) hash ^= DownstreamAuthPassword.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (StatPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(StatPrefix);
      }
      if (Cluster.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Cluster);
      }
      if (settings_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Settings);
      }
      if (LatencyInMicros != false) {
        output.WriteRawTag(32);
        output.WriteBool(LatencyInMicros);
      }
      if (prefixRoutes_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(PrefixRoutes);
      }
      if (downstreamAuthPassword_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DownstreamAuthPassword);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (StatPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StatPrefix);
      }
      if (Cluster.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
      }
      if (settings_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Settings);
      }
      if (LatencyInMicros != false) {
        size += 1 + 1;
      }
      if (prefixRoutes_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PrefixRoutes);
      }
      if (downstreamAuthPassword_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DownstreamAuthPassword);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RedisProxy other) {
      if (other == null) {
        return;
      }
      if (other.StatPrefix.Length != 0) {
        StatPrefix = other.StatPrefix;
      }
      if (other.Cluster.Length != 0) {
        Cluster = other.Cluster;
      }
      if (other.settings_ != null) {
        if (settings_ == null) {
          Settings = new global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings();
        }
        Settings.MergeFrom(other.Settings);
      }
      if (other.LatencyInMicros != false) {
        LatencyInMicros = other.LatencyInMicros;
      }
      if (other.prefixRoutes_ != null) {
        if (prefixRoutes_ == null) {
          PrefixRoutes = new global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes();
        }
        PrefixRoutes.MergeFrom(other.PrefixRoutes);
      }
      if (other.downstreamAuthPassword_ != null) {
        if (downstreamAuthPassword_ == null) {
          DownstreamAuthPassword = new global::Envoy.Api.V3Alpha.Core.DataSource();
        }
        DownstreamAuthPassword.MergeFrom(other.DownstreamAuthPassword);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            StatPrefix = input.ReadString();
            break;
          }
          case 18: {
            Cluster = input.ReadString();
            break;
          }
          case 26: {
            if (settings_ == null) {
              Settings = new global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings();
            }
            input.ReadMessage(Settings);
            break;
          }
          case 32: {
            LatencyInMicros = input.ReadBool();
            break;
          }
          case 42: {
            if (prefixRoutes_ == null) {
              PrefixRoutes = new global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes();
            }
            input.ReadMessage(PrefixRoutes);
            break;
          }
          case 50: {
            if (downstreamAuthPassword_ == null) {
              DownstreamAuthPassword = new global::Envoy.Api.V3Alpha.Core.DataSource();
            }
            input.ReadMessage(DownstreamAuthPassword);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RedisProxy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Redis connection pool settings.
      /// </summary>
      public sealed partial class ConnPoolSettings : pb::IMessage<ConnPoolSettings> {
        private static readonly pb::MessageParser<ConnPoolSettings> _parser = new pb::MessageParser<ConnPoolSettings>(() => new ConnPoolSettings());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<ConnPoolSettings> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ConnPoolSettings() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ConnPoolSettings(ConnPoolSettings other) : this() {
          opTimeout_ = other.opTimeout_ != null ? other.opTimeout_.Clone() : null;
          enableHashtagging_ = other.enableHashtagging_;
          enableRedirection_ = other.enableRedirection_;
          maxBufferSizeBeforeFlush_ = other.maxBufferSizeBeforeFlush_;
          bufferFlushTimeout_ = other.bufferFlushTimeout_ != null ? other.bufferFlushTimeout_.Clone() : null;
          MaxUpstreamUnknownConnections = other.MaxUpstreamUnknownConnections;
          readPolicy_ = other.readPolicy_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ConnPoolSettings Clone() {
          return new ConnPoolSettings(this);
        }

        /// <summary>Field number for the "op_timeout" field.</summary>
        public const int OpTimeoutFieldNumber = 1;
        private global::Google.Protobuf.WellKnownTypes.Duration opTimeout_;
        /// <summary>
        /// Per-operation timeout in milliseconds. The timer starts when the first
        /// command of a pipeline is written to the backend connection. Each response received from Redis
        /// resets the timer since it signifies that the next command is being processed by the backend.
        /// The only exception to this behavior is when a connection to a backend is not yet established.
        /// In that case, the connect timeout on the cluster will govern the timeout until the connection
        /// is ready.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration OpTimeout {
          get { return opTimeout_; }
          set {
            opTimeout_ = value;
          }
        }

        /// <summary>Field number for the "enable_hashtagging" field.</summary>
        public const int EnableHashtaggingFieldNumber = 2;
        private bool enableHashtagging_;
        /// <summary>
        /// Use hash tagging on every redis key to guarantee that keys with the same hash tag will be
        /// forwarded to the same upstream. The hash key used for determining the upstream in a
        /// consistent hash ring configuration will be computed from the hash tagged key instead of the
        /// whole key. The algorithm used to compute the hash tag is identical to the `redis-cluster
        /// implementation &lt;https://redis.io/topics/cluster-spec#keys-hash-tags>`_.
        ///
        /// Examples:
        ///
        /// * '{user1000}.following' and '{user1000}.followers' **will** be sent to the same upstream
        /// * '{user1000}.following' and '{user1001}.following' **might** be sent to the same upstream
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool EnableHashtagging {
          get { return enableHashtagging_; }
          set {
            enableHashtagging_ = value;
          }
        }

        /// <summary>Field number for the "enable_redirection" field.</summary>
        public const int EnableRedirectionFieldNumber = 3;
        private bool enableRedirection_;
        /// <summary>
        /// Accept `moved and ask redirection
        /// &lt;https://redis.io/topics/cluster-spec#redirection-and-resharding>`_ errors from upstream
        /// redis servers, and retry commands to the specified target server. The target server does not
        /// need to be known to the cluster manager. If the command cannot be redirected, then the
        /// original error is passed downstream unchanged. By default, this support is not enabled.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool EnableRedirection {
          get { return enableRedirection_; }
          set {
            enableRedirection_ = value;
          }
        }

        /// <summary>Field number for the "max_buffer_size_before_flush" field.</summary>
        public const int MaxBufferSizeBeforeFlushFieldNumber = 4;
        private uint maxBufferSizeBeforeFlush_;
        /// <summary>
        /// Maximum size of encoded request buffer before flush is triggered and encoded requests
        /// are sent upstream. If this is unset, the buffer flushes whenever it receives data
        /// and performs no batching.
        /// This feature makes it possible for multiple clients to send requests to Envoy and have
        /// them batched- for example if one is running several worker processes, each with its own
        /// Redis connection. There is no benefit to using this with a single downstream process.
        /// Recommended size (if enabled) is 1024 bytes.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint MaxBufferSizeBeforeFlush {
          get { return maxBufferSizeBeforeFlush_; }
          set {
            maxBufferSizeBeforeFlush_ = value;
          }
        }

        /// <summary>Field number for the "buffer_flush_timeout" field.</summary>
        public const int BufferFlushTimeoutFieldNumber = 5;
        private global::Google.Protobuf.WellKnownTypes.Duration bufferFlushTimeout_;
        /// <summary>
        /// The encoded request buffer is flushed N milliseconds after the first request has been
        /// encoded, unless the buffer size has already exceeded `max_buffer_size_before_flush`.
        /// If `max_buffer_size_before_flush` is not set, this flush timer is not used. Otherwise,
        /// the timer should be set according to the number of clients, overall request rate and
        /// desired maximum latency for a single command. For example, if there are many requests
        /// being batched together at a high rate, the buffer will likely be filled before the timer
        /// fires. Alternatively, if the request rate is lower the buffer will not be filled as often
        /// before the timer fires.
        /// If `max_buffer_size_before_flush` is set, but `buffer_flush_timeout` is not, the latter
        /// defaults to 3ms.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Duration BufferFlushTimeout {
          get { return bufferFlushTimeout_; }
          set {
            bufferFlushTimeout_ = value;
          }
        }

        /// <summary>Field number for the "max_upstream_unknown_connections" field.</summary>
        public const int MaxUpstreamUnknownConnectionsFieldNumber = 6;
        private static readonly pb::FieldCodec<uint?> _single_maxUpstreamUnknownConnections_codec = pb::FieldCodec.ForStructWrapper<uint>(50);
        private uint? maxUpstreamUnknownConnections_;
        /// <summary>
        /// `max_upstream_unknown_connections` controls how many upstream connections to unknown hosts
        /// can be created at any given time by any given worker thread (see `enable_redirection` for
        /// more details). If the host is unknown and a connection cannot be created due to enforcing
        /// this limit, then redirection will fail and the original redirection error will be passed
        /// downstream unchanged. This limit defaults to 100.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint? MaxUpstreamUnknownConnections {
          get { return maxUpstreamUnknownConnections_; }
          set {
            maxUpstreamUnknownConnections_ = value;
          }
        }


        /// <summary>Field number for the "read_policy" field.</summary>
        public const int ReadPolicyFieldNumber = 7;
        private global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy readPolicy_ = global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy.Master;
        /// <summary>
        /// Read policy. The default is to read from the master.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy ReadPolicy {
          get { return readPolicy_; }
          set {
            readPolicy_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as ConnPoolSettings);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(ConnPoolSettings other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(OpTimeout, other.OpTimeout)) return false;
          if (EnableHashtagging != other.EnableHashtagging) return false;
          if (EnableRedirection != other.EnableRedirection) return false;
          if (MaxBufferSizeBeforeFlush != other.MaxBufferSizeBeforeFlush) return false;
          if (!object.Equals(BufferFlushTimeout, other.BufferFlushTimeout)) return false;
          if (MaxUpstreamUnknownConnections != other.MaxUpstreamUnknownConnections) return false;
          if (ReadPolicy != other.ReadPolicy) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (opTimeout_ != null) hash ^= OpTimeout.GetHashCode();
          if (EnableHashtagging != false) hash ^= EnableHashtagging.GetHashCode();
          if (EnableRedirection != false) hash ^= EnableRedirection.GetHashCode();
          if (MaxBufferSizeBeforeFlush != 0) hash ^= MaxBufferSizeBeforeFlush.GetHashCode();
          if (bufferFlushTimeout_ != null) hash ^= BufferFlushTimeout.GetHashCode();
          if (maxUpstreamUnknownConnections_ != null) hash ^= MaxUpstreamUnknownConnections.GetHashCode();
          if (ReadPolicy != global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy.Master) hash ^= ReadPolicy.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (opTimeout_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(OpTimeout);
          }
          if (EnableHashtagging != false) {
            output.WriteRawTag(16);
            output.WriteBool(EnableHashtagging);
          }
          if (EnableRedirection != false) {
            output.WriteRawTag(24);
            output.WriteBool(EnableRedirection);
          }
          if (MaxBufferSizeBeforeFlush != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(MaxBufferSizeBeforeFlush);
          }
          if (bufferFlushTimeout_ != null) {
            output.WriteRawTag(42);
            output.WriteMessage(BufferFlushTimeout);
          }
          if (maxUpstreamUnknownConnections_ != null) {
            _single_maxUpstreamUnknownConnections_codec.WriteTagAndValue(output, MaxUpstreamUnknownConnections);
          }
          if (ReadPolicy != global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy.Master) {
            output.WriteRawTag(56);
            output.WriteEnum((int) ReadPolicy);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (opTimeout_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(OpTimeout);
          }
          if (EnableHashtagging != false) {
            size += 1 + 1;
          }
          if (EnableRedirection != false) {
            size += 1 + 1;
          }
          if (MaxBufferSizeBeforeFlush != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxBufferSizeBeforeFlush);
          }
          if (bufferFlushTimeout_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(BufferFlushTimeout);
          }
          if (maxUpstreamUnknownConnections_ != null) {
            size += _single_maxUpstreamUnknownConnections_codec.CalculateSizeWithTag(MaxUpstreamUnknownConnections);
          }
          if (ReadPolicy != global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy.Master) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ReadPolicy);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(ConnPoolSettings other) {
          if (other == null) {
            return;
          }
          if (other.opTimeout_ != null) {
            if (opTimeout_ == null) {
              OpTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            OpTimeout.MergeFrom(other.OpTimeout);
          }
          if (other.EnableHashtagging != false) {
            EnableHashtagging = other.EnableHashtagging;
          }
          if (other.EnableRedirection != false) {
            EnableRedirection = other.EnableRedirection;
          }
          if (other.MaxBufferSizeBeforeFlush != 0) {
            MaxBufferSizeBeforeFlush = other.MaxBufferSizeBeforeFlush;
          }
          if (other.bufferFlushTimeout_ != null) {
            if (bufferFlushTimeout_ == null) {
              BufferFlushTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            BufferFlushTimeout.MergeFrom(other.BufferFlushTimeout);
          }
          if (other.maxUpstreamUnknownConnections_ != null) {
            if (maxUpstreamUnknownConnections_ == null || other.MaxUpstreamUnknownConnections != 0) {
              MaxUpstreamUnknownConnections = other.MaxUpstreamUnknownConnections;
            }
          }
          if (other.ReadPolicy != global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy.Master) {
            ReadPolicy = other.ReadPolicy;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (opTimeout_ == null) {
                  OpTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(OpTimeout);
                break;
              }
              case 16: {
                EnableHashtagging = input.ReadBool();
                break;
              }
              case 24: {
                EnableRedirection = input.ReadBool();
                break;
              }
              case 32: {
                MaxBufferSizeBeforeFlush = input.ReadUInt32();
                break;
              }
              case 42: {
                if (bufferFlushTimeout_ == null) {
                  BufferFlushTimeout = new global::Google.Protobuf.WellKnownTypes.Duration();
                }
                input.ReadMessage(BufferFlushTimeout);
                break;
              }
              case 50: {
                uint? value = _single_maxUpstreamUnknownConnections_codec.Read(input);
                if (maxUpstreamUnknownConnections_ == null || value != 0) {
                  MaxUpstreamUnknownConnections = value;
                }
                break;
              }
              case 56: {
                ReadPolicy = (global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.ConnPoolSettings.Types.ReadPolicy) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the ConnPoolSettings message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
          /// supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
          /// because replication is asynchronous and requires some delay. You need to ensure that your
          /// application can tolerate stale data.
          /// </summary>
          public enum ReadPolicy {
            /// <summary>
            /// Default mode. Read from the current master node.
            /// </summary>
            [pbr::OriginalName("MASTER")] Master = 0,
            /// <summary>
            /// Read from the master, but if it is unavailable, read from replica nodes.
            /// </summary>
            [pbr::OriginalName("PREFER_MASTER")] PreferMaster = 1,
            /// <summary>
            /// Read from replica nodes. If multiple replica nodes are present within a shard, a random
            /// node is selected. Healthy nodes have precedent over unhealthy nodes.
            /// </summary>
            [pbr::OriginalName("REPLICA")] Replica = 2,
            /// <summary>
            /// Read from the replica nodes (similar to REPLICA), but if all replicas are unavailable (not
            /// present or unhealthy), read from the master.
            /// </summary>
            [pbr::OriginalName("PREFER_REPLICA")] PreferReplica = 3,
            /// <summary>
            /// Read from any node of the cluster. A random node is selected among the master and replicas,
            /// healthy nodes have precedent over unhealthy nodes.
            /// </summary>
            [pbr::OriginalName("ANY")] Any = 4,
          }

        }
        #endregion

      }

      public sealed partial class PrefixRoutes : pb::IMessage<PrefixRoutes> {
        private static readonly pb::MessageParser<PrefixRoutes> _parser = new pb::MessageParser<PrefixRoutes>(() => new PrefixRoutes());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<PrefixRoutes> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PrefixRoutes() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PrefixRoutes(PrefixRoutes other) : this() {
          routes_ = other.routes_.Clone();
          caseInsensitive_ = other.caseInsensitive_;
          catchAllCluster_ = other.catchAllCluster_;
          catchAllRoute_ = other.catchAllRoute_ != null ? other.catchAllRoute_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public PrefixRoutes Clone() {
          return new PrefixRoutes(this);
        }

        /// <summary>Field number for the "routes" field.</summary>
        public const int RoutesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route> _repeated_routes_codec
            = pb::FieldCodec.ForMessage(10, global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route> routes_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route>();
        /// <summary>
        /// List of prefix routes.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route> Routes {
          get { return routes_; }
        }

        /// <summary>Field number for the "case_insensitive" field.</summary>
        public const int CaseInsensitiveFieldNumber = 2;
        private bool caseInsensitive_;
        /// <summary>
        /// Indicates that prefix matching should be case insensitive.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool CaseInsensitive {
          get { return caseInsensitive_; }
          set {
            caseInsensitive_ = value;
          }
        }

        /// <summary>Field number for the "catch_all_cluster" field.</summary>
        public const int CatchAllClusterFieldNumber = 3;
        private string catchAllCluster_ = "";
        /// <summary>
        /// Optional catch-all route to forward commands that doesn't match any of the routes. The
        /// catch-all route becomes required when no routes are specified.
        /// .. attention::
        ///
        ///   This field is deprecated. Use a :ref:`catch_all
        ///   route&lt;envoy_api_field_config.filter.network.redis_proxy.v3alpha.RedisProxy.PrefixRoutes.catch_all_route>`
        ///   instead.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string CatchAllCluster {
          get { return catchAllCluster_; }
          set {
            catchAllCluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "catch_all_route" field.</summary>
        public const int CatchAllRouteFieldNumber = 4;
        private global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route catchAllRoute_;
        /// <summary>
        /// Optional catch-all route to forward commands that doesn't match any of the routes. The
        /// catch-all route becomes required when no routes are specified.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route CatchAllRoute {
          get { return catchAllRoute_; }
          set {
            catchAllRoute_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as PrefixRoutes);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(PrefixRoutes other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!routes_.Equals(other.routes_)) return false;
          if (CaseInsensitive != other.CaseInsensitive) return false;
          if (CatchAllCluster != other.CatchAllCluster) return false;
          if (!object.Equals(CatchAllRoute, other.CatchAllRoute)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= routes_.GetHashCode();
          if (CaseInsensitive != false) hash ^= CaseInsensitive.GetHashCode();
          if (CatchAllCluster.Length != 0) hash ^= CatchAllCluster.GetHashCode();
          if (catchAllRoute_ != null) hash ^= CatchAllRoute.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          routes_.WriteTo(output, _repeated_routes_codec);
          if (CaseInsensitive != false) {
            output.WriteRawTag(16);
            output.WriteBool(CaseInsensitive);
          }
          if (CatchAllCluster.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(CatchAllCluster);
          }
          if (catchAllRoute_ != null) {
            output.WriteRawTag(34);
            output.WriteMessage(CatchAllRoute);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += routes_.CalculateSize(_repeated_routes_codec);
          if (CaseInsensitive != false) {
            size += 1 + 1;
          }
          if (CatchAllCluster.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(CatchAllCluster);
          }
          if (catchAllRoute_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(CatchAllRoute);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(PrefixRoutes other) {
          if (other == null) {
            return;
          }
          routes_.Add(other.routes_);
          if (other.CaseInsensitive != false) {
            CaseInsensitive = other.CaseInsensitive;
          }
          if (other.CatchAllCluster.Length != 0) {
            CatchAllCluster = other.CatchAllCluster;
          }
          if (other.catchAllRoute_ != null) {
            if (catchAllRoute_ == null) {
              CatchAllRoute = new global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route();
            }
            CatchAllRoute.MergeFrom(other.CatchAllRoute);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                routes_.AddEntriesFrom(input, _repeated_routes_codec);
                break;
              }
              case 16: {
                CaseInsensitive = input.ReadBool();
                break;
              }
              case 26: {
                CatchAllCluster = input.ReadString();
                break;
              }
              case 34: {
                if (catchAllRoute_ == null) {
                  CatchAllRoute = new global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route();
                }
                input.ReadMessage(CatchAllRoute);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the PrefixRoutes message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class Route : pb::IMessage<Route> {
            private static readonly pb::MessageParser<Route> _parser = new pb::MessageParser<Route>(() => new Route());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Route> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Route() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Route(Route other) : this() {
              prefix_ = other.prefix_;
              removePrefix_ = other.removePrefix_;
              cluster_ = other.cluster_;
              requestMirrorPolicy_ = other.requestMirrorPolicy_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Route Clone() {
              return new Route(this);
            }

            /// <summary>Field number for the "prefix" field.</summary>
            public const int PrefixFieldNumber = 1;
            private string prefix_ = "";
            /// <summary>
            /// String prefix that must match the beginning of the keys. Envoy will always favor the
            /// longest match.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Prefix {
              get { return prefix_; }
              set {
                prefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "remove_prefix" field.</summary>
            public const int RemovePrefixFieldNumber = 2;
            private bool removePrefix_;
            /// <summary>
            /// Indicates if the prefix needs to be removed from the key when forwarded.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool RemovePrefix {
              get { return removePrefix_; }
              set {
                removePrefix_ = value;
              }
            }

            /// <summary>Field number for the "cluster" field.</summary>
            public const int ClusterFieldNumber = 3;
            private string cluster_ = "";
            /// <summary>
            /// Upstream cluster to forward the command to.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string Cluster {
              get { return cluster_; }
              set {
                cluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "request_mirror_policy" field.</summary>
            public const int RequestMirrorPolicyFieldNumber = 4;
            private static readonly pb::FieldCodec<global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Types.RequestMirrorPolicy> _repeated_requestMirrorPolicy_codec
                = pb::FieldCodec.ForMessage(34, global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Types.RequestMirrorPolicy.Parser);
            private readonly pbc::RepeatedField<global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Types.RequestMirrorPolicy> requestMirrorPolicy_ = new pbc::RepeatedField<global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Types.RequestMirrorPolicy>();
            /// <summary>
            /// Indicates that the route has a request mirroring policy.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Types.RequestMirrorPolicy> RequestMirrorPolicy {
              get { return requestMirrorPolicy_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Route);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Route other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Prefix != other.Prefix) return false;
              if (RemovePrefix != other.RemovePrefix) return false;
              if (Cluster != other.Cluster) return false;
              if(!requestMirrorPolicy_.Equals(other.requestMirrorPolicy_)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (Prefix.Length != 0) hash ^= Prefix.GetHashCode();
              if (RemovePrefix != false) hash ^= RemovePrefix.GetHashCode();
              if (Cluster.Length != 0) hash ^= Cluster.GetHashCode();
              hash ^= requestMirrorPolicy_.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (Prefix.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Prefix);
              }
              if (RemovePrefix != false) {
                output.WriteRawTag(16);
                output.WriteBool(RemovePrefix);
              }
              if (Cluster.Length != 0) {
                output.WriteRawTag(26);
                output.WriteString(Cluster);
              }
              requestMirrorPolicy_.WriteTo(output, _repeated_requestMirrorPolicy_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (Prefix.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Prefix);
              }
              if (RemovePrefix != false) {
                size += 1 + 1;
              }
              if (Cluster.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
              }
              size += requestMirrorPolicy_.CalculateSize(_repeated_requestMirrorPolicy_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Route other) {
              if (other == null) {
                return;
              }
              if (other.Prefix.Length != 0) {
                Prefix = other.Prefix;
              }
              if (other.RemovePrefix != false) {
                RemovePrefix = other.RemovePrefix;
              }
              if (other.Cluster.Length != 0) {
                Cluster = other.Cluster;
              }
              requestMirrorPolicy_.Add(other.requestMirrorPolicy_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Prefix = input.ReadString();
                    break;
                  }
                  case 16: {
                    RemovePrefix = input.ReadBool();
                    break;
                  }
                  case 26: {
                    Cluster = input.ReadString();
                    break;
                  }
                  case 34: {
                    requestMirrorPolicy_.AddEntriesFrom(input, _repeated_requestMirrorPolicy_codec);
                    break;
                  }
                }
              }
            }

            #region Nested types
            /// <summary>Container for nested types declared in the Route message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static partial class Types {
              /// <summary>
              /// The router is capable of shadowing traffic from one cluster to another. The current
              /// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
              /// respond before returning the response from the primary cluster. All normal statistics are
              /// collected for the shadow cluster making this feature useful for testing.
              /// </summary>
              public sealed partial class RequestMirrorPolicy : pb::IMessage<RequestMirrorPolicy> {
                private static readonly pb::MessageParser<RequestMirrorPolicy> _parser = new pb::MessageParser<RequestMirrorPolicy>(() => new RequestMirrorPolicy());
                private pb::UnknownFieldSet _unknownFields;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pb::MessageParser<RequestMirrorPolicy> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public static pbr::MessageDescriptor Descriptor {
                  get { return global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxy.Types.PrefixRoutes.Types.Route.Descriptor.NestedTypes[0]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                pbr::MessageDescriptor pb::IMessage.Descriptor {
                  get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public RequestMirrorPolicy() {
                  OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public RequestMirrorPolicy(RequestMirrorPolicy other) : this() {
                  cluster_ = other.cluster_;
                  runtimeFraction_ = other.runtimeFraction_ != null ? other.runtimeFraction_.Clone() : null;
                  excludeReadCommands_ = other.excludeReadCommands_;
                  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public RequestMirrorPolicy Clone() {
                  return new RequestMirrorPolicy(this);
                }

                /// <summary>Field number for the "cluster" field.</summary>
                public const int ClusterFieldNumber = 1;
                private string cluster_ = "";
                /// <summary>
                /// Specifies the cluster that requests will be mirrored to. The cluster must
                /// exist in the cluster manager configuration.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public string Cluster {
                  get { return cluster_; }
                  set {
                    cluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                  }
                }

                /// <summary>Field number for the "runtime_fraction" field.</summary>
                public const int RuntimeFractionFieldNumber = 2;
                private global::Envoy.Api.V3Alpha.Core.RuntimeFractionalPercent runtimeFraction_;
                /// <summary>
                /// If not specified or the runtime key is not present, all requests to the target cluster
                /// will be mirrored.
                ///
                /// If specified, Envoy will lookup the runtime key to get the percentage of requests to the
                /// mirror.
                ///
                /// Parsing this field is implemented such that the runtime key's data may be represented
                /// as a :ref:`FractionalPercent &lt;envoy_api_msg_type.FractionalPercent>` proto represented
                /// as JSON/YAML and may also be represented as an integer with the assumption that the value
                /// is an integral percentage out of 100. For instance, a runtime key lookup returning the
                /// value "42" would parse as a `FractionalPercent` whose numerator is 42 and denominator is
                /// HUNDRED.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public global::Envoy.Api.V3Alpha.Core.RuntimeFractionalPercent RuntimeFraction {
                  get { return runtimeFraction_; }
                  set {
                    runtimeFraction_ = value;
                  }
                }

                /// <summary>Field number for the "exclude_read_commands" field.</summary>
                public const int ExcludeReadCommandsFieldNumber = 3;
                private bool excludeReadCommands_;
                /// <summary>
                /// Set this to TRUE to only mirror write commands, this is effectively replicating the
                /// writes in a "fire and forget" manner.
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public bool ExcludeReadCommands {
                  get { return excludeReadCommands_; }
                  set {
                    excludeReadCommands_ = value;
                  }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override bool Equals(object other) {
                  return Equals(other as RequestMirrorPolicy);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public bool Equals(RequestMirrorPolicy other) {
                  if (ReferenceEquals(other, null)) {
                    return false;
                  }
                  if (ReferenceEquals(other, this)) {
                    return true;
                  }
                  if (Cluster != other.Cluster) return false;
                  if (!object.Equals(RuntimeFraction, other.RuntimeFraction)) return false;
                  if (ExcludeReadCommands != other.ExcludeReadCommands) return false;
                  return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override int GetHashCode() {
                  int hash = 1;
                  if (Cluster.Length != 0) hash ^= Cluster.GetHashCode();
                  if (runtimeFraction_ != null) hash ^= RuntimeFraction.GetHashCode();
                  if (ExcludeReadCommands != false) hash ^= ExcludeReadCommands.GetHashCode();
                  if (_unknownFields != null) {
                    hash ^= _unknownFields.GetHashCode();
                  }
                  return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public override string ToString() {
                  return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void WriteTo(pb::CodedOutputStream output) {
                  if (Cluster.Length != 0) {
                    output.WriteRawTag(10);
                    output.WriteString(Cluster);
                  }
                  if (runtimeFraction_ != null) {
                    output.WriteRawTag(18);
                    output.WriteMessage(RuntimeFraction);
                  }
                  if (ExcludeReadCommands != false) {
                    output.WriteRawTag(24);
                    output.WriteBool(ExcludeReadCommands);
                  }
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(output);
                  }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public int CalculateSize() {
                  int size = 0;
                  if (Cluster.Length != 0) {
                    size += 1 + pb::CodedOutputStream.ComputeStringSize(Cluster);
                  }
                  if (runtimeFraction_ != null) {
                    size += 1 + pb::CodedOutputStream.ComputeMessageSize(RuntimeFraction);
                  }
                  if (ExcludeReadCommands != false) {
                    size += 1 + 1;
                  }
                  if (_unknownFields != null) {
                    size += _unknownFields.CalculateSize();
                  }
                  return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(RequestMirrorPolicy other) {
                  if (other == null) {
                    return;
                  }
                  if (other.Cluster.Length != 0) {
                    Cluster = other.Cluster;
                  }
                  if (other.runtimeFraction_ != null) {
                    if (runtimeFraction_ == null) {
                      RuntimeFraction = new global::Envoy.Api.V3Alpha.Core.RuntimeFractionalPercent();
                    }
                    RuntimeFraction.MergeFrom(other.RuntimeFraction);
                  }
                  if (other.ExcludeReadCommands != false) {
                    ExcludeReadCommands = other.ExcludeReadCommands;
                  }
                  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                public void MergeFrom(pb::CodedInputStream input) {
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                      case 10: {
                        Cluster = input.ReadString();
                        break;
                      }
                      case 18: {
                        if (runtimeFraction_ == null) {
                          RuntimeFraction = new global::Envoy.Api.V3Alpha.Core.RuntimeFractionalPercent();
                        }
                        input.ReadMessage(RuntimeFraction);
                        break;
                      }
                      case 24: {
                        ExcludeReadCommands = input.ReadBool();
                        break;
                      }
                    }
                  }
                }

              }

            }
            #endregion

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
  /// :ref:`extension_protocol_options&lt;envoy_api_field_Cluster.extension_protocol_options>`, keyed
  /// by the name `envoy.redis_proxy`.
  /// </summary>
  public sealed partial class RedisProtocolOptions : pb::IMessage<RedisProtocolOptions> {
    private static readonly pb::MessageParser<RedisProtocolOptions> _parser = new pb::MessageParser<RedisProtocolOptions>(() => new RedisProtocolOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RedisProtocolOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Network.RedisProxy.V3Alpha.RedisProxyReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedisProtocolOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedisProtocolOptions(RedisProtocolOptions other) : this() {
      authPassword_ = other.authPassword_ != null ? other.authPassword_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RedisProtocolOptions Clone() {
      return new RedisProtocolOptions(this);
    }

    /// <summary>Field number for the "auth_password" field.</summary>
    public const int AuthPasswordFieldNumber = 1;
    private global::Envoy.Api.V3Alpha.Core.DataSource authPassword_;
    /// <summary>
    /// Upstream server password as defined by the `requirepass directive
    /// &lt;https://redis.io/topics/config>`_ in the server's configuration file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V3Alpha.Core.DataSource AuthPassword {
      get { return authPassword_; }
      set {
        authPassword_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RedisProtocolOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RedisProtocolOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(AuthPassword, other.AuthPassword)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (authPassword_ != null) hash ^= AuthPassword.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (authPassword_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(AuthPassword);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (authPassword_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AuthPassword);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RedisProtocolOptions other) {
      if (other == null) {
        return;
      }
      if (other.authPassword_ != null) {
        if (authPassword_ == null) {
          AuthPassword = new global::Envoy.Api.V3Alpha.Core.DataSource();
        }
        AuthPassword.MergeFrom(other.AuthPassword);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (authPassword_ == null) {
              AuthPassword = new global::Envoy.Api.V3Alpha.Core.DataSource();
            }
            input.ReadMessage(AuthPassword);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
