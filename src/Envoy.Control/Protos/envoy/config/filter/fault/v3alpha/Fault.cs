// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: envoy/config/filter/fault/v3alpha/fault.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Filter.Fault.V3Alpha {

  /// <summary>Holder for reflection information generated from envoy/config/filter/fault/v3alpha/fault.proto</summary>
  public static partial class FaultReflection {

    #region Descriptor
    /// <summary>File descriptor for envoy/config/filter/fault/v3alpha/fault.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static FaultReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci1lbnZveS9jb25maWcvZmlsdGVyL2ZhdWx0L3YzYWxwaGEvZmF1bHQucHJv",
            "dG8SIWVudm95LmNvbmZpZy5maWx0ZXIuZmF1bHQudjNhbHBoYRoYZW52b3kv",
            "dHlwZS9wZXJjZW50LnByb3RvGh5nb29nbGUvcHJvdG9idWYvZHVyYXRpb24u",
            "cHJvdG8aF3ZhbGlkYXRlL3ZhbGlkYXRlLnByb3RvIvECCgpGYXVsdERlbGF5",
            "Ek4KBHR5cGUYASABKA4yPC5lbnZveS5jb25maWcuZmlsdGVyLmZhdWx0LnYz",
            "YWxwaGEuRmF1bHREZWxheS5GYXVsdERlbGF5VHlwZUICGAESPAoLZml4ZWRf",
            "ZGVsYXkYAyABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb25CCrrpwAMF",
            "qgECKgBIABJRCgxoZWFkZXJfZGVsYXkYBSABKAsyOS5lbnZveS5jb25maWcu",
            "ZmlsdGVyLmZhdWx0LnYzYWxwaGEuRmF1bHREZWxheS5IZWFkZXJEZWxheUgA",
            "EjEKCnBlcmNlbnRhZ2UYBCABKAsyHS5lbnZveS50eXBlLkZyYWN0aW9uYWxQ",
            "ZXJjZW50Gg0KC0hlYWRlckRlbGF5IhsKDkZhdWx0RGVsYXlUeXBlEgkKBUZJ",
            "WEVEEABCHQoUZmF1bHRfZGVsYXlfc2VjaWZpZXISBbjpwAMBSgQIAhADIsAC",
            "Cg5GYXVsdFJhdGVMaW1pdBJTCgtmaXhlZF9saW1pdBgBIAEoCzI8LmVudm95",
            "LmNvbmZpZy5maWx0ZXIuZmF1bHQudjNhbHBoYS5GYXVsdFJhdGVMaW1pdC5G",
            "aXhlZExpbWl0SAASVQoMaGVhZGVyX2xpbWl0GAMgASgLMj0uZW52b3kuY29u",
            "ZmlnLmZpbHRlci5mYXVsdC52M2FscGhhLkZhdWx0UmF0ZUxpbWl0LkhlYWRl",
            "ckxpbWl0SAASMQoKcGVyY2VudGFnZRgCIAEoCzIdLmVudm95LnR5cGUuRnJh",
            "Y3Rpb25hbFBlcmNlbnQaKwoKRml4ZWRMaW1pdBIdCgpsaW1pdF9rYnBzGAEg",
            "ASgEQgm66cADBDICKAEaDQoLSGVhZGVyTGltaXRCEwoKbGltaXRfdHlwZRIF",
            "uOnAAwFCPwovaW8uZW52b3lwcm94eS5lbnZveS5jb25maWcuZmlsdGVyLmZh",
            "dWx0LnYzYWxwaGFCCkZhdWx0UHJvdG9QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Type.PercentReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay), global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Parser, new[]{ "Type", "FixedDelay", "HeaderDelay", "Percentage" }, new[]{ "FaultDelaySecifier" }, new[]{ typeof(global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.HeaderDelay), global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.HeaderDelay.Parser, null, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit), global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Parser, new[]{ "FixedLimit", "HeaderLimit", "Percentage" }, new[]{ "LimitType" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.FixedLimit), global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.FixedLimit.Parser, new[]{ "LimitKbps" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.HeaderLimit), global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.HeaderLimit.Parser, null, null, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Delay specification is used to inject latency into the
  /// HTTP/gRPC/Mongo/Redis operation or delay proxying of TCP connections.
  /// </summary>
  public sealed partial class FaultDelay : pb::IMessage<FaultDelay> {
    private static readonly pb::MessageParser<FaultDelay> _parser = new pb::MessageParser<FaultDelay>(() => new FaultDelay());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FaultDelay> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Fault.V3Alpha.FaultReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FaultDelay() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FaultDelay(FaultDelay other) : this() {
      type_ = other.type_;
      percentage_ = other.percentage_ != null ? other.percentage_.Clone() : null;
      switch (other.FaultDelaySecifierCase) {
        case FaultDelaySecifierOneofCase.FixedDelay:
          FixedDelay = other.FixedDelay.Clone();
          break;
        case FaultDelaySecifierOneofCase.HeaderDelay:
          HeaderDelay = other.HeaderDelay.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FaultDelay Clone() {
      return new FaultDelay(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType type_ = global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType.Fixed;
    /// <summary>
    /// Unused and deprecated. Will be removed in the next release.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "fixed_delay" field.</summary>
    public const int FixedDelayFieldNumber = 3;
    /// <summary>
    /// Add a fixed delay before forwarding the operation upstream. See
    /// https://developers.google.com/protocol-buffers/docs/proto3#json for
    /// the JSON/YAML Duration mapping. For HTTP/Mongo/Redis, the specified
    /// delay will be injected before a new request/operation. For TCP
    /// connections, the proxying of the connection upstream will be delayed
    /// for the specified period. This is required if type is FIXED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration FixedDelay {
      get { return faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.FixedDelay ? (global::Google.Protobuf.WellKnownTypes.Duration) faultDelaySecifier_ : null; }
      set {
        faultDelaySecifier_ = value;
        faultDelaySecifierCase_ = value == null ? FaultDelaySecifierOneofCase.None : FaultDelaySecifierOneofCase.FixedDelay;
      }
    }

    /// <summary>Field number for the "header_delay" field.</summary>
    public const int HeaderDelayFieldNumber = 5;
    /// <summary>
    /// Fault delays are controlled via an HTTP header (if applicable).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.HeaderDelay HeaderDelay {
      get { return faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.HeaderDelay ? (global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.HeaderDelay) faultDelaySecifier_ : null; }
      set {
        faultDelaySecifier_ = value;
        faultDelaySecifierCase_ = value == null ? FaultDelaySecifierOneofCase.None : FaultDelaySecifierOneofCase.HeaderDelay;
      }
    }

    /// <summary>Field number for the "percentage" field.</summary>
    public const int PercentageFieldNumber = 4;
    private global::Envoy.Type.FractionalPercent percentage_;
    /// <summary>
    /// The percentage of operations/connections/requests on which the delay will be injected.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.FractionalPercent Percentage {
      get { return percentage_; }
      set {
        percentage_ = value;
      }
    }

    private object faultDelaySecifier_;
    /// <summary>Enum of possible cases for the "fault_delay_secifier" oneof.</summary>
    public enum FaultDelaySecifierOneofCase {
      None = 0,
      FixedDelay = 3,
      HeaderDelay = 5,
    }
    private FaultDelaySecifierOneofCase faultDelaySecifierCase_ = FaultDelaySecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FaultDelaySecifierOneofCase FaultDelaySecifierCase {
      get { return faultDelaySecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFaultDelaySecifier() {
      faultDelaySecifierCase_ = FaultDelaySecifierOneofCase.None;
      faultDelaySecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FaultDelay);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FaultDelay other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (!object.Equals(FixedDelay, other.FixedDelay)) return false;
      if (!object.Equals(HeaderDelay, other.HeaderDelay)) return false;
      if (!object.Equals(Percentage, other.Percentage)) return false;
      if (FaultDelaySecifierCase != other.FaultDelaySecifierCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType.Fixed) hash ^= Type.GetHashCode();
      if (faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.FixedDelay) hash ^= FixedDelay.GetHashCode();
      if (faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.HeaderDelay) hash ^= HeaderDelay.GetHashCode();
      if (percentage_ != null) hash ^= Percentage.GetHashCode();
      hash ^= (int) faultDelaySecifierCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Type != global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType.Fixed) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Type);
      }
      if (faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.FixedDelay) {
        output.WriteRawTag(26);
        output.WriteMessage(FixedDelay);
      }
      if (percentage_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Percentage);
      }
      if (faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.HeaderDelay) {
        output.WriteRawTag(42);
        output.WriteMessage(HeaderDelay);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType.Fixed) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.FixedDelay) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FixedDelay);
      }
      if (faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.HeaderDelay) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderDelay);
      }
      if (percentage_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Percentage);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FaultDelay other) {
      if (other == null) {
        return;
      }
      if (other.Type != global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType.Fixed) {
        Type = other.Type;
      }
      if (other.percentage_ != null) {
        if (percentage_ == null) {
          Percentage = new global::Envoy.Type.FractionalPercent();
        }
        Percentage.MergeFrom(other.Percentage);
      }
      switch (other.FaultDelaySecifierCase) {
        case FaultDelaySecifierOneofCase.FixedDelay:
          if (FixedDelay == null) {
            FixedDelay = new global::Google.Protobuf.WellKnownTypes.Duration();
          }
          FixedDelay.MergeFrom(other.FixedDelay);
          break;
        case FaultDelaySecifierOneofCase.HeaderDelay:
          if (HeaderDelay == null) {
            HeaderDelay = new global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.HeaderDelay();
          }
          HeaderDelay.MergeFrom(other.HeaderDelay);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = (global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.FaultDelayType) input.ReadEnum();
            break;
          }
          case 26: {
            global::Google.Protobuf.WellKnownTypes.Duration subBuilder = new global::Google.Protobuf.WellKnownTypes.Duration();
            if (faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.FixedDelay) {
              subBuilder.MergeFrom(FixedDelay);
            }
            input.ReadMessage(subBuilder);
            FixedDelay = subBuilder;
            break;
          }
          case 34: {
            if (percentage_ == null) {
              Percentage = new global::Envoy.Type.FractionalPercent();
            }
            input.ReadMessage(Percentage);
            break;
          }
          case 42: {
            global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.HeaderDelay subBuilder = new global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Types.HeaderDelay();
            if (faultDelaySecifierCase_ == FaultDelaySecifierOneofCase.HeaderDelay) {
              subBuilder.MergeFrom(HeaderDelay);
            }
            input.ReadMessage(subBuilder);
            HeaderDelay = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FaultDelay message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum FaultDelayType {
        /// <summary>
        /// Unused and deprecated.
        /// </summary>
        [pbr::OriginalName("FIXED")] Fixed = 0,
      }

      /// <summary>
      /// Fault delays are controlled via an HTTP header (if applicable). See the
      /// :ref:`http fault filter &lt;config_http_filters_fault_injection_http_header>` documentation for
      /// more information.
      /// </summary>
      public sealed partial class HeaderDelay : pb::IMessage<HeaderDelay> {
        private static readonly pb::MessageParser<HeaderDelay> _parser = new pb::MessageParser<HeaderDelay>(() => new HeaderDelay());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HeaderDelay> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Fault.V3Alpha.FaultDelay.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HeaderDelay() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HeaderDelay(HeaderDelay other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HeaderDelay Clone() {
          return new HeaderDelay(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HeaderDelay);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HeaderDelay other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HeaderDelay other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Describes a rate limit to be applied.
  /// </summary>
  public sealed partial class FaultRateLimit : pb::IMessage<FaultRateLimit> {
    private static readonly pb::MessageParser<FaultRateLimit> _parser = new pb::MessageParser<FaultRateLimit>(() => new FaultRateLimit());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FaultRateLimit> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Filter.Fault.V3Alpha.FaultReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FaultRateLimit() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FaultRateLimit(FaultRateLimit other) : this() {
      percentage_ = other.percentage_ != null ? other.percentage_.Clone() : null;
      switch (other.LimitTypeCase) {
        case LimitTypeOneofCase.FixedLimit:
          FixedLimit = other.FixedLimit.Clone();
          break;
        case LimitTypeOneofCase.HeaderLimit:
          HeaderLimit = other.HeaderLimit.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FaultRateLimit Clone() {
      return new FaultRateLimit(this);
    }

    /// <summary>Field number for the "fixed_limit" field.</summary>
    public const int FixedLimitFieldNumber = 1;
    /// <summary>
    /// A fixed rate limit.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.FixedLimit FixedLimit {
      get { return limitTypeCase_ == LimitTypeOneofCase.FixedLimit ? (global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.FixedLimit) limitType_ : null; }
      set {
        limitType_ = value;
        limitTypeCase_ = value == null ? LimitTypeOneofCase.None : LimitTypeOneofCase.FixedLimit;
      }
    }

    /// <summary>Field number for the "header_limit" field.</summary>
    public const int HeaderLimitFieldNumber = 3;
    /// <summary>
    /// Rate limits are controlled via an HTTP header (if applicable).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.HeaderLimit HeaderLimit {
      get { return limitTypeCase_ == LimitTypeOneofCase.HeaderLimit ? (global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.HeaderLimit) limitType_ : null; }
      set {
        limitType_ = value;
        limitTypeCase_ = value == null ? LimitTypeOneofCase.None : LimitTypeOneofCase.HeaderLimit;
      }
    }

    /// <summary>Field number for the "percentage" field.</summary>
    public const int PercentageFieldNumber = 2;
    private global::Envoy.Type.FractionalPercent percentage_;
    /// <summary>
    /// The percentage of operations/connections/requests on which the rate limit will be injected.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Type.FractionalPercent Percentage {
      get { return percentage_; }
      set {
        percentage_ = value;
      }
    }

    private object limitType_;
    /// <summary>Enum of possible cases for the "limit_type" oneof.</summary>
    public enum LimitTypeOneofCase {
      None = 0,
      FixedLimit = 1,
      HeaderLimit = 3,
    }
    private LimitTypeOneofCase limitTypeCase_ = LimitTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LimitTypeOneofCase LimitTypeCase {
      get { return limitTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLimitType() {
      limitTypeCase_ = LimitTypeOneofCase.None;
      limitType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FaultRateLimit);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FaultRateLimit other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FixedLimit, other.FixedLimit)) return false;
      if (!object.Equals(HeaderLimit, other.HeaderLimit)) return false;
      if (!object.Equals(Percentage, other.Percentage)) return false;
      if (LimitTypeCase != other.LimitTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (limitTypeCase_ == LimitTypeOneofCase.FixedLimit) hash ^= FixedLimit.GetHashCode();
      if (limitTypeCase_ == LimitTypeOneofCase.HeaderLimit) hash ^= HeaderLimit.GetHashCode();
      if (percentage_ != null) hash ^= Percentage.GetHashCode();
      hash ^= (int) limitTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (limitTypeCase_ == LimitTypeOneofCase.FixedLimit) {
        output.WriteRawTag(10);
        output.WriteMessage(FixedLimit);
      }
      if (percentage_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Percentage);
      }
      if (limitTypeCase_ == LimitTypeOneofCase.HeaderLimit) {
        output.WriteRawTag(26);
        output.WriteMessage(HeaderLimit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (limitTypeCase_ == LimitTypeOneofCase.FixedLimit) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FixedLimit);
      }
      if (limitTypeCase_ == LimitTypeOneofCase.HeaderLimit) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HeaderLimit);
      }
      if (percentage_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Percentage);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FaultRateLimit other) {
      if (other == null) {
        return;
      }
      if (other.percentage_ != null) {
        if (percentage_ == null) {
          Percentage = new global::Envoy.Type.FractionalPercent();
        }
        Percentage.MergeFrom(other.Percentage);
      }
      switch (other.LimitTypeCase) {
        case LimitTypeOneofCase.FixedLimit:
          if (FixedLimit == null) {
            FixedLimit = new global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.FixedLimit();
          }
          FixedLimit.MergeFrom(other.FixedLimit);
          break;
        case LimitTypeOneofCase.HeaderLimit:
          if (HeaderLimit == null) {
            HeaderLimit = new global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.HeaderLimit();
          }
          HeaderLimit.MergeFrom(other.HeaderLimit);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.FixedLimit subBuilder = new global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.FixedLimit();
            if (limitTypeCase_ == LimitTypeOneofCase.FixedLimit) {
              subBuilder.MergeFrom(FixedLimit);
            }
            input.ReadMessage(subBuilder);
            FixedLimit = subBuilder;
            break;
          }
          case 18: {
            if (percentage_ == null) {
              Percentage = new global::Envoy.Type.FractionalPercent();
            }
            input.ReadMessage(Percentage);
            break;
          }
          case 26: {
            global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.HeaderLimit subBuilder = new global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Types.HeaderLimit();
            if (limitTypeCase_ == LimitTypeOneofCase.HeaderLimit) {
              subBuilder.MergeFrom(HeaderLimit);
            }
            input.ReadMessage(subBuilder);
            HeaderLimit = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FaultRateLimit message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Describes a fixed/constant rate limit.
      /// </summary>
      public sealed partial class FixedLimit : pb::IMessage<FixedLimit> {
        private static readonly pb::MessageParser<FixedLimit> _parser = new pb::MessageParser<FixedLimit>(() => new FixedLimit());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<FixedLimit> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public FixedLimit() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public FixedLimit(FixedLimit other) : this() {
          limitKbps_ = other.limitKbps_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public FixedLimit Clone() {
          return new FixedLimit(this);
        }

        /// <summary>Field number for the "limit_kbps" field.</summary>
        public const int LimitKbpsFieldNumber = 1;
        private ulong limitKbps_;
        /// <summary>
        /// The limit supplied in KiB/s.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong LimitKbps {
          get { return limitKbps_; }
          set {
            limitKbps_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as FixedLimit);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(FixedLimit other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (LimitKbps != other.LimitKbps) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (LimitKbps != 0UL) hash ^= LimitKbps.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (LimitKbps != 0UL) {
            output.WriteRawTag(8);
            output.WriteUInt64(LimitKbps);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (LimitKbps != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(LimitKbps);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(FixedLimit other) {
          if (other == null) {
            return;
          }
          if (other.LimitKbps != 0UL) {
            LimitKbps = other.LimitKbps;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                LimitKbps = input.ReadUInt64();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Rate limits are controlled via an HTTP header (if applicable). See the
      /// :ref:`http fault filter &lt;config_http_filters_fault_injection_http_header>` documentation for
      /// more information.
      /// </summary>
      public sealed partial class HeaderLimit : pb::IMessage<HeaderLimit> {
        private static readonly pb::MessageParser<HeaderLimit> _parser = new pb::MessageParser<HeaderLimit>(() => new HeaderLimit());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HeaderLimit> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Filter.Fault.V3Alpha.FaultRateLimit.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HeaderLimit() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HeaderLimit(HeaderLimit other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HeaderLimit Clone() {
          return new HeaderLimit(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HeaderLimit);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HeaderLimit other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HeaderLimit other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
